Date: Thu, 2 Jul 2020 17:48:20 +0530
Subject: [PATCH] 1. Added libitls.a library for esp32 platform 2. Added OPTIGA
 Trust M2 ID2 host code 3. Modified the mqttapp to host random data in cloud
 4. Added optiga_se_adapter.c file 5. Modified i2c driver code to support
 maximum 20bytes of data.

---
 .vscode/tasks.json                            |    3 +-
 .../alios/example_optiga_se_adapter.c         |  268 +
 .../examples/optiga/example_utilities.c       |  141 +
 .../examples/optiga/include/optiga_example.h  |  152 +
 .../aes_key_object_confidentiality.h          |  202 +
 .../protected_update_data_set/data_object.h   |  209 +
 .../data_object_confidentiality.h             |  262 +
 .../example_optiga_util_protected_update.h    |  177 +
 .../metadata_object_confidentiality.h         |  199 +
 .../rsa_key_object_confidentiality.h          |  218 +
 .../usecases/example_ali_id2_key_update.c     |  437 ++
 .../usecases/example_ali_id2_rsa_key_update.c |  501 ++
 .../example_optiga_hibernate_restore.c        |  254 +
 ..._host_and_optiga_using_pre_shared_secret.c |  265 +
 .../usecases/example_read_coprocessor_id.c    |  228 +
 .../optiga/examples/optiga_shell.c            |  743 +++
 .../bin/protected_update_data_set.exe         |  Bin 0 -> 109568 bytes
 .../protected_update_data_set/include/cbor.h  |   65 +
 .../include/common_utilites.h                 |   59 +
 .../include/pal/pal_crypt.h                   |  125 +
 .../include/pal/pal_file_system.h             |   60 +
 .../include/pal/pal_logger.h                  |   63 +
 .../include/pal/pal_os_memory.h               |   63 +
 .../include/protected_update_data_set.h       |  265 +
 .../protected_update_data_set_version.h       |   47 +
 .../include/user_input_parser.h               |   54 +
 .../pal/pal_crypt_mbedtls.c                   |  557 ++
 .../pal/pal_file_system.c                     |  196 +
 .../pal/pal_logger.c                          |  118 +
 .../pal/pal_os_memory.c                       |   70 +
 .../protected_update_data_set/readme.txt      |   32 +
 .../samples/confidentiality/secret.txt        |    1 +
 .../samples/gen_data_update_data_set.bat      |   11 +
 .../samples/gen_key_update_data_set.bat       |   22 +
 .../samples/gen_metadata_update_data_set.bat  |    7 +
 .../integrity/sample_rsa_1024_cert.txt        |   46 +
 .../integrity/sample_rsa_1024_priv.pem        |   15 +
 .../integrity/sample_rsa_2048_cert.txt        |   55 +
 .../integrity/sample_rsa_2048_priv.pem        |   27 +
 .../samples/payload/data/ascii_data.txt       |   11 +
 .../samples/payload/data/hex_data.txt         |   19 +
 .../samples/payload/key/aes_key_128.txt       |    1 +
 .../samples/payload/key/aes_key_192.txt       |    2 +
 .../samples/payload/key/aes_key_256.txt       |    2 +
 .../samples/payload/key/rsa_1024_test.pem     |   15 +
 .../samples/payload/key/rsa_1024_test.pem1    |   15 +
 .../samples/payload/key/rsa_2048_test.pem     |   27 +
 .../samples/payload/metadata/metadata.txt     |    1 +
 .../protected_update_data_set/src/cbor.c      |  158 +
 .../src/common_utilities.c                    |   81 +
 .../src/protected_update_data_set.c           | 1149 +++++
 .../src/user_input_parser.c                   |  929 ++++
 .../visual_studio/main.c                      |  113 +
 .../protected_update_data_set.sln             |   20 +
 .../protected_update_data_set.vcxproj         |  186 +
 .../protected_update_data_set.vcxproj.filters |  315 ++
 .../optiga/externals/alios/LICENSE            |  201 +
 .../se/chipset/chip_template/chip_config.h    |   51 +
 .../chip_template/include/error_code.h        |   32 +
 .../chipset/chip_template/include/irot_hal.h  |  259 +
 .../chipset/chip_template/include/se_driver.h |   51 +
 .../security/irot/se/src/core/km_to_irot.c    |  220 +
 .../irot/se/src/core/optiga_se_adapter.c      |  702 +++
 .../optiga/optiga/cmd/optiga_cmd.c            | 4468 +++++++++++++++++
 .../optiga/optiga/common/optiga_lib_common.c  |   72 +
 .../optiga/optiga/common/optiga_lib_logger.c  |  260 +
 .../optiga/optiga/comms/ifx_i2c/ifx_i2c.c     |  355 ++
 .../optiga/comms/ifx_i2c/ifx_i2c_config.c     |  114 +
 .../comms/ifx_i2c/ifx_i2c_data_link_layer.c   |  690 +++
 .../comms/ifx_i2c/ifx_i2c_physical_layer.c    |  799 +++
 .../ifx_i2c/ifx_i2c_presentation_layer.c      | 1173 +++++
 .../comms/ifx_i2c/ifx_i2c_transport_layer.c   |  569 +++
 .../optiga/comms/optiga_comms_ifx_i2c.c       |  222 +
 .../optiga/optiga/crypt/optiga_crypt.c        | 2052 ++++++++
 .../optiga/include/optiga/cmd/optiga_cmd.h    |  703 +++
 .../include/optiga/common/optiga_lib_common.h |  659 +++
 .../common/optiga_lib_common_internal.h       |  113 +
 .../include/optiga/common/optiga_lib_logger.h |  241 +
 .../optiga/common/optiga_lib_return_codes.h   |  140 +
 .../include/optiga/common/optiga_lib_types.h  |  131 +
 .../include/optiga/comms/optiga_comms.h       |  342 ++
 .../optiga/include/optiga/ifx_i2c/ifx_i2c.h   |  274 +
 .../include/optiga/ifx_i2c/ifx_i2c_config.h   |  488 ++
 .../optiga/ifx_i2c/ifx_i2c_data_link_layer.h  |  128 +
 .../optiga/ifx_i2c/ifx_i2c_physical_layer.h   |  146 +
 .../ifx_i2c/ifx_i2c_presentation_layer.h      |  132 +
 .../optiga/ifx_i2c/ifx_i2c_transport_layer.h  |  105 +
 .../optiga/include/optiga/optiga_crypt.h      | 2338 +++++++++
 .../optiga/include/optiga/optiga_lib_config.h |  142 +
 .../include/optiga/optiga_lib_version.h       |   56 +
 .../optiga/include/optiga/optiga_util.h       |  624 +++
 .../optiga/optiga/include/optiga/pal/pal.h    |  106 +
 .../optiga/include/optiga/pal/pal_crypt.h     |  217 +
 .../optiga/include/optiga/pal/pal_gpio.h      |  146 +
 .../optiga/include/optiga/pal/pal_i2c.h       |  244 +
 .../include/optiga/pal/pal_ifx_i2c_config.h   |   62 +
 .../optiga/include/optiga/pal/pal_logger.h    |  155 +
 .../include/optiga/pal/pal_os_datastore.h     |  130 +
 .../optiga/include/optiga/pal/pal_os_event.h  |  191 +
 .../optiga/include/optiga/pal/pal_os_lock.h   |  166 +
 .../optiga/include/optiga/pal/pal_os_memory.h |  162 +
 .../optiga/include/optiga/pal/pal_os_timer.h  |  142 +
 .../optiga/optiga/util/optiga_util.c          |  672 +++
 3rdparty/experimental/optiga/pal/esp32/pal.c  |   57 +
 .../experimental/optiga/pal/esp32/pal_gpio.c  |   81 +
 .../experimental/optiga/pal/esp32/pal_i2c.c   |  260 +
 .../optiga/pal/esp32/pal_ifx_i2c_config.c     |   91 +
 .../optiga/pal/esp32/pal_logger.c             |  109 +
 .../optiga/pal/esp32/pal_os_datastore.c       |  192 +
 .../optiga/pal/esp32/pal_os_event.c           |  138 +
 .../optiga/pal/esp32/pal_os_lock.c            |   87 +
 .../optiga/pal/esp32/pal_os_memory.c          |   67 +
 .../optiga/pal/esp32/pal_os_random.c          |   73 +
 .../optiga/pal/esp32/pal_os_timer.c           |  100 +
 .../optiga/pal/pal_crypt_mbedtls.c            |  304 ++
 .../optiga/pal/pal_crypt_wolfssl.c            |  230 +
 .../optiga/projects/esp32_alios/Config.in     |    9 +
 .../optiga/projects/esp32_alios/aos.mk        |   49 +
 app/example/mqttapp/app_entry.c               |    2 +-
 app/example/mqttapp/mqtt_example.c            |   22 +-
 board/esp32devkitc/Config.in                  |    8 +
 board/esp32devkitc/k_config.h                 |    2 +-
 build/build_rules/aos_target_config.mk        |    1 +
 .../toolchain/aos_toolchain_xtensa.mk         |    2 +-
 include/aos/hal/i2c.h                         |    2 +
 platform/mcu/esp32/aos.mk                     |    2 +-
 platform/mcu/esp32/hal/i2c.c                  |  113 +-
 security/Config.in                            |    3 +-
 security/id2/aos.mk                           |    2 +-
 security/irot/Config.in                       |    6 +-
 security/irot/se/aos.mk                       |    3 +
 .../se/chipset/chip_template/chip_config.h    |    7 +-
 security/irot/se/src/core/km_to_irot.c        |    3 +
 security/irot/se/src/core/optiga_se_adapter.c |  702 +++
 security/itls/lib/xtensa/libitls.a            |  Bin 0 -> 111336 bytes
 security/itls/src/mbedtls_alt.c               |   38 +-
 136 files changed, 33427 insertions(+), 44 deletions(-)
 create mode 100644 3rdparty/experimental/optiga/examples/integration/alios/example_optiga_se_adapter.c
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/example_utilities.c
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/include/optiga_example.h
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/aes_key_object_confidentiality.h
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/data_object.h
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/data_object_confidentiality.h
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/example_optiga_util_protected_update.h
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/metadata_object_confidentiality.h
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/rsa_key_object_confidentiality.h
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/usecases/example_ali_id2_key_update.c
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/usecases/example_ali_id2_rsa_key_update.c
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/usecases/example_optiga_hibernate_restore.c
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/usecases/example_pair_host_and_optiga_using_pre_shared_secret.c
 create mode 100644 3rdparty/experimental/optiga/examples/optiga/usecases/example_read_coprocessor_id.c
 create mode 100644 3rdparty/experimental/optiga/examples/optiga_shell.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/bin/protected_update_data_set.exe
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/cbor.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/common_utilites.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_crypt.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_file_system.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_logger.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_os_memory.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/protected_update_data_set.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/protected_update_data_set_version.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/user_input_parser.h
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_crypt_mbedtls.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_file_system.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_logger.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_os_memory.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/readme.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/confidentiality/secret.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_data_update_data_set.bat
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_key_update_data_set.bat
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_metadata_update_data_set.bat
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_1024_cert.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_1024_priv.pem
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_2048_cert.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_2048_priv.pem
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/data/ascii_data.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/data/hex_data.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_128.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_192.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_256.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_1024_test.pem
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_1024_test.pem1
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_2048_test.pem
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/metadata/metadata.txt
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/cbor.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/common_utilities.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/protected_update_data_set.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/user_input_parser.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/main.c
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.sln
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.vcxproj
 create mode 100644 3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.vcxproj.filters
 create mode 100644 3rdparty/experimental/optiga/externals/alios/LICENSE
 create mode 100644 3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/chip_config.h
 create mode 100644 3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/error_code.h
 create mode 100644 3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/irot_hal.h
 create mode 100644 3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/se_driver.h
 create mode 100644 3rdparty/experimental/optiga/externals/alios/security/irot/se/src/core/km_to_irot.c
 create mode 100644 3rdparty/experimental/optiga/externals/alios/security/irot/se/src/core/optiga_se_adapter.c
 create mode 100644 3rdparty/experimental/optiga/optiga/cmd/optiga_cmd.c
 create mode 100644 3rdparty/experimental/optiga/optiga/common/optiga_lib_common.c
 create mode 100644 3rdparty/experimental/optiga/optiga/common/optiga_lib_logger.c
 create mode 100644 3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c.c
 create mode 100644 3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_config.c
 create mode 100644 3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_data_link_layer.c
 create mode 100644 3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c
 create mode 100644 3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_presentation_layer.c
 create mode 100644 3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_transport_layer.c
 create mode 100644 3rdparty/experimental/optiga/optiga/comms/optiga_comms_ifx_i2c.c
 create mode 100644 3rdparty/experimental/optiga/optiga/crypt/optiga_crypt.c
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/cmd/optiga_cmd.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_common.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_common_internal.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_logger.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_return_codes.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_types.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/comms/optiga_comms.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_config.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_data_link_layer.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_physical_layer.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_presentation_layer.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_transport_layer.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/optiga_crypt.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/optiga_lib_config.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/optiga_lib_version.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/optiga_util.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_crypt.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_gpio.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_i2c.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_ifx_i2c_config.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_logger.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_datastore.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_event.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_lock.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_memory.h
 create mode 100644 3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_timer.h
 create mode 100644 3rdparty/experimental/optiga/optiga/util/optiga_util.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_gpio.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_i2c.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_ifx_i2c_config.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_logger.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_os_datastore.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_os_event.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_os_lock.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_os_memory.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_os_random.c
 create mode 100644 3rdparty/experimental/optiga/pal/esp32/pal_os_timer.c
 create mode 100644 3rdparty/experimental/optiga/pal/pal_crypt_mbedtls.c
 create mode 100644 3rdparty/experimental/optiga/pal/pal_crypt_wolfssl.c
 create mode 100644 3rdparty/experimental/optiga/projects/esp32_alios/Config.in
 create mode 100644 3rdparty/experimental/optiga/projects/esp32_alios/aos.mk
 create mode 100644 security/irot/se/src/core/optiga_se_adapter.c
 create mode 100644 security/itls/lib/xtensa/libitls.a

diff --git a/.vscode/tasks.json b/.vscode/tasks.json
index 035607884..d8de39e3c 100644
--- a/.vscode/tasks.json
+++ b/.vscode/tasks.json
@@ -20,7 +20,8 @@
       "type": "shell",
       "command": "aos",
       "args": [
-        "make"
+        "make",
+        "helloworld@developerkit"
       ],
       "presentation": {
         "focus": true
diff --git a/3rdparty/experimental/optiga/examples/integration/alios/example_optiga_se_adapter.c b/3rdparty/experimental/optiga/examples/integration/alios/example_optiga_se_adapter.c
new file mode 100644
index 000000000..0d02b1bc8
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/integration/alios/example_optiga_se_adapter.c
@@ -0,0 +1,268 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file example_optiga_se_adapter.c
+*
+* \brief   This file provides an example of ali id2 usecase with irot hal APIs from optiga
+*
+* \ingroup grUseCases
+*
+* @{
+*/
+
+#include "chip_config.h"
+#include "irot_hal.h"
+#include "optiga_example.h"
+#include "optiga/pal/pal_os_memory.h"
+#include "optiga/common/optiga_lib_return_codes.h"
+
+#define PLAIN_TEXT_SIZE             (0x20)    
+#if ((CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES) || (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_3DES))
+//lint --e{526} suppress "symbol not defined"
+void example_optiga_crypt_symmetric_generate_key(void);
+#endif
+#if (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_RSA)
+void example_optiga_util_protected_update(void);
+#endif
+/**
+ * The below example demonstrates usage of IROT HAL APIs for Ali ID2 client usecase
+ */
+#if ((CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES) || (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_3DES))
+void example_optiga_se_adapter_aes(void)
+{ 
+    
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+    uint8_t device_id_buffer[12];
+    uint32_t device_id_buffer_length = sizeof(device_id_buffer);
+
+    const uint8_t plain_text[PLAIN_TEXT_SIZE] = {
+                                    0x6c, 0x69, 0x6e, 0x65, 0x31, 0x20, 0x3a, 0x20, 
+                                    0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 
+                                    0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 
+                                    0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64
+                                };
+    
+    uint8_t cipher_text[PLAIN_TEXT_SIZE];
+    uint32_t cipher_text_length = sizeof(cipher_text);
+    uint8_t decipher_text[PLAIN_TEXT_SIZE];    
+    uint32_t decipher_text_length = sizeof(decipher_text);
+    sym_crypto_param_t sym_crypto_param;
+    
+    pal_os_memset(cipher_text,0x00,cipher_text_length);    
+    pal_os_memset(decipher_text,0x00,decipher_text_length);
+
+    OPTIGA_EXAMPLE_LOG_MESSAGE(__FUNCTION__);
+                                
+    do
+    {
+        /**
+         * 1. Initialize IROT HAL layer and power on OPTIGA.
+         */
+        return_status = irot_hal_init();
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        /**
+         * 2. Obtain Device ID
+         */
+        return_status = irot_hal_get_id2(device_id_buffer,&device_id_buffer_length);
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        /**
+         * 3. Update the symmetric key in 0xE200
+         */        
+        example_optiga_crypt_symmetric_generate_key();
+        
+        /**
+         * 4. Encrypt the plain text using ECB mode of operation
+         */
+        sym_crypto_param.block_mode = BLOCK_MODE_ECB;
+        sym_crypto_param.mode = MODE_ENCRYPT;
+        sym_crypto_param.padding_type = SYM_PADDING_NOPADDING;
+        
+        return_status = irot_hal_sym_crypto(NULL,
+                                            0, 
+                                            NULL,
+                                            0,
+                                            plain_text,
+                                            sizeof(plain_text),
+                                            cipher_text, 
+                                            &cipher_text_length, 
+                                            &sym_crypto_param);
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+        
+        /**
+         * 5. Decrypt the cipher text using ECB mode of operation
+         */
+        sym_crypto_param.block_mode = BLOCK_MODE_ECB;
+        sym_crypto_param.mode = MODE_DECRYPT;
+        sym_crypto_param.padding_type = SYM_PADDING_NOPADDING;
+
+        return_status = irot_hal_sym_crypto(NULL,
+                                            0, 
+                                            NULL,
+                                            0,
+                                            cipher_text,
+                                            cipher_text_length,
+                                            decipher_text, 
+                                            &decipher_text_length, 
+                                            &sym_crypto_param);        
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+        
+    } while (FALSE);
+    OPTIGA_EXAMPLE_LOG_STATUS((optiga_lib_status_t)(int)return_status);
+
+    /**
+     * 6. Power down OPTIGA and de-initialize IROTHAL layer
+     */
+    return_status = irot_hal_cleanup();
+    if(IROT_SUCCESS != return_status)
+    {
+        //lint --e{774} suppress This is a generic macro
+        OPTIGA_EXAMPLE_LOG_STATUS((optiga_lib_status_t)(int)return_status);
+    }
+
+}
+#endif
+
+#if (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_RSA)
+void example_optiga_se_adapter_rsa(void)
+{ 
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+    uint8_t device_id_buffer[12];
+    uint32_t device_id_buffer_length = sizeof(device_id_buffer);
+
+    uint8_t cipher_text[LENGTH_RSA_1024] = {
+        0xBD, 0x6B, 0x42, 0xE3, 0x4E, 0x62, 0x77, 0x25, 0x89, 0x62, 0x8C, 0x32, 0x8D, 0xF5, 0xC0, 0x07,
+        0xAE, 0x05, 0x0C, 0x24, 0x60, 0x98, 0x48, 0x83, 0x6E, 0x76, 0xDB, 0x33, 0x41, 0x40, 0xDF, 0x70,
+        0xFC, 0x01, 0x6A, 0x6C, 0x10, 0xF2, 0xD0, 0x34, 0xBE, 0x9F, 0x6C, 0xE9, 0xE5, 0x5A, 0x7A, 0x69,
+        0xCA, 0x52, 0x60, 0xF9, 0x26, 0x5F, 0x74, 0xFB, 0x6B, 0xB4, 0x19, 0xF8, 0x3B, 0xFE, 0x40, 0xF9,
+        0x0F, 0x17, 0xB4, 0x38, 0x47, 0xF3, 0x96, 0xA0, 0xFF, 0xF3, 0xE1, 0x0B, 0x71, 0xE0, 0xC8, 0x58,
+        0xE3, 0x53, 0x52, 0xDB, 0xB0, 0x13, 0xC1, 0xBE, 0x17, 0xB6, 0x9E, 0xC1, 0xF1, 0xD7, 0x32, 0xBE,
+        0xD4, 0xCC, 0x9B, 0x3C, 0x36, 0x8A, 0x4F, 0x55, 0xB2, 0xEB, 0xF8, 0x9A, 0x4C, 0x1C, 0x64, 0xE0,
+        0x8C, 0x6F, 0x80, 0x03, 0x26, 0xD0, 0x72, 0x33, 0x4E, 0x0A, 0x66, 0x4F, 0xF8, 0x61, 0x66, 0xA4
+    };
+    // SHA-256 digest to be signed
+    static uint8_t digest [] =
+    {
+        0x61, 0xC7, 0xDE, 0xF9, 0x0F, 0xD5, 0xCD, 0x7A,0x8B, 0x7A, 0x36, 0x41, 0x04, 0xE0, 0x0D, 0x82,
+        0x38, 0x46, 0xBF, 0xB7, 0x70, 0xEE, 0xBF, 0x8F,0x40, 0x25, 0x2E, 0x0A, 0x21, 0x42, 0xAF, 0x9C,
+    };
+
+    uint8_t signature [200];
+    uint32_t signature_length = sizeof(signature);
+    uint32_t cipher_text_length = sizeof(cipher_text);
+    uint8_t decipher_text[PLAIN_TEXT_SIZE];    
+    uint32_t decipher_text_length = sizeof(decipher_text);
+    irot_asym_padding_t padding;
+
+    pal_os_memset(decipher_text,0x00,decipher_text_length);
+
+    OPTIGA_EXAMPLE_LOG_MESSAGE(__FUNCTION__);
+                                
+    do
+    {
+        /**
+         * 1. Initialize IROT HAL layer and power on OPTIGA.
+         */
+        return_status = irot_hal_init();
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        /**
+         * 2. Obtain Device ID
+         */
+        return_status = irot_hal_get_id2(device_id_buffer,&device_id_buffer_length);
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        /**
+         * 3. Update the asymmetric key in 0xE0FC. RSA key update macro should be enabled in below example
+         */        
+        example_optiga_util_protected_update();
+        
+        return_status = irot_hal_asym_priv_sign(NULL,
+                                               0, 
+                                               digest,
+                                               sizeof(digest),
+                                               signature, 
+                                               &signature_length, 
+                                               ASYM_TYPE_RSA_SHA256_PKCS1);
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+        /**
+         * 4. Decrypt the cipher text
+         */
+        padding = ASYM_PADDING_PKCS1;
+        return_status = irot_hal_asym_priv_decrypt(NULL,
+                                                   0, 
+                                                   cipher_text,
+                                                   cipher_text_length,
+                                                   decipher_text, 
+                                                   &decipher_text_length, 
+                                                   padding);
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+    } while (FALSE);
+    OPTIGA_EXAMPLE_LOG_STATUS((optiga_lib_status_t)(int)return_status);
+
+    /**
+     * 5. Power down OPTIGA and de-initialize IROTHAL layer
+     */
+    return_status = irot_hal_cleanup();
+    if(IROT_SUCCESS != return_status)
+    {
+        //lint --e{774} suppress This is a generic macro
+        OPTIGA_EXAMPLE_LOG_STATUS((optiga_lib_status_t)(int)return_status);
+    }
+
+}
+#endif
+        
+/**
+ * @}
+ */
diff --git a/3rdparty/experimental/optiga/examples/optiga/example_utilities.c b/3rdparty/experimental/optiga/examples/optiga/example_utilities.c
new file mode 100644
index 000000000..5be409af0
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/example_utilities.c
@@ -0,0 +1,141 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file example_utilities.c
+*
+* \brief   This file provides the utilities for example code.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include "optiga/pal/pal_os_memory.h"
+#include "optiga/common/optiga_lib_return_codes.h"
+
+#define OPTIGA_EXAMPLE_UTIL_RSA_NEGATIVE_INTEGER          (0x7F)
+#define OPTIGA_EXAMPLE_UTIL_DER_BITSTRING_TAG               (0x03)
+#define OPTIGA_EXAMPLE_UTIL_DER_NUM_UNUSED_BITS             (0x00)
+
+#define OPTIGA_EXAMPLE_UTIL_SET_DER_LENGTH(buffer, index, value) \
+                                {\
+                                    uint16_t position = *index; \
+                                    if (0xFF < value) \
+                                    { \
+                                        buffer[position++] = (value & 0xFF00) >> 8; \
+                                    } \
+                                    buffer[position++] = (value & 0xFF); \
+                                    *index = position; \
+                                }
+                                
+//lint --e{838} suppress "first time use of modulus_signed_bit_len and length_field_in_bytes"
+void example_util_encode_rsa_public_key_in_bit_string_format(const uint8_t * n_buffer,
+                                                        uint16_t n_length,
+                                                        const uint8_t * e_buffer,
+                                                        uint16_t e_length,
+                                                        uint8_t * pub_key_buffer,
+                                                        uint16_t * pub_key_length)
+{
+#define OPTIGA_EXAMPLE_UTIL_RSA_DER_MIN_LEN_FIELD     (0x80)
+#define OPTIGA_EXAMPLE_UTIL_RSA_DER_SEQUENCE_TAG      (0x30)
+#define OPTIGA_EXAMPLE_UTIL_RSA_DER_INTEGER_TAG       (0x02)
+
+    uint16_t index = 0;
+    uint16_t modulus_signed_bit_len = 0;
+    uint8_t length_field_in_bytes = 0;
+
+    // Check if the first byte of modulus is a negative integer
+    modulus_signed_bit_len = ((OPTIGA_EXAMPLE_UTIL_RSA_NEGATIVE_INTEGER < n_buffer[0]) ? 0x01 : 0x00);
+
+    // Check the number of bytes required to represent the length field
+    length_field_in_bytes = ((n_length > 0xFF)? 0x02 : 0x01);
+
+    // RSA public key formation according to DER encoded format
+    pub_key_buffer[index++] = OPTIGA_EXAMPLE_UTIL_DER_BITSTRING_TAG;
+    pub_key_buffer[index++] = OPTIGA_EXAMPLE_UTIL_RSA_DER_MIN_LEN_FIELD + length_field_in_bytes;
+    // 7 bytes = Unused Bits(1 byte) + Sequence Tag (1 byte) +
+    //           Length tag (1 byte) * 3 occurrence + Integer tag (1 byte) * 2 occurrence
+    OPTIGA_EXAMPLE_UTIL_SET_DER_LENGTH(pub_key_buffer, &index, (0x07 +
+                                                   n_length +
+                                                   modulus_signed_bit_len +
+                                                   e_length +
+                                                   (2 * length_field_in_bytes)))
+    pub_key_buffer[index++] = OPTIGA_EXAMPLE_UTIL_DER_NUM_UNUSED_BITS;
+
+    pub_key_buffer[index++] = OPTIGA_EXAMPLE_UTIL_RSA_DER_SEQUENCE_TAG;
+    pub_key_buffer[index++] = OPTIGA_EXAMPLE_UTIL_RSA_DER_MIN_LEN_FIELD + length_field_in_bytes;
+    // 4 bytes = Integer tag (1 byte) * 2 occurrence + Length tag (1 byte) * 2 occurrence
+    OPTIGA_EXAMPLE_UTIL_SET_DER_LENGTH(pub_key_buffer, &index, (0x04 +
+                                                   n_length +
+                                                   modulus_signed_bit_len +
+                                                   e_length +
+                                                   length_field_in_bytes))
+
+    pub_key_buffer[index++] = OPTIGA_EXAMPLE_UTIL_RSA_DER_INTEGER_TAG;
+    pub_key_buffer[index++] = OPTIGA_EXAMPLE_UTIL_RSA_DER_MIN_LEN_FIELD + length_field_in_bytes;
+    OPTIGA_EXAMPLE_UTIL_SET_DER_LENGTH(pub_key_buffer, &index, (n_length  + modulus_signed_bit_len))
+    index += modulus_signed_bit_len;
+    pal_os_memcpy(&pub_key_buffer[index], n_buffer, n_length);
+    index += n_length;
+
+    pub_key_buffer[index++] = OPTIGA_EXAMPLE_UTIL_RSA_DER_INTEGER_TAG;
+    pub_key_buffer[index++] = (uint8_t)e_length;
+    pal_os_memcpy(&pub_key_buffer[index], e_buffer, e_length);
+    index += e_length;
+
+    *pub_key_length = index;
+
+#undef OPTIGA_EXAMPLE_UTIL_RSA_DER_MIN_LEN_FIELD
+#undef OPTIGA_EXAMPLE_UTIL_RSA_DER_SEQUENCE_TAG
+#undef OPTIGA_EXAMPLE_UTIL_RSA_DER_INTEGER_TAG
+}
+optiga_lib_status_t example_check_tag_in_metadata(const uint8_t * buffer, const uint8_t tag)
+{
+    optiga_lib_status_t return_status = OPTIGA_LIB_SUCCESS;
+    uint8_t offset = 1;
+    uint8_t buffer_length = 0;
+    uint8_t tag_length = 0;
+    do
+    {
+        buffer_length = buffer[offset++];
+        while(offset < buffer_length)
+        {
+            if (tag == buffer[offset++])
+            {
+                return_status = !OPTIGA_LIB_SUCCESS;
+                break;
+            }
+            tag_length = buffer[offset];
+            offset += (tag_length + 1);
+        }
+    } while (FALSE);
+    return (return_status);
+}
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/include/optiga_example.h b/3rdparty/experimental/optiga/examples/optiga/include/optiga_example.h
new file mode 100644
index 000000000..e5871a7ad
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/include/optiga_example.h
@@ -0,0 +1,152 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_example.h
+*
+* \brief   This file defines APIs, types and data structures used in the OPTIGA example.
+*
+* \ingroup  grOptigaExamples
+*
+* @{
+*/
+
+
+#ifndef _OPTIGA_EXAMPLE_H_
+#define _OPTIGA_EXAMPLE_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "optiga/optiga_lib_config.h"
+#include "optiga/common/optiga_lib_logger.h"
+
+// Macro to enable logger for Application
+#define OPTIGA_LIB_ENABLE_EXAMPLE_LOGGING
+
+// Logger levels
+#define OPTIGA_EXAMPLE                     "[optiga example]  : "
+
+// Logger color for different layers and data
+#define OPTIGA_EXAMPLE_COLOR               OPTIGA_LIB_LOGGER_COLOR_DEFAULT
+
+// Check return status
+#define WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status)\
+                            if (OPTIGA_LIB_SUCCESS != return_status)\
+                            {\
+                                break;\
+                            }\
+                            while (OPTIGA_LIB_BUSY == optiga_lib_status)\
+                            { }\
+                            if (OPTIGA_LIB_SUCCESS != optiga_lib_status)\
+                            {\
+                                return_status = optiga_lib_status;\
+                                break;\
+                            }\
+                            
+#if defined (OPTIGA_LIB_ENABLE_EXAMPLE_LOGGING)
+/**
+ * \brief Logs the message provided from Application layer
+ *
+ * \details
+ * Logs the message provided from Application layer
+ *
+ * \pre
+ *
+ * \note
+ * - None
+ *
+ * \param[in]      msg      Valid pointer to string to be logged
+ *
+ */
+#define OPTIGA_EXAMPLE_LOG_MESSAGE(msg) \
+{\
+    optiga_lib_print_message(msg,OPTIGA_EXAMPLE,OPTIGA_EXAMPLE_COLOR);\
+}
+
+/**
+ * \brief Logs the byte array buffer provided from Application layer in hexadecimal format
+ *
+ * \details
+ * Logs the byte array buffer provided from Application layer in hexadecimal format
+ *
+ * \pre
+ *
+ * \note
+ * - None
+ *
+ * \param[in]      array      Valid pointer to array to be logged
+ * \param[in]      array_len  Length of array buffer
+ *
+ */
+#define OPTIGA_EXAMPLE_LOG_HEX_DATA(array,array_len) \
+{\
+    optiga_lib_print_array_hex_format(array,array_len,OPTIGA_UNPROTECTED_DATA_COLOR);\
+}
+
+/**
+ * \brief Logs the status info provided from Application layer
+ *
+ * \details
+ * Logs the status info provided from Application layer
+ *
+ * \pre
+ *
+ * \note
+ * - None
+ *
+ * \param[in]      return_value      Status information Application layer
+ *
+ */
+#define OPTIGA_EXAMPLE_LOG_STATUS(return_value) \
+{ \
+    if (OPTIGA_LIB_SUCCESS != return_value) \
+    { \
+        optiga_lib_print_status(OPTIGA_EXAMPLE,OPTIGA_ERROR_COLOR,return_value); \
+    } \
+    else\
+    { \
+        optiga_lib_print_status(OPTIGA_EXAMPLE,OPTIGA_EXAMPLE_COLOR,return_value); \
+    } \
+}
+#else
+
+#define OPTIGA_EXAMPLE_LOG_MESSAGE(msg)
+#define OPTIGA_EXAMPLE_LOG_HEX_DATA(array, array_len)
+#define OPTIGA_EXAMPLE_LOG_STATUS(return_value)
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_EXAMPLE_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/aes_key_object_confidentiality.h b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/aes_key_object_confidentiality.h
new file mode 100644
index 000000000..6ce9ea825
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/aes_key_object_confidentiality.h
@@ -0,0 +1,202 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file aes_key_object_confidentiality.h
+*
+* \brief   This file provides the data set for protected update of aes key object with confidentiality.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include <stdint.h>
+
+/**
+ * Manifest for AES key update with integrity protected and confidentiality
+ */
+const uint8_t manifest_aes_key[] = 
+{
+    // COSE Sign1 Trust
+    0x84,
+        // Protected signed header trust
+        0x47,
+            // Trust Sign Algorithm
+            0xA1, 
+            // RSA
+            0x01, 0x3A, 0x00, 0x01, 0x00, 0xA3, 
+        // Unprotected signed header trust
+        0xA1, 
+            // Root of trust
+            0x04, 0x42, 
+            // Trust Anchor OID
+            0xE0, 0xE3, 
+        // Payload info Byte string of single byte length
+        0x58, 
+            // Byte string length of manifest            
+            0x9C, 
+            // Trust manifest, array of 6 entries
+            0x86, 
+            // Version(Major Type 0)
+            0x01,
+            // NULL
+            0xF6,
+            // NULL
+            0xF6,
+            // Resources, array of 4 entries
+            0x84, 
+                // Trust Payload Type
+                0x22,
+                // Payload Length 
+                0x13,
+                // Trust Payload version
+                0x03, 
+                // Trust Add info data 
+                0x82, 
+                    // key algorithm
+                    0x18, 0x81,
+                    // key usage
+                    0x02, 
+                // Trust Processors, array of 2 entries 
+                0x82, 
+                    // Processing step integrity, array of 2 entries
+                    0x82, 
+                        // Process( Major Type 1)
+                        0x20, 
+                        // Parameters, byte string with single byte length
+                        0x58, 
+                            // Byte string length 
+                            0x25, 
+                            // IFX Digest info, array of 2 entries
+                            0x82, 
+                                // Digest Algorithm
+                                0x18,
+                                    // SHA-256
+                                    0x29, 
+                                // Digest
+                                0x58, 
+                                    // Byte string length
+                                    0x20, 
+                                        // Digest data
+                                        0xC7, 0xD6, 0xD4, 0xE4, 0xBF, 0xD0, 0xA7, 0x98, 
+                                        0x2D, 0xC5, 0x74, 0xB2, 0x96, 0xE9, 0x04, 0xCD,
+                                        0xDE, 0xB9, 0x78, 0xEF, 0x6C, 0xFD, 0x70, 0xCA,
+                                        0x10, 0xF9, 0x39, 0xA8, 0x98, 0x0E, 0x7E, 0xB6,     
+                    // Processing step decrypt, array of 2 entries
+                    0x82,
+                        // Process( Major Type 0)
+                        0x01,
+                        // COSE_Encrypt_Trust array of 3 entries
+                        0x83,
+                            // protected-encrypt-header-Trust
+                            0x43,
+                                // Map 
+                                0xA1,
+                                    // Key 
+                                    0x01,
+                                    // AES-CCM-16-64-128, 128-bit key, 64-bit Authentication(MAC) tag, 13-byte nonce
+                                    0x0A,
+                            // recipients array of 1
+                            0x81,
+                                // COSE_Recipient_Trust array of 2
+                                0x82,
+                                    // protected-recipient-header-Trust
+                                    0x58,
+                                        // byte str
+                                        0x54,
+                                            // Map of 3
+                                            0xA3,
+                                                // Key
+                                                0x04,
+                                                // Value
+                                                0x42,
+                                                    // Shared secret OID
+                                                    0xF1, 0xD1,
+                                                // Key
+                                                0x01,
+                                                // Value (KeyDerivationAlgorithms)
+                                                0x3A, 0x00, 0x01, 0x00, 0xB7,
+                                                // Key
+                                                0x05,
+                                                // Value array of 2
+                                                0x82,
+                                                    0x44,
+                                                        // label(4)
+                                                        0x74, 0x65, 0x73, 0x74,
+                                                    0x58,
+                                                        0x40,
+                                                        // seed(64)
+                                                        0x5E, 0xC8, 0x4C, 0x3C, 0x8E, 0xC5, 0x9D, 0xC3, 
+                                                        0x66, 0x0A, 0x52, 0x5E, 0x67, 0x95, 0xD9, 0xC9,
+                                                        0x1C, 0x31, 0x6A, 0x47, 0x21, 0x2F, 0xB9, 0xDB, 
+                                                        0xF7, 0x3E, 0x5F, 0x84, 0xA8, 0xC4, 0x81, 0xE7, 
+                                                        0x7B, 0xDA, 0xB9, 0x94, 0xF3, 0xE7, 0x04, 0x50, 
+                                                        0x8A, 0x51, 0x94, 0x03, 0xA9, 0x8D, 0x5E, 0x2A,
+                                                        0x09, 0x79, 0x10, 0x88, 0xB0, 0x1B, 0xC8, 0x8C, 
+                                                        0x98, 0x2D, 0x53, 0x26, 0xAC, 0x34, 0xDC, 0xD7, 
+                                    // ciphertext-recipient-header-Trust
+                                    0xF6,
+                            // AdditionalInfo
+                            0xF6,
+                // Trust Target
+                0x82, 
+                    // Component identifier(0)
+                    0x40,
+                    // Storage identifier
+                    0x42, 
+                    // Optiga target OID
+                    0xE2, 0x00, 
+        // Signature info, byte string of single byte length
+        0x58, 
+            // Byte string length for RSA 1024
+            0x80, 
+            // Signature data
+            0xBB, 0xF9, 0x64, 0x7F, 0x56, 0x50, 0xA1, 0xAA, 0x46, 0x8D, 0xE3, 0x4D, 0xC8, 0x35, 0xB1, 0xAD, 
+            0xD3, 0x74, 0x14, 0x01, 0xB0, 0x2A, 0x05, 0xEC, 0xA8, 0x16, 0x04, 0xFD, 0x79, 0x99, 0xCF, 0xB5, 
+            0x37, 0xF5, 0x4C, 0x2D, 0xDE, 0x20, 0x54, 0xF3, 0x93, 0x53, 0xD3, 0x29, 0x00, 0xBC, 0x0E, 0xF5, 
+            0x14, 0x2A, 0xEB, 0xE8, 0x58, 0xA0, 0xCB, 0x72, 0xE4, 0x97, 0xA3, 0x21, 0x27, 0x79, 0x81, 0x57,
+            0x1F, 0x99, 0xC9, 0xDB, 0xD1, 0xA4, 0x48, 0x8A, 0xC1, 0x71, 0xF0, 0x80, 0x4E, 0xC1, 0x00, 0x54,
+            0xC6, 0x74, 0x0D, 0xF2, 0x4F, 0x76, 0x44, 0xC1, 0x46, 0x26, 0xCB, 0xAC, 0x01, 0x67, 0x32, 0x2A,
+            0xF4, 0xCE, 0xD7, 0xB4, 0x48, 0x9C, 0x5D, 0xA4, 0xF5, 0xAD, 0x91, 0x40, 0x30, 0x9F, 0x7C, 0x8B,
+            0x08, 0x13, 0x99, 0xCD, 0xA6, 0x9D, 0x84, 0xBF, 0x68, 0x9E, 0x7A, 0xE6, 0xE6, 0xB7, 0xAA, 0x4D,
+
+};
+
+/**
+ * Fragment array for final with 19 bytes of payload for AES key update
+ */
+const uint8_t aes_key_final_fragment_array[] = 
+{
+    // Payload of 27 bytes (16 bytes AES key,3 bytes for TL and 8 byte MAC)
+    0x84, 0x38, 0xEC, 0xCC, 0x41, 0x03, 0x7D, 0xD2, 0x8D, 0x5C, 0xB6, 0xA1, 0x1F, 0xFF, 0x6F, 0x2C,
+    0x1F, 0x86, 0xF3, 0x30, 0x57, 0x8A, 0xE0, 0xA0, 0x8E, 0x75, 0x3F,
+};
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/data_object.h b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/data_object.h
new file mode 100644
index 000000000..816845401
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/data_object.h
@@ -0,0 +1,209 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file data_object.c
+*
+* \brief   This file provides the data set for protected update of data object .
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include <stdint.h>
+
+/**
+ * Manifest when the payload is integrity protected
+ */
+const uint8_t manifest_int[] = 
+{
+    // COSE Sign1 Trust
+    0x84,
+        // Protected signed header trust
+        0x47,
+            // Trust Sign Algorithm
+            0xA1, 
+            // RSA
+            0x01, 0x3A, 0x00, 0x01, 0x00, 0xA3,
+        // Unprotected signed header trust
+        0xA1, 
+            // Root of trust
+            0x04, 0x42, 
+            // Trust Anchor OID
+            0xE0, 0xE3, 
+        // Payload info Byte string of single byte length
+        0x58, 
+            // Byte string length of manifest            
+            0x3D, 
+            // Trust manifest, array of 6 entries
+            0x86, 
+            // Version(Major Type 0)
+            0x01,
+            // NULL
+            0xF6,
+            // NULL
+            0xF6,
+            // Resources, array of 4 entries
+            0x84, 
+                // Trust Payload Type
+                0x20,
+                // 2 byte length
+                0x19,
+                // Payload Length
+                0x03, 0x2E, 
+                // Trust Payload version
+                0x03, 
+                // Trust Add info data 
+                0x82, 
+                    // Offset(Major Type 0)
+                    0x00, 
+                    // Trust add info write type
+                    0x01, 
+                // Trust Processors, array of 2 entries 
+                0x82, 
+                    // Processing step integrity, array of 2 entries
+                    0x82, 
+                        // Process(Major Type 1)
+                        0x20, 
+                        // Parameters, byte string with single byte length
+                        0x58,                         // Byte string length
+                        0x25, 
+                        // IFX Digest info, array of 2 entries
+                        0x82, 
+                        // Digest Algorithm
+                        0x18,
+                        // SHA-256
+                        0x29, 
+                        // Digest
+                        0x58, 
+                        // Byte string length
+                        0x20, 
+                        // Digest data
+                        0xD8, 0x6C, 0x98, 0x4A, 0x54, 0x28, 0x31, 0x58, 
+                        0x92, 0x4F, 0x4C, 0xDD, 0x1A, 0xD5, 0x19, 0xEC, 
+                        0x57, 0x20, 0x20, 0x29, 0x59, 0xBB, 0xD6, 0x5B,
+                        0x2D, 0x0B, 0x17, 0x8E, 0xDB, 0x62, 0x3F, 0xAA,
+                    // NULL
+                    0xF6, 
+                // Trust Target
+                0x82, 
+                    // Component identifier
+                    0x40, 
+                    // Storage identifier
+                    0x42, 
+                    // Optiga target OID
+                    0xE0, 0xE1, 
+        // Signature info, byte string of single byte length
+        0x58, 
+            // Byte string length for RSA 1024
+            0x80, 
+            // Signature data
+            0x9A, 0xCF, 0x68, 0xE6, 0x2E, 0x3B, 0x76, 0xE6, 0xD1, 0xF0, 0x30, 0x28, 0x0E, 0x31, 0x29, 0xEA, 
+            0x27, 0x9E, 0x2E, 0x7B, 0x68, 0x8C, 0x91, 0x8F, 0xAD, 0x54, 0xDF, 0x58, 0x32, 0x6F, 0x2C, 0x80,
+            0xED, 0xC2, 0x26, 0x4D, 0x81, 0xE5, 0xAF, 0xFB, 0x3C, 0xD3, 0x6E, 0x63, 0xFC, 0x9A, 0x7A, 0x85,
+            0x74, 0x78, 0x6D, 0x27, 0x7E, 0xD7, 0x51, 0x76, 0x80, 0x21, 0x39, 0xD3, 0xA0, 0x0D, 0xE7, 0x44, 
+            0x21, 0x5A, 0x07, 0x98, 0xD3, 0x68, 0x84, 0xC9, 0xEF, 0x0F, 0x3C, 0xB2, 0x94, 0xE7, 0x27, 0xC7,
+            0xE0, 0x12, 0x1C, 0x7A, 0x6C, 0x70, 0x95, 0x9A, 0x5E, 0x9A, 0x9F, 0xE4, 0xBD, 0xC9, 0x70, 0x2A,
+            0xE9, 0x35, 0xB6, 0x57, 0x9D, 0x64, 0xFB, 0x99, 0xC0, 0xE3, 0xA8, 0xD5, 0x1A, 0x08, 0x7D, 0x05,
+            0x5C, 0x1B, 0x30, 0x60, 0xE2, 0x82, 0x50, 0x5D, 0xD3, 0xB2, 0xEA, 0xC3, 0x2C, 0xB6, 0xFC, 0xA7,
+
+};
+
+/**
+ * Fragment array for continue with 608 bytes of payload and 32 bytes of digest of next fragment
+ */
+const uint8_t int_continue_fragment_array[] = 
+{
+    0x6C, 0x69, 0x6E, 0x65, 0x31, 0x20, 0x3A, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
+    0x61, 0x20, 0x73, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64,
+    0x20, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x20,
+    0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70,
+    0x64, 0x61, 0x74, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x67, 0x65,
+    0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0x0D, 0x0A, 0x6C, 0x69, 0x6E, 0x65, 0x32, 0x20,
+    0x3A, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6D, 0x70,
+    0x6C, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x64, 0x65,
+    0x6D, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72,
+    0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x64,
+    0x61, 0x74, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F,
+    0x72, 0x2E, 0x0D, 0x0A, 0x6C, 0x69, 0x6E, 0x65, 0x33, 0x20, 0x3A, 0x20, 0x54, 0x68, 0x69, 0x73,
+    0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x79,
+    0x6C, 0x6F, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x6E, 0x73, 0x74, 0x72,
+    0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65,
+    0x64, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x65,
+    0x74, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0x0D, 0x0A, 0x6C, 0x69,
+    0x6E, 0x65, 0x34, 0x20, 0x3A, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20,
+    0x73, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x74,
+    0x6F, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68,
+    0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x64, 0x61,
+    0x74, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x67, 0x65, 0x6E, 0x65,
+    0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0x0D, 0x0A, 0x6C, 0x69, 0x6E, 0x65, 0x35, 0x20, 0x3A, 0x20,
+    0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6D, 0x70, 0x6C, 0x65,
+    0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x6D, 0x6F,
+    0x6E, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74,
+    0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x64, 0x61, 0x74,
+    0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E,
+    0x0D, 0x0A, 0x6C, 0x69, 0x6E, 0x65, 0x36, 0x20, 0x3A, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69,
+    0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F,
+    0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61, 0x74,
+    0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20,
+    0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20,
+    0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0x0D, 0x0A, 0x6C, 0x69, 0x6E, 0x65,
+    0x37, 0x20, 0x3A, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61,
+    0x6D, 0x70, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20,
+    0x64, 0x65, 0x6D, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20,
+    0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
+    0xDA, 0xB6, 0x9C, 0x81, 0x0B, 0x06, 0x2C, 0x0A, 0xB9, 0x8B, 0x62, 0xFB, 0xFB, 0x2F, 0xBD, 0x66,
+    0x77, 0xC7, 0x59, 0xB6, 0x9B, 0xA8, 0xAC, 0x7E, 0x03, 0xA2, 0x64, 0x06, 0x33, 0x46, 0x6A, 0xDB,
+};
+
+/**
+ * Fragment array for final 
+ */
+const uint8_t int_final_fragment_array[] = 
+{
+
+    0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61,
+    0x74, 0x6F, 0x72, 0x2E, 0x0D, 0x0A, 0x6C, 0x69, 0x6E, 0x65, 0x38, 0x20, 0x3A, 0x20, 0x54, 0x68,
+    0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x70,
+    0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x6E, 0x73,
+    0x74, 0x72, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63,
+    0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20,
+    0x73, 0x65, 0x74, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0x0D, 0x0A,
+    0x6C, 0x69, 0x6E, 0x65, 0x39, 0x20, 0x3A, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
+    0x61, 0x20, 0x73, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64,
+    0x20, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x20,
+    0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70,
+    0x64, 0x61, 0x74, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x67, 0x65,
+    0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A,    
+};
+
+/**
+* @}
+*/
+
+
diff --git a/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/data_object_confidentiality.h b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/data_object_confidentiality.h
new file mode 100644
index 000000000..fcf57c820
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/data_object_confidentiality.h
@@ -0,0 +1,262 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file data_object_confidentiality.h
+*
+* \brief   This file provides the data set for protected update of data object with confidentiality.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include <stdint.h>
+
+/**
+ * Manifest for when the  payload is integrity and confidentiality protected with AES-CCM-16-64-128 algorithm
+ */
+const uint8_t manifest_int_conf[] = 
+{
+    // COSE Sign1 Trust
+    0x84,
+        // Protected signed header trust
+        0x47,
+            // Trust Sign Algorithm
+            0xA1, 
+            // RSA
+            0x01, 0x3A, 0x00, 0x01, 0x00, 0xA3, 
+        // Unprotected signed header trust
+        0xA1, 
+            // Root of trust
+            0x04, 0x42, 
+            // Trust Anchor OID
+            0xE0, 0xE3, 
+        // Payload info Byte string of single byte length
+        0x58, 
+            // Byte string length of manifest            
+            0x9D, 
+            // Trust manifest, array of 6 entries
+            0x86, 
+            // Version(Major Type 0)
+            0x01,
+            // NULL
+            0xF6,
+            // NULL
+            0xF6,
+            // Resources, array of 4 entries
+            0x84, 
+                // Trust Payload Type
+                0x20,
+                // 2 byte length  
+                0x19,
+                // Payload Length
+                0x03, 0x2E, 
+                // Trust Payload version
+                0x03, 
+                // Trust Add info data 
+                0x82, 
+                    // Offset( Major Type 0)
+                    0x00, 
+                    // Trust add info write type
+                    0x01, 
+                // Trust Processors, array of 2 entries 
+                0x82, 
+                    // Processing step integrity, array of 2 entries
+                    0x82, 
+                        // Process( Major Type 1)
+                        0x20, 
+                        // Parameters, byte string with single byte length
+                        0x58, 
+                            // Byte string length 
+                            0x25, 
+                            // IFX Digest info, array of 2 entries
+                            0x82, 
+                                // Digest Algorithm
+                                0x18,
+                                    // SHA-256
+                                    0x29, 
+                                // Digest
+                                0x58, 
+                                    // Byte string length
+                                    0x20, 
+                                        // Digest data
+                                        0xAB, 0x0F, 0x67, 0xE1, 0x9D, 0x26, 0x54, 0x8D,
+                                        0x01, 0xC3, 0x9E, 0x4A, 0xBB, 0x54, 0x5E, 0xA3,
+                                        0x01, 0x3E, 0x37, 0x25, 0x7E, 0xFD, 0x75, 0x17, 
+                                        0x47, 0x73, 0xF4, 0xB0, 0xC0, 0x41, 0x05, 0x6F,
+                    // Processing step decrypt, array of 2 entries
+                        0x82, 
+                        // Process( Major Type 0)
+                        0x01,
+                        // COSE_Encrypt_Trust array of 3 entries
+                        0x83,
+                            // protected-encrypt-header-Trust
+                            0x43,
+                                // Map 
+                                0xA1,
+                                    // Key 
+                                    0x01,
+                                    // AES-CCM-16-64-128, 128-bit key, 64-bit Authentication(MAC) tag, 13-byte nonce
+                                    0x0A, 
+                            // recipients array of 1
+                            0x81,   
+                                // COSE_Recipient_Trust array of 2
+                                0x82, 
+                                    // protected-recipient-header-Trust
+                                    0x58, 
+                                        // byte string
+                                        0x54, 
+                                            // Map of 3
+                                            0xA3, 
+                                                // Key
+                                                0x04,
+                                                // Value
+                                                0x42,
+                                                    // Shared secret OID
+                                                    0xF1, 0xD1, 
+                                                // Key
+                                                0x01, 
+                                                // Value (KeyDerivationAlgorithms)
+                                                0x3A, 0x00, 0x01, 0x00, 0xB7, 
+                                                // Key
+                                                0x05, 
+                                                // Value array of 2
+                                                0x82, 
+                                                0x44, 
+                                                        // label(4)
+                                                        0x74, 0x65, 0x73, 0x74,
+                                                    0x58, 
+                                                        0x40, 
+                                                        // seed(64)
+                                                        0x0B, 0x1F, 0xD1, 0xA0, 0x2F, 0xF1, 0x97, 0xCC, 
+                                                        0xDA, 0x46, 0x9E, 0x32, 0xE2, 0xB8, 0x20, 0x93, 
+                                                        0xB6, 0x24, 0x74, 0x90, 0xAF, 0x3F, 0xF7, 0x64, 
+                                                        0x1B, 0xEC, 0x3E, 0x0E, 0xFC, 0x37, 0xDD, 0x1E,
+                                                        0xFD, 0x88, 0xD3, 0x41, 0x5B, 0x9F, 0xBA, 0xDA,
+                                                        0x9E, 0xAE, 0x18, 0xE6, 0x4A, 0x4C, 0x67, 0xEB, 
+                                                        0x29, 0x97, 0x9E, 0x34, 0xBD, 0xEF, 0xDD, 0x62, 
+                                                        0x91, 0xCE, 0x76, 0x12, 0xEE, 0xD1, 0x97, 0x75, 
+                                    // ciphertext-recipient-header-Trust
+                                    0xF6,
+                            // AdditionalInfo
+                            0xF6, 
+                // Trust Target
+                0x82,
+                    // Component identifier(0)
+                    0x40, 
+                    // Storage identifier
+                    0x42, 
+                    // Optiga target OID
+                    0xE0, 0xE1, 
+        // Signature info, byte string of single byte length
+        0x58,
+            // Byte string length for RSA 1024
+            0x80,
+            // Signature data
+            0x62, 0x28, 0xAC, 0x02, 0xEC, 0x18, 0xE4, 0x59, 0xA0, 0x96, 0x52, 0x43, 0xF6, 0x92, 0xCC, 0x70, 
+            0xDB, 0xF0, 0x14, 0x01, 0x8D, 0x5A, 0x57, 0x96, 0xD2, 0x02, 0x04, 0xD9, 0x4B, 0xB9, 0x14, 0x78, 
+            0xA6, 0xE5, 0x24, 0x85, 0xC5, 0xDC, 0xDB, 0x67, 0x9B, 0xBA, 0x1D, 0xCE, 0x95, 0x6D, 0x16, 0xCB, 
+            0x89, 0x98, 0x25, 0xBD, 0x8F, 0xBD, 0x3F, 0xD9, 0x9D, 0x2B, 0x95, 0x65, 0x98, 0x1D, 0xD6, 0x87, 
+            0x30, 0x81, 0x88, 0x22, 0x2A, 0xB0, 0x90, 0x5F, 0x7F, 0x71, 0xAC, 0x4E, 0xCC, 0xCA, 0x9E, 0x9B,
+            0x76, 0xEF, 0xD6, 0x00, 0x3B, 0xF4, 0x9A, 0x7C, 0x00, 0xF9, 0x67, 0x31, 0x51, 0x7F, 0x34, 0xC3, 
+            0xA0, 0xC0, 0x75, 0x11, 0x06, 0x86, 0x42, 0x6A, 0x9C, 0x40, 0xA3, 0x9F, 0x70, 0x0A, 0x77, 0x5F, 
+            0x89, 0x9A, 0xBE, 0x60, 0x1D, 0xFF, 0x8B, 0x26, 0x21, 0x02, 0xC3, 0x5C, 0xD4, 0x53, 0x51, 0xAC,
+
+};
+
+/**
+ * Fragment array for continue with 600 bytes of payload, 8 bytes of MAC and 32 bytes of digest of next fragment
+ */
+const uint8_t int_conf_continue_fragment_array[] = 
+{
+        0x3E, 0x48, 0x32, 0xEA, 0x7F, 0xD9, 0x00, 0x26, 0xF5, 0x2B, 0x28, 0x90, 0xFF, 0x69, 0x20, 0x2A,
+        0xFC, 0xA0, 0xEB, 0xDB, 0x61, 0x2B, 0x2D, 0xE9, 0xE7, 0xF9, 0xA7, 0xE0, 0x70, 0x96, 0xD2, 0xB4,
+        0xD3, 0xA1, 0x6C, 0x19, 0x72, 0x69, 0x5C, 0x31, 0x2C, 0xB6, 0x44, 0x10, 0x36, 0xFC, 0x90, 0xEF,
+        0xF3, 0xFA, 0x8C, 0xE9, 0x82, 0xB8, 0x5D, 0xB2, 0xD6, 0xDC, 0xBA, 0x71, 0xA3, 0x1F, 0xD2, 0xC9,
+        0xF7, 0x3F, 0xA4, 0x6D, 0xC7, 0xD3, 0xD4, 0xF6, 0x08, 0x62, 0xB2, 0x90, 0xF9, 0xC5, 0x0B, 0xA2,
+        0x07, 0x55, 0x52, 0x01, 0x6B, 0x10, 0xCA, 0xA3, 0x8B, 0x1A, 0xEC, 0x09, 0x78, 0x66, 0x27, 0xDB,
+        0xD5, 0x17, 0x18, 0x0C, 0x89, 0xA8, 0x4E, 0x7D, 0xEF, 0x4F, 0xF1, 0x01, 0xC6, 0x9E, 0x1A, 0x7D,
+        0xFD, 0xB8, 0x18, 0x13, 0xDD, 0x56, 0x61, 0x85, 0x57, 0x7F, 0x0B, 0x2E, 0xC0, 0x63, 0x4B, 0x5D,
+        0x0A, 0xE7, 0xC3, 0xC2, 0x48, 0x83, 0x8C, 0xF2, 0x82, 0xE4, 0x16, 0xB8, 0xD0, 0x4B, 0xE8, 0xCE,
+        0x6E, 0x14, 0xC3, 0x44, 0x9F, 0x54, 0xA6, 0xF8, 0x0C, 0x91, 0xBE, 0x9D, 0x54, 0xDE, 0xA2, 0xC8,
+        0x21, 0xAD, 0xE7, 0x38, 0x75, 0x59, 0xAD, 0x6E, 0xE4, 0x66, 0xE2, 0x72, 0x15, 0x8E, 0x44, 0xCF,
+        0xDB, 0x6A, 0xCA, 0xF8, 0x57, 0xAF, 0x43, 0xE0, 0x48, 0x7A, 0xA8, 0x1B, 0x7A, 0x37, 0xE8, 0x05,
+        0x54, 0xEA, 0x52, 0x33, 0x9C, 0xED, 0xEE, 0x49, 0x63, 0x99, 0xA0, 0x3F, 0x99, 0x56, 0x1F, 0xEB,
+        0x07, 0x8F, 0xDD, 0xCF, 0xF9, 0x40, 0x5E, 0x49, 0xDF, 0x77, 0x29, 0x34, 0x0E, 0x91, 0x67, 0xF6,
+        0x9A, 0xE4, 0xCA, 0xD6, 0x9E, 0x8D, 0xF5, 0xBE, 0xE9, 0xAB, 0x19, 0x0D, 0x8E, 0xA4, 0xFD, 0x15,
+        0xFC, 0x37, 0x54, 0x71, 0xE0, 0xA6, 0x8D, 0xED, 0x39, 0x5F, 0x23, 0x80, 0x2D, 0x84, 0xA2, 0x34,
+        0x5E, 0xC9, 0x7A, 0xF2, 0xD9, 0x6F, 0xCF, 0x6E, 0x9C, 0xD2, 0xCA, 0x5C, 0xE7, 0xFE, 0xF4, 0x46,
+        0x35, 0x3B, 0x8C, 0x90, 0xC8, 0x7A, 0x83, 0x1D, 0x5A, 0xEE, 0x5E, 0x58, 0xDA, 0x76, 0x8F, 0x5B,
+        0x72, 0xF4, 0x31, 0xA6, 0x1D, 0x62, 0xEE, 0xD8, 0x61, 0xE8, 0xAB, 0x69, 0xEE, 0x7A, 0x77, 0x77,
+        0x69, 0x13, 0x84, 0xEF, 0x0F, 0x70, 0x7C, 0x8B, 0x32, 0xA3, 0xFE, 0x00, 0x35, 0xE5, 0x4C, 0x79,
+        0x47, 0xCC, 0x50, 0xD5, 0xFA, 0x74, 0xA2, 0xF6, 0x81, 0xF3, 0x8F, 0xC7, 0x4F, 0xFE, 0xB6, 0xAF,
+        0x12, 0x65, 0x41, 0xE9, 0x22, 0xDE, 0x55, 0xF8, 0xDE, 0x4C, 0x6C, 0x1F, 0x0C, 0x9C, 0x71, 0x36,
+        0x6E, 0x6F, 0xBB, 0x93, 0xA6, 0xCE, 0x3D, 0x85, 0x9D, 0xCE, 0xDF, 0x03, 0xB8, 0xA8, 0x91, 0x6C,
+        0x31, 0x47, 0x34, 0x87, 0x0C, 0xF9, 0xB4, 0xCB, 0x4C, 0x06, 0x9F, 0xA1, 0xC4, 0xA1, 0xD6, 0x63,
+        0x83, 0x41, 0x1C, 0x8E, 0x9A, 0x7E, 0x06, 0x17, 0xF4, 0xA4, 0x0A, 0xEF, 0xB2, 0x0D, 0x1D, 0xE7,
+        0x00, 0x44, 0x59, 0x11, 0xBA, 0x5A, 0xC0, 0x49, 0xBB, 0xB9, 0xA7, 0xAD, 0xDD, 0xFF, 0x5A, 0xF2,
+        0x65, 0x94, 0xB9, 0x58, 0x43, 0xD2, 0xB5, 0xB4, 0xA6, 0x8B, 0x4F, 0x9F, 0xC1, 0x6F, 0x99, 0x46,
+        0xA1, 0x59, 0x6A, 0xF8, 0x13, 0xF5, 0xF3, 0xAA, 0xCA, 0xC4, 0x9D, 0xE4, 0xC2, 0xF6, 0x5A, 0xF9,
+        0x83, 0x4C, 0xDB, 0xA4, 0x58, 0x2D, 0x33, 0x6F, 0x78, 0x9A, 0xBD, 0x27, 0x31, 0x82, 0xB3, 0x23,
+        0x49, 0xB4, 0xCD, 0x58, 0x9B, 0xFF, 0xEC, 0xCE, 0x8C, 0x72, 0x74, 0xE2, 0xF4, 0xD1, 0xAC, 0x4F,
+        0xC7, 0x0D, 0x2D, 0x77, 0xE6, 0xEC, 0x4B, 0xD0, 0xBA, 0x4A, 0xFD, 0x96, 0x74, 0x8F, 0x93, 0x9B,
+        0x0E, 0x77, 0xC1, 0x23, 0xA6, 0x36, 0xA2, 0x48, 0x71, 0xAE, 0x0E, 0xA3, 0x51, 0x4D, 0x29, 0x16,
+        0xAF, 0x91, 0xA9, 0x08, 0x47, 0xF6, 0x2E, 0x85, 0x3B, 0xE7, 0x1D, 0x75, 0xC0, 0xAE, 0x92, 0xB1,
+        0x82, 0xAC, 0xF8, 0xF6, 0x79, 0x42, 0xBF, 0x6B, 0x80, 0xF2, 0x42, 0xF9, 0x5A, 0xDF, 0x53, 0x4D,
+        0x27, 0x54, 0x0A, 0xBF, 0x7D, 0x82, 0x59, 0x96, 0x70, 0xD4, 0x3E, 0x14, 0x35, 0xFD, 0x30, 0x79,
+        0x4B, 0xA8, 0xBB, 0x59, 0x15, 0x37, 0x8C, 0xFA, 0x3A, 0x25, 0xE2, 0xC5, 0x3C, 0x34, 0x5D, 0x4C,
+        0xE2, 0x95, 0xC9, 0xF0, 0xF7, 0x67, 0xCB, 0x9B, 0x44, 0x64, 0xEA, 0xB9, 0xE4, 0xF0, 0xDC, 0x21,
+        0xE5, 0xA8, 0xEA, 0xDE, 0xF6, 0xF4, 0xB5, 0x16, 0x2E, 0xBF, 0x39, 0xC5, 0x8F, 0x86, 0xD4, 0xD1,
+        0x94, 0x39, 0x75, 0xBF, 0xB9, 0x04, 0x90, 0xE1, 0x88, 0xDD, 0xF7, 0x85, 0xEC, 0x76, 0x49, 0xF9,
+        0xD9, 0x27, 0x34, 0x03, 0xFC, 0x89, 0x4A, 0xF2, 0x04, 0x65, 0x96, 0x41, 0x29, 0x8D, 0x71, 0x84,
+};
+
+/**
+ * Fragment array for final with 58 bytes of payload and 8 bytes of MAC
+ */
+const uint8_t int_conf_final_fragment_array[] = 
+{
+    0x9C, 0x02, 0xF6, 0x9E, 0x40, 0x51, 0xE9, 0x52, 0xC4, 0x10, 0x3E, 0x12, 0x58, 0x33, 0x9D, 0x7A,
+    0x4B, 0x46, 0x0E, 0x24, 0x9E, 0x3E, 0x40, 0x87, 0x12, 0xED, 0x54, 0x5C, 0xF7, 0x6A, 0xA7, 0x63,
+    0xBB, 0xAE, 0xF2, 0xDC, 0xE0, 0xB2, 0x2D, 0x26, 0xB6, 0x18, 0x18, 0x08, 0xC3, 0x0D, 0x27, 0x7C,
+    0x01, 0x4B, 0x8F, 0xA3, 0xBF, 0x7E, 0x18, 0xA3, 0x5F, 0x3A, 0xF1, 0x85, 0x24, 0x59, 0x7C, 0x5C,
+    0x88, 0xF9, 0x48, 0x6D, 0xE2, 0x37, 0xFE, 0xC7, 0x75, 0x30, 0x4A, 0xEF, 0x2C, 0x7A, 0x30, 0x5E,
+    0xC3, 0x76, 0xFD, 0x2C, 0xA7, 0x0F, 0x8D, 0xD5, 0xA4, 0x41, 0x9A, 0x30, 0x1F, 0x6F, 0x90, 0x1F,
+    0xC0, 0x75, 0xCF, 0xD9, 0xB8, 0xAC, 0x6A, 0xFA, 0x0A, 0x14, 0x47, 0xA5, 0xEC, 0x32, 0xCC, 0x1A,
+    0xB2, 0xA5, 0x06, 0x5D, 0x8E, 0xDB, 0xCD, 0xE5, 0x54, 0x0F, 0x0D, 0xC6, 0xC6, 0xB8, 0x3A, 0x2E,
+    0xF5, 0x20, 0x73, 0x07, 0x03, 0x80, 0xC6, 0x85, 0xF5, 0x0D, 0x47, 0x25, 0x54, 0xF0, 0xB3, 0x16,
+    0x44, 0xF8, 0xFA, 0xAF, 0x5B, 0x6F, 0xDB, 0x0D, 0x1C, 0x3D, 0xCF, 0x74, 0x89, 0xF2, 0x47, 0xA1,
+    0xEC, 0x35, 0x38, 0x08, 0x10, 0xC2, 0xA7, 0xF3, 0x04, 0x9D, 0x0B, 0x3B, 0x7F, 0x0A, 0xC2, 0xED,
+    0xF1, 0x6E, 0x7F, 0x69, 0x56, 0x23, 0x51, 0x0A, 0x1B, 0xFB, 0x3C, 0x5B, 0xA8, 0x12, 0xA9, 0xD2,
+    0xE1, 0x10, 0xE8, 0xEF, 0xC5, 0xB0, 0xF9, 0x73, 0xD4, 0x99, 0x9A, 0xF7, 0x51, 0x2E, 0xC0, 0x0F,
+    0x93, 0x8C, 0xB5, 0xE2, 0xA9, 0x4E, 0x1C, 0x53, 0x01, 0x21, 0x2F, 0x75, 0x51, 0xDA,
+};
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/example_optiga_util_protected_update.h b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/example_optiga_util_protected_update.h
new file mode 100644
index 000000000..d80e8f22f
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/example_optiga_util_protected_update.h
@@ -0,0 +1,177 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file example_optiga_util_protected_update.h
+*
+* \brief   This file provides the data set for protected update of ecc key object with confidentiality.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include <stdint.h>
+
+#include "data_object.h"
+#include "data_object_confidentiality.h"
+#include "aes_key_object_confidentiality.h"
+#include "rsa_key_object_confidentiality.h"
+#include "metadata_object_confidentiality.h"
+
+/** @brief Macro to enable secure data update in OID example */
+#define INTEGRITY_PROTECTED                  (0x00)
+/** @brief Macro to enable secure data update in OID with confidentiality example */
+#define CONFIDENTIALITY_PROTECTED            (0x01)
+/** @brief Macro to enable secure AES key update in key object example */
+#define AES_KEY_UPDATE                       (0x02)
+/** @brief Macro to enable secure RSA key update in key object example */
+#define RSA_KEY_UPDATE                       (0x04)
+/** @brief Macro to enable secure metadata update of  OID example */
+#define METADATA_UPDATE                      (0x05)
+
+/**
+ * \brief Specifies the structure for protected update manifest and fragment configuration
+ */
+typedef struct optiga_protected_update_manifest_fragment_configuration
+{
+    /// Manifest version.
+    uint8_t manifest_version;
+    /// Pointer to a buffer where manifest data is stored.
+    const uint8_t * manifest_data;
+    /// Manifest length
+    uint16_t manifest_length;
+    /// Pointer to a buffer where continue fragment data is stored.
+    const uint8_t * continue_fragment_data;
+    /// Continue fragment length
+    uint16_t continue_fragment_length;
+    /// Pointer to a buffer where final fragment data is stored.
+    const uint8_t * final_fragment_data;
+    /// Final fragment length
+    uint16_t final_fragment_length;
+}optiga_protected_update_manifest_fragment_configuration_t;
+
+#ifdef INTEGRITY_PROTECTED
+/**
+ * Integrity protected manifest and fragment configuration
+ */
+optiga_protected_update_manifest_fragment_configuration_t data_integrity_configuration =
+                                                                {
+                                                                     0x01,
+                                                                     manifest_int,
+                                                                     sizeof(manifest_int),
+                                                                     int_continue_fragment_array,
+                                                                     sizeof(int_continue_fragment_array),
+                                                                     int_final_fragment_array,
+                                                                     sizeof(int_final_fragment_array)
+                                                                };
+#endif
+
+#ifdef CONFIDENTIALITY_PROTECTED
+/**
+ * Integrity and confidentiality protected manifest and fragment configuration
+ */
+optiga_protected_update_manifest_fragment_configuration_t data_confidentiality_configuration =
+                                                                {
+                                                                     0x01,
+                                                                     manifest_int_conf,
+                                                                     sizeof(manifest_int_conf),
+                                                                     int_conf_continue_fragment_array,
+                                                                     sizeof(int_conf_continue_fragment_array),
+                                                                     int_conf_final_fragment_array,
+                                                                     sizeof(int_conf_final_fragment_array)
+                                                                };
+#endif
+
+#ifdef AES_KEY_UPDATE
+/**
+ * AES key update manifest and fragment configuration
+ */
+optiga_protected_update_manifest_fragment_configuration_t data_aes_key_configuration =
+                                                                {
+                                                                     0x01,
+                                                                     manifest_aes_key,
+                                                                     sizeof(manifest_aes_key),
+                                                                     NULL,
+                                                                     0,
+                                                                     aes_key_final_fragment_array,
+                                                                     sizeof(aes_key_final_fragment_array)
+                                                                };
+#endif
+
+#ifdef RSA_KEY_UPDATE
+/**
+ * RSA key update manifest and fragment configuration
+ */                               
+optiga_protected_update_manifest_fragment_configuration_t data_rsa_key_configuration = 
+                                                                {    
+                                                                     0x01,
+                                                                     manifest_rsa_key,
+                                                                     sizeof(manifest_rsa_key),
+                                                                     NULL,
+                                                                     0,
+                                                                     rsa_key_final_fragment_array,
+                                                                     sizeof(rsa_key_final_fragment_array)
+                                                                };
+#endif
+
+#ifdef METADATA_UPDATE                                                                
+/**
+ * Metadata update manifest and fragment configuration
+ */                               
+optiga_protected_update_manifest_fragment_configuration_t metadata_update_configuration = 
+                                                                {    
+                                                                     0x01,
+                                                                     manifest_metadata,
+                                                                     sizeof(manifest_metadata),
+                                                                     NULL,
+                                                                     0,
+                                                                     metadata_final_fragment_array,
+                                                                     sizeof(metadata_final_fragment_array)
+                                                                };
+#endif
+
+/**
+ * \brief Specifies the structure for protected update data configuration
+ */
+typedef struct optiga_protected_update_data_configuration
+{
+    /// Target OID
+    uint16_t target_oid;
+    /// Target OID metadata
+    const uint8_t * target_oid_metadata;
+    /// Target OID metadata length
+    uint16_t target_oid_metadata_length;
+    /// Pointer to a buffer where continue fragment data is stored.
+    const optiga_protected_update_manifest_fragment_configuration_t * data_config;
+}optiga_protected_update_data_configuration_t;
+
+
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/metadata_object_confidentiality.h b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/metadata_object_confidentiality.h
new file mode 100644
index 000000000..fd90cf608
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/metadata_object_confidentiality.h
@@ -0,0 +1,199 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file metadata_object_confidentiality.h
+*
+* \brief   This file provides the data set for protected update of metadata object with confidentiality.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+/**
+ * Manifest for metadata update with integrity protected and confidentiality
+ */
+const uint8_t manifest_metadata[] = 
+{
+    // COSE Sign1 Trust
+    0x84,
+        // Protected signed header trust
+        0x47,
+            // Trust Sign Algorithm
+            0xA1, 
+            // RSA
+            0x01, 0x3A, 0x00, 0x01, 0x00, 0xA3, 
+        // Unprotected signed header trust
+        0xA1, 
+            // Root of trust
+            0x04, 0x42, 
+            // Trust Anchor OID
+            0xE0, 0xE3, 
+        // Payload info Byte string of single byte length
+        0x58, 
+            // Byte string length of manifest            
+            0x9B, 
+            // Trust manifest, array of 6 entries
+            0x86, 
+            // Version(Major Type 0)
+            0x01,
+            // NULL
+            0xF6,
+            // NULL
+            0xF6,
+            // Resources, array of 4 entries
+            0x84, 
+                // Trust Payload Type
+                0x21,
+                // Payload Length 
+                0x0D,
+                // Trust Payload version
+                0x03, 
+                // Trust Add info data 
+                0x82, 
+                    // content reset
+                    0x00,
+                    // additional flag
+                    0x00,
+                // Trust Processors, array of 2 entries 
+                0x82, 
+                    // Processing step integrity, array of 2 entries
+                    0x82, 
+                        // Process( Major Type 1)
+                        0x20, 
+                        // Parameters, byte string with single byte length
+                        0x58, 
+                            // Byte string length 
+                            0x25, 
+                            // IFX Digest info, array of 2 entries
+                            0x82, 
+                                // Digest Algorithm
+                                0x18,
+                                    // SHA-256
+                                    0x29, 
+                                // Digest
+                                0x58, 
+                                    // Byte string length
+                                    0x20, 
+                                        // Digest data
+                                        0x8A, 0x7A, 0x10, 0x3A, 0xD3, 0xB4, 0xB7, 0xA9,
+                                        0x48, 0x5B, 0x80, 0x1C, 0x7E, 0xD4, 0xD5, 0xAE,
+                                        0xD7, 0x8C, 0xDD, 0xB2, 0x02, 0x9A, 0xA8, 0xC8,
+                                        0x11, 0x90, 0xF0, 0xA8, 0x10, 0xC7, 0x14, 0xD9,
+                    // Processing step decrypt, array of 2 entries
+                    0x82,
+                        // Process( Major Type 0)
+                        0x01,
+                        // COSE_Encrypt_Trust array of 3 entries
+                        0x83,
+                            // protected-encrypt-header-Trust
+                            0x43,
+                                // Map 
+                                0xA1,
+                                    // Key 
+                                    0x01,
+                                    // AES-CCM-16-64-128, 128-bit key, 64-bit Authentication(MAC) tag, 13-byte nonce
+                                    0x0A,
+                            // recipients array of 1
+                            0x81,
+                                // COSE_Recipient_Trust array of 2
+                                0x82,
+                                    // protected-recipient-header-Trust
+                                    0x58,
+                                        // byte str
+                                        0x54,
+                                            // Map of 3
+                                            0xA3,
+                                                // Key
+                                                0x04,
+                                                // Value
+                                                0x42,
+                                                    // Shared secret OID
+                                                    0xF1, 0xD1,
+                                                // Key
+                                                0x01,
+                                                // Value (KeyDerivationAlgorithms)
+                                                0x3A, 0x00, 0x01, 0x00, 0xB7,
+                                                // Key
+                                                0x05,
+                                                // Value array of 2
+                                                0x82,
+                                                    0x44,
+                                                        // label(4)
+                                                        0x74, 0x65, 0x73, 0x74,
+                                                    0x58,
+                                                        0x40,
+                                                        // seed(64)
+                                                        0x8B, 0xE5, 0xD9, 0xF4, 0xEE, 0xA5, 0x5D, 0xD6,
+                                                        0xCF, 0xBE, 0x65, 0x1B, 0x38, 0x99, 0x48, 0x23,
+                                                        0x22, 0xA7, 0x47, 0x95, 0x1E, 0x88, 0x3E, 0x72, 
+                                                        0x3B, 0xCE, 0xB3, 0x11, 0x71, 0xCE, 0x31, 0xB6,
+                                                        0x4F, 0xF0, 0xD1, 0x39, 0xEB, 0xFA, 0x79, 0x73,
+                                                        0x3C, 0x18, 0x55, 0xDD, 0x18, 0x45, 0x32, 0x57,
+                                                        0xB5, 0x29, 0xEE, 0xDD, 0x5A, 0x44, 0x8A, 0x12,
+                                                        0xA2, 0xFB, 0xA8, 0x1A, 0xAE, 0x5B, 0x59, 0x91, 
+                                    // ciphertext-recipient-header-Trust
+                                    0xF6,
+                            // AdditionalInfo
+                            0xF6,
+                // Trust Target
+                0x82, 
+                    // Component identifier(0)
+                    0x40,
+                    // Storage identifier
+                    0x42, 
+                    // Optiga target OID
+                    0xE0, 0xE2, 
+        // Signature info, byte string of single byte length
+        0x58, 
+            // Byte string length for RSA 1024
+            0x80, 
+            // Signature data
+            0x3A, 0x9D, 0x55, 0x74, 0xD3, 0xC4, 0x8A, 0x23, 0xD2, 0x12, 0xED, 0xE8, 0xE3, 0x25, 0xC0, 0x49, 
+            0x06, 0xD8, 0x3C, 0xB5, 0x97, 0x9D, 0x4A, 0xFB, 0x64, 0xAE, 0x84, 0x82, 0x90, 0x39, 0xC0, 0x62, 
+            0xC5, 0xB3, 0xAD, 0x52, 0xDA, 0x01, 0x97, 0xE7, 0xE6, 0x81, 0xD8, 0x44, 0xB3, 0x56, 0x52, 0xC8, 
+            0x5F, 0x2A, 0x2E, 0x76, 0x31, 0x05, 0xA6, 0x27, 0xBE, 0xCB, 0x77, 0xE8, 0xCA, 0x0E, 0xFE, 0xA7,
+            0xEC, 0xF0, 0xA5, 0xD1, 0xF6, 0xAA, 0xF1, 0x14, 0x6E, 0x3C, 0x84, 0x0B, 0x3A, 0xE1, 0xB7, 0xB5,
+            0xC7, 0x58, 0xD1, 0xD2, 0x7D, 0x3D, 0x94, 0x54, 0x78, 0xB7, 0xEC, 0x02, 0xF4, 0x4D, 0x10, 0x4E,
+            0xAD, 0xC8, 0x78, 0x05, 0xE1, 0x42, 0xC6, 0xD4, 0xB1, 0x0B, 0x76, 0x37, 0xC2, 0x2D, 0xF6, 0x8E, 
+            0x73, 0xB1, 0x00, 0x41, 0xB4, 0xE8, 0xEA, 0x0A, 0xA8, 0x19, 0xAC, 0x43, 0x4D, 0x6A, 0x5D, 0x39,
+
+};
+
+/**
+ * Fragment array 
+ */
+const uint8_t metadata_final_fragment_array[] = 
+{
+    0x37, 0x7F, 0x65, 0xC4, 0xE8, 0x39, 0x61, 0x1D, 0xAC, 0x37, 0x67, 0x6F, 0x9E, 0x1D, 0x62, 0x50,
+    0xA2, 0x7A, 0x3E, 0xF1, 0x5B,
+};
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/rsa_key_object_confidentiality.h b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/rsa_key_object_confidentiality.h
new file mode 100644
index 000000000..dfc03dc12
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/protected_update_data_set/rsa_key_object_confidentiality.h
@@ -0,0 +1,218 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file rsa_key_object_confidentiality.h
+*
+* \brief   This file provides the data set for protected update of rsa key object with confidentiality.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include <stdint.h>
+
+/**
+ * Manifest for RSA key update with integrity and confidentiality
+ */
+const uint8_t manifest_rsa_key[] =
+{
+    // COSE Sign1 Trust
+    0x84,
+        // Protected signed header trust
+        0x47,
+            // Trust Sign Algorithm
+            0xA1, 
+            // RSA
+            0x01, 0x3A, 0x00, 0x01, 0x00, 0xA3, 
+        // Unprotected signed header trust
+        0xA1, 
+            // Root of trust
+            0x04, 0x42, 
+            // Trust Anchor OID
+            0xE0, 0xE3, 
+        // Payload info Byte string of single byte length
+        0x58, 
+            // Byte string length of manifest            
+            0x9E, 
+            // Trust manifest, array of 6 entries
+            0x86, 
+            // Version(Major Type 0)
+            0x01,
+            // NULL
+            0xF6,
+            // NULL
+            0xF6,
+            // Resources, array of 4 entries
+            0x84, 
+                // Trust Payload Type
+                0x22,
+                // Payload Length 
+                0x19, 0x01, 0x0D,
+                // Trust Payload version
+                0x03, 
+                // Trust Add info data 
+                0x82, 
+                    // key algorithm
+                    0x18,
+                    // key usage
+                    0x41, 0x12, 
+                // Trust Processors, array of 2 entries 
+                0x82, 
+                    // Processing step integrity, array of 2 entries
+                    0x82, 
+                        // Process( Major Type 1)
+                        0x20, 
+                        // Parameters, byte string with single byte length
+                        0x58, 
+                            // Byte string length 
+                            0x25, 
+                            // IFX Digest info, array of 2 entries
+                            0x82, 
+                                // Digest Algorithm
+                                0x18,
+                                    // SHA-256
+                                    0x29, 
+                                // Digest
+                                0x58, 
+                                    // Byte string length
+                                    0x20, 
+                                        // Digest data
+                                        0xDC, 0x9A, 0x2F, 0xEF, 0x36, 0x27, 0x6C, 0x01,
+                                        0xC0, 0x64, 0x00, 0x69, 0xEA, 0x9A, 0x77, 0x4C,
+                                        0x23, 0x53, 0x43, 0x0E, 0x54, 0xBE, 0x36, 0x21,
+                                        0x98, 0x7A, 0xFD, 0x84, 0x92, 0x2B, 0xC6, 0x2D,
+                    // Processing step decrypt, array of 2 entries
+                    0x82,
+                        // Process( Major Type 0)
+                        0x01,
+                        // COSE_Encrypt_Trust array of 3 entries
+                        0x83,
+                            // protected-encrypt-header-Trust
+                            0x43,
+                                // Map 
+                                0xA1,
+                                    // Key 
+                                    0x01,
+                                    // AES-CCM-16-64-128, 128-bit key, 64-bit Authentication(MAC) tag, 13-byte nonce
+                                    0x0A,
+                            // recipients array of 1
+                            0x81,
+                                // COSE_Recipient_Trust array of 2
+                                0x82,
+                                    // protected-recipient-header-Trust
+                                    0x58,
+                                        // byte str
+                                        0x54,
+                                            // Map of 3
+                                            0xA3,
+                                                // Key
+                                                0x04,
+                                                // Value
+                                                0x42,
+                                                    // Shared secret OID
+                                                    0xF1, 0xD1,
+                                                // Key
+                                                0x01,
+                                                // Value (KeyDerivationAlgorithms)
+                                                0x3A, 0x00, 0x01, 0x00, 0xB7,
+                                                // Key
+                                                0x05,
+                                                // Value array of 2
+                                                0x82,
+                                                    0x44,
+                                                        // label(4)
+                                                        0x74, 0x65, 0x73, 0x74,
+                                                    0x58,
+                                                        0x40,
+                                                        // seed(64)
+                                                        0x10, 0x51, 0xF4, 0x48, 0x77, 0xF3, 0x24, 0xAC,
+                                                        0xB9, 0xE1, 0xCF, 0x89, 0xC7, 0x22, 0x98, 0x3A,
+                                                        0xBE, 0x74, 0x7C, 0x05, 0x6E, 0xC4, 0xFB, 0x66,
+                                                        0x4F, 0xC4, 0x57, 0xB9, 0x23, 0xDC, 0x6C, 0xA0,
+                                                        0x20, 0x62, 0xCC, 0xB0, 0x02, 0x0D, 0x7B, 0x8C, 
+                                                        0x9D, 0x02, 0x4C, 0xF3, 0x7B, 0x3E, 0xAD, 0x12,
+                                                        0x14, 0xC2, 0x14, 0x2B, 0xB3, 0xF7, 0x96, 0x48,
+                                                        0xC8, 0x29, 0x2C, 0x19, 0x14, 0xEF, 0x0C, 0x92,
+                                    // ciphertext-recipient-header-Trust
+                                    0xF6,
+                            // AdditionalInfo
+                            0xF6,
+                // Trust Target
+                0x82, 
+                    // Component identifier(0)
+                    0x40,
+                    // Storage identifier
+                    0x42, 
+                    // Optiga target OID
+                    0xE0, 0xFC, 
+        // Signature info, byte string of single byte length
+        0x58, 
+            // Byte string length for RSA 1024
+            0x80, 
+            // Signature data
+            0xE0, 0xD3, 0x80, 0x3B, 0xC9, 0x6F, 0x2A, 0xB6, 0x2C, 0x71, 0x0A, 0x75, 0x92, 0x07, 0x75, 0x32,
+            0x56, 0x46, 0xAC, 0x52, 0x95, 0xF3, 0xBD, 0x2A, 0x66, 0xA7, 0x41, 0x0B, 0x39, 0xAD, 0xEE, 0x5F,
+            0xBE, 0x23, 0xC8, 0xC6, 0xE5, 0xAF, 0x62, 0xEF, 0x04, 0x9D, 0x30, 0x87, 0x9E, 0xAA, 0xFC, 0xF0,
+            0xEF, 0x36, 0x0D, 0xCC, 0x3E, 0x65, 0x19, 0x2A, 0xA6, 0x10, 0x3D, 0x02, 0x64, 0xD3, 0x36, 0xEE,
+            0xE8, 0xD7, 0xDC, 0xC6, 0x78, 0x9C, 0xEF, 0xFD, 0xEF, 0x62, 0xF0, 0xCD, 0xF3, 0x8E, 0xAC, 0x31,
+            0x31, 0xDD, 0x70, 0xDA, 0x9F, 0x63, 0x0F, 0x8A, 0x95, 0x01, 0xD0, 0x39, 0x2E, 0x9E, 0x15, 0x08,
+            0x64, 0x52, 0x96, 0x4D, 0x27, 0x01, 0x5B, 0x25, 0x12, 0x19, 0xA8, 0xCE, 0x38, 0x67, 0xB7, 0xFD,
+            0xD7, 0xBB, 0xF6, 0xDA, 0x73, 0x62, 0xC2, 0xF1, 0xA4, 0xF9, 0xCE, 0xB8, 0x63, 0x45, 0xE6, 0x8D,
+
+};
+
+
+/**
+ * Fragment array for final payload for RSA key update
+ */
+const uint8_t rsa_key_final_fragment_array[] =
+{
+    0xEE, 0xAE, 0x29, 0xC1, 0x62, 0x92, 0x4E, 0xAD, 0x9F, 0xFD, 0x1D, 0xE7, 0xBC, 0x04, 0x73, 0x5C,
+    0x3E, 0x20, 0x5F, 0xC5, 0xBA, 0x28, 0x3F, 0x8A, 0xC7, 0xEB, 0x01, 0xDE, 0x71, 0x11, 0xF8, 0xCC,
+    0x0C, 0x21, 0x91, 0x5B, 0x71, 0xCA, 0xE8, 0x4F, 0x74, 0x4E, 0x6F, 0x32, 0x54, 0xD9, 0x29, 0xBD,
+    0xFC, 0xEC, 0x7D, 0xB8, 0xE0, 0xA6, 0x08, 0x8E, 0xCE, 0x74, 0xD4, 0x43, 0x90, 0x93, 0xC8, 0x7E,
+    0xFF, 0x4E, 0x69, 0x7C, 0x28, 0x80, 0x6B, 0xBA, 0x3A, 0xB3, 0xD2, 0x51, 0xC8, 0x7A, 0xC9, 0x45,
+    0xE4, 0x37, 0x06, 0x7F, 0xB2, 0xAE, 0xE5, 0xC0, 0xE5, 0xFC, 0xE1, 0xF6, 0x52, 0x7E, 0xBC, 0x89,
+    0xF3, 0x76, 0x8C, 0x59, 0x2B, 0x85, 0x00, 0x2D, 0xBB, 0x43, 0xE6, 0x83, 0xDC, 0x7D, 0xB1, 0x4D,
+    0x37, 0xCF, 0xA8, 0x08, 0xD2, 0x2E, 0x02, 0xF7, 0x53, 0x27, 0x75, 0x1F, 0xE7, 0x37, 0xF9, 0x7E,
+    0x0E, 0xD0, 0xB9, 0xAD, 0x67, 0x0E, 0xE4, 0x93, 0xC4, 0xA7, 0xFC, 0x12, 0xF5, 0x4E, 0x80, 0xF4,
+    0x4A, 0x29, 0x74, 0xA1, 0x3F, 0xEE, 0xA1, 0xCB, 0x28, 0x4E, 0xE4, 0x8C, 0x7C, 0xA9, 0x53, 0xE5,
+    0x07, 0xE8, 0x37, 0x19, 0x12, 0xD1, 0x48, 0xA6, 0x1F, 0xFD, 0x78, 0x09, 0x07, 0x27, 0x6F, 0x9C,
+    0x02, 0xC0, 0x08, 0x31, 0xC2, 0x0B, 0x1E, 0xEB, 0x64, 0x4D, 0x76, 0xB8, 0x68, 0xA9, 0x8C, 0x38,
+    0x62, 0x33, 0x27, 0x6F, 0x4F, 0x95, 0xD7, 0x15, 0xF1, 0x21, 0xD6, 0x8F, 0x1F, 0xC8, 0xC9, 0x58,
+    0x10, 0xEC, 0xD5, 0x03, 0x40, 0xF0, 0xCF, 0xF2, 0x7F, 0x3B, 0x6F, 0x8B, 0x98, 0xE3, 0x4B, 0xD0,
+    0x3E, 0xFF, 0x6A, 0xA1, 0xFE, 0x8E, 0xBF, 0x72, 0x78, 0xE3, 0x6F, 0x01, 0xCB, 0x22, 0x67, 0xB6,
+    0x35, 0xEA, 0xB0, 0x05, 0xDF, 0x15, 0x84, 0x58, 0x43, 0xCD, 0xC4, 0xA7, 0xC3, 0xAE, 0x21, 0xB3,
+    0xD8, 0xC4, 0x87, 0x70, 0xEC, 0x75, 0xA8, 0xE2, 0xE4, 0x6B, 0x11, 0xF7, 0x64, 0x89, 0x41, 0x77,
+    0x89, 0x23, 0x34, 0xA7, 0x8C,
+};
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/usecases/example_ali_id2_key_update.c b/3rdparty/experimental/optiga/examples/optiga/usecases/example_ali_id2_key_update.c
new file mode 100644
index 000000000..b87649456
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/usecases/example_ali_id2_key_update.c
@@ -0,0 +1,437 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file example_optiga_util_protected_update.c
+*
+* \brief   This file provides the example for util protected update operation using #optiga_util_protected_update_start,
+*           #optiga_util_protected_update_continue & #optiga_util_protected_update_final.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include "optiga/optiga_util.h"
+#include "optiga/optiga_crypt.h"
+
+/**
+ * Callback when optiga_util_xxxx operation is completed asynchronously
+ */
+static volatile optiga_lib_status_t optiga_lib_status;
+//lint --e{818} suppress "argument "context" is not used in the sample provided"
+static void optiga_util_callback(void * context, optiga_lib_status_t return_status)
+{
+    optiga_lib_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+/**
+ * Sample Trust Anchor with RSA based certificate
+ */
+const uint8_t trust_anchor [] = 
+{
+    0x30, 0x82, 0x02, 0xD5, 0x30, 0x82, 0x01, 0xBD, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x4D,
+    0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30,
+    0x3C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x49, 0x4E, 0x31, 0x0D,
+    0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31, 0x1E, 0x30,
+    0x1C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x15, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x61, 0x6E,
+    0x63, 0x68, 0x6F, 0x72, 0x20, 0x72, 0x73, 0x61, 0x20, 0x32, 0x30, 0x34, 0x38, 0x30, 0x1E, 0x17,
+    0x0D, 0x31, 0x38, 0x30, 0x36, 0x31, 0x31, 0x30, 0x37, 0x32, 0x35, 0x35, 0x36, 0x5A, 0x17, 0x0D, 
+    0x32, 0x38, 0x30, 0x36, 0x30, 0x38, 0x30, 0x37, 0x32, 0x35, 0x35, 0x36, 0x5A, 0x30, 0x3C, 0x31, 
+    0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x49, 0x4E, 0x31, 0x0D, 0x30, 0x0B, 
+    0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31, 0x1E, 0x30, 0x1C, 0x06, 
+    0x03, 0x55, 0x04, 0x03, 0x0C, 0x15, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 
+    0x74, 0x65, 0x20, 0x72, 0x73, 0x61, 0x20, 0x31, 0x30, 0x32, 0x34, 0x30, 0x81, 0x9F, 0x30, 0x0D, 
+    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8D, 
+    0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xE1, 0x26, 0x9F, 0x49, 0x2B, 0xA0, 0xCF, 0x88, 
+    0xAB, 0x10, 0x6A, 0x48, 0x64, 0xAD, 0xBF, 0xED, 0x95, 0xAE, 0x49, 0xE6, 0x85, 0x78, 0x56, 0x5F, 
+    0x44, 0x0A, 0xD5, 0x3E, 0x76, 0x16, 0x70, 0xD1, 0x15, 0x04, 0x04, 0x15, 0x3A, 0xD3, 0xBE, 0xF0, 
+    0xA9, 0x68, 0x1B, 0x0A, 0x8F, 0xDC, 0xE4, 0x09, 0x5F, 0xF7, 0x27, 0xED, 0x68, 0x22, 0x54, 0xCA, 
+    0xB5, 0xB2, 0x7A, 0xD0, 0xBD, 0x60, 0x97, 0x5A, 0x17, 0x3B, 0x6B, 0x9D, 0xF7, 0x12, 0xD5, 0x01, 
+    0x9C, 0x7C, 0x89, 0x4F, 0xE2, 0x28, 0x44, 0xC8, 0x7E, 0xC4, 0x49, 0xFB, 0xDF, 0x31, 0xBF, 0x32, 
+    0xDC, 0xC6, 0x2B, 0x32, 0xDC, 0x73, 0x41, 0xB2, 0x92, 0xE9, 0x90, 0xB5, 0x93, 0xFF, 0x60, 0x10, 
+    0xC3, 0x45, 0xF3, 0xE6, 0x07, 0x04, 0xF0, 0xA2, 0x67, 0x2F, 0x5F, 0x53, 0xA5, 0xFC, 0x1B, 0x30, 
+    0xE5, 0x7E, 0x8E, 0x94, 0x85, 0x13, 0x13, 0x9B, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x66, 0x30, 
+    0x64, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x82, 0xDA, 0x0A, 0xF9, 
+    0x6A, 0x37, 0x49, 0x71, 0xA1, 0x9E, 0x61, 0x4E, 0x46, 0xEB, 0xA9, 0x19, 0x9F, 0x59, 0xAB, 0x28, 
+    0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xDF, 0xE4, 0xB1, 
+    0x34, 0x53, 0x2D, 0x46, 0x50, 0xCD, 0x7D, 0xFB, 0xF8, 0x68, 0x1F, 0xCB, 0xF4, 0x29, 0xA5, 0x4C, 
+    0xD1, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 
+    0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 
+    0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 
+    0x01, 0x0B, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x21, 0x4F, 0x0B, 0x00, 0x0E, 0x63, 0x77, 
+    0xE2, 0x6D, 0x54, 0x25, 0xDC, 0xD6, 0x5F, 0xFF, 0xED, 0x6B, 0x9B, 0x7C, 0x28, 0xA4, 0x09, 0x63, 
+    0x93, 0xCC, 0x91, 0xBB, 0xAC, 0x2A, 0xD6, 0x93, 0x56, 0x30, 0x1C, 0x11, 0x9C, 0x9D, 0xA4, 0xD9, 
+    0xD5, 0x45, 0x52, 0x26, 0xDF, 0xFA, 0x65, 0xCB, 0xA1, 0xF0, 0x63, 0xA0, 0xE4, 0xB1, 0xCD, 0xFF, 
+    0xB4, 0x52, 0x6B, 0x38, 0x35, 0x17, 0x29, 0x15, 0x8A, 0xCC, 0xEC, 0xDE, 0x5E, 0x87, 0x63, 0x47, 
+    0xDE, 0x32, 0xBA, 0xB1, 0x90, 0xAF, 0x5C, 0xCB, 0x6F, 0xBA, 0x48, 0x29, 0x55, 0xF0, 0xED, 0xA7, 
+    0xDD, 0x75, 0x7E, 0x68, 0x42, 0xD2, 0xB3, 0xC4, 0xC5, 0x2B, 0x90, 0x3B, 0xBC, 0xCF, 0xC6, 0x96, 
+    0xA6, 0x5F, 0xB9, 0x70, 0xAD, 0x05, 0x67, 0xB3, 0x3A, 0xF9, 0x9D, 0x7F, 0xEF, 0x7A, 0xDE, 0x68, 
+    0xCF, 0xEE, 0x1D, 0xDF, 0x2F, 0xFF, 0x3D, 0x38, 0x92, 0xF3, 0x85, 0x00, 0x11, 0x89, 0x9F, 0xBF, 
+    0xDD, 0x88, 0x79, 0xAE, 0xE0, 0xE2, 0xE1, 0x56, 0x46, 0x8C, 0x32, 0x37, 0xCA, 0x6D, 0x25, 0x43, 
+    0x7F, 0x90, 0xC0, 0xFB, 0xDA, 0xAC, 0xB4, 0x6D, 0xD3, 0xAF, 0x9B, 0xFD, 0x67, 0xEC, 0x3A, 0x6A, 
+    0x9E, 0x8E, 0x19, 0xA3, 0xE6, 0x19, 0x63, 0x5A, 0x94, 0x7C, 0x71, 0x2F, 0x4A, 0xD3, 0x31, 0xDA, 
+    0x8E, 0x00, 0x69, 0xD2, 0xD3, 0x1A, 0xAA, 0x3D, 0x24, 0xC1, 0xF3, 0xB5, 0x3C, 0x55, 0x76, 0xCB, 
+    0x05, 0xB9, 0x95, 0x2F, 0x53, 0xBC, 0x98, 0x5E, 0x26, 0xC3, 0xD7, 0x1F, 0x87, 0x18, 0x24, 0x36, 
+    0x9A, 0xEE, 0x8F, 0xF7, 0xF6, 0xB8, 0x06, 0xEC, 0x07, 0x7C, 0x5E, 0x96, 0x51, 0x3F, 0x13, 0x35, 
+    0x14, 0x1B, 0x67, 0x10, 0xE8, 0x28, 0xB1, 0x9E, 0xBE, 0x5B, 0xBC, 0x13, 0x48, 0x9A, 0x76, 0x2F, 
+    0x84, 0xAD, 0x63, 0x2C, 0x8F, 0xBA, 0x40, 0x6C, 0xA0
+};
+
+/**
+ * Manifest for AES key update with integrity protected
+ */
+const uint8_t manifest_aes_key[] = 
+{
+        0x84, 0x47, 0xA1, 0x01, 0x3A, 0x00, 0x01, 0x00, 0xA3, 0xA1, 0x04, 0x42, 0xE0, 0xE3, 0x58, 0x3C,
+        0x86, 0x01, 0xF6, 0xF6, 0x84, 0x22, 0x13, 0x03, 0x82, 0x18, 0x81, 0x02, 0x82, 0x82, 0x20, 0x58,
+        0x25, 0x82, 0x18, 0x29, 0x58, 0x20, 0x37, 0x5E, 0x3D, 0xD1, 0x7A, 0xA8, 0x59, 0x88, 0xA2, 0x4A,
+        0xB9, 0xC2, 0x9A, 0xBA, 0xCD, 0x2A, 0xD8, 0x8B, 0x06, 0x33, 0xD1, 0x84, 0x5B, 0x31, 0x4F, 0xDC,
+        0x5D, 0xCD, 0x36, 0x58, 0x8C, 0xE7, 0xF6, 0x82, 0x40, 0x42, 0xE2, 0x00, 0x58, 0x80, 0x60, 0x4D,
+        0xA6, 0x5F, 0x81, 0x40, 0x32, 0x49, 0x39, 0xC4, 0x0B, 0xD6, 0x5D, 0xE5, 0xBA, 0xBC, 0xAA, 0x4A,
+        0xEB, 0xAF, 0xC4, 0x0A, 0x08, 0xDC, 0x0B, 0xED, 0x10, 0x63, 0x66, 0x08, 0xFA, 0x4C, 0x3C, 0x1F,
+        0x41, 0x50, 0x1A, 0x13, 0x93, 0xAF, 0x36, 0x2E, 0x86, 0x46, 0x98, 0x36, 0x5C, 0xD5, 0x41, 0xE2,
+        0x15, 0x1E, 0xF4, 0x37, 0x7E, 0x5D, 0x43, 0xB6, 0x1E, 0x49, 0xB6, 0xA8, 0x43, 0xAC, 0x66, 0x20,
+        0xFE, 0xEE, 0x4C, 0x7C, 0x76, 0x66, 0xDA, 0xFF, 0xAC, 0x01, 0x89, 0xD9, 0x63, 0x18, 0x76, 0x3C,
+        0xB0, 0x0C, 0x54, 0x75, 0x2C, 0x17, 0xB2, 0xE6, 0xE7, 0x6E, 0x22, 0xC4, 0x89, 0xE7, 0x68, 0xD9,
+        0x37, 0x2F, 0xE8, 0xAD, 0x31, 0x76, 0x7A, 0xB5, 0x5C, 0x5A, 0x7B, 0xD0, 0x1F, 0x75, 0x2A, 0x66,
+        0x37, 0x86, 0x96, 0xF1, 0x34, 0x01, 0x28, 0xE1, 0x11, 0x20, 0xCF, 0x69, 0x20, 0x56,
+};
+
+/**
+ * Fragment array for final with 19 bytes of payload for AES key update
+ */
+const uint8_t aes_key_final_fragment_array[] = 
+{
+    // Payload of 27 bytes  (16 bytes AES key,3 bytes for TL and 8 byte MAC)
+        0x01, 0x00, 0x10, 0x22, 0x38, 0x5E, 0xA7, 0xEB, 0x61, 0x94, 0xB9, 0xD7, 0xFF, 0xD4, 0x1C, 0xA5,
+        0x68, 0x34, 0xD3,
+};
+
+/**
+ * Sample metadata of 0xE0E3 for execute access condition
+ */
+const uint8_t E0E3_metadata[] = { 0x20, 0x06, 0xD3, 0x01, 0x00, 0xe8, 0x01, 0x11 };
+
+/**
+ * Sample metadata of 0xE200
+ */
+const uint8_t E200_metadata[] = { 0x20, 0x09, 0xD0, 0x03, 0x21, 0xE0, 0xE3, 0xC1, 0x02, 0x00, 0x00 };
+
+/**
+ * Sample data of ID2 device ID
+ */
+uint8_t device_id[] = {0x00,0x65,0xE2,0x29,0xF0,0x0F,0x28,0x26,0xE7,0x81,0x27,0x00};
+
+/**
+ * Local functions prototype
+ */
+static optiga_lib_status_t write_metadata_aes_key_update ( optiga_util_t * me);
+static optiga_lib_status_t write_ecc_256_certificate ( optiga_util_t * me);
+
+
+/**
+ * The below example demonstrates the protected update of AES key using #optiga_util_protected_update_start,
+ * optiga_util_protected_update_continue & optiga_util_protected_update_final
+ *
+ * This example uses OID 0xE0E3 as Trust Anchor and OID 0xE200 as Target OID. Signature algorithm used is ECC-256.
+ *
+ * Example for #optiga_util_protected_update_start,#optiga_util_protected_update_final.
+ *
+ */
+void example_optiga_util_ali_id2_aes_key_update(void)
+{
+    optiga_lib_status_t return_status = 0;
+    uint16_t optiga_oid;
+    uint16_t offset,size;
+    optiga_util_t * me = NULL;
+
+    do
+    {
+        /**
+         *  Create OPTIGA util Instance
+         *
+         */
+        me = optiga_util_create(0, optiga_util_callback, NULL);
+        if (NULL == me)
+        {
+            break;
+        }
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_open_application(me, 0);
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+        while (optiga_lib_status == OPTIGA_LIB_BUSY)
+        {
+            //Wait until the optiga_util_open_application is completed
+        }
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //optiga util open application failed
+            break;
+        }
+        #if 1
+        /**
+         * Write Trust Anchor to a Trust Anchor object (e.g. E0E8)
+         * using optiga_util_write_data with no shielded connection protection.
+         *
+         * Use Erase and Write (OPTIGA_UTIL_ERASE_AND_WRITE) option,
+         * to clear the remaining data in the object
+         */
+        optiga_oid = 0xf1d0;
+        offset = 0x00;
+
+        OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL(me, OPTIGA_COMMS_RESPONSE_PROTECTION);
+
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_write_data(me,
+                                               optiga_oid,
+                                               OPTIGA_UTIL_ERASE_AND_WRITE,
+                                               offset,
+                                               device_id,
+                                               sizeof(device_id));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_data operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing data to a data object failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+
+        /**
+        *  Precondition 1 : Write Metadata for 0xE0E3 and 0xE200
+         */
+        return_status = write_metadata_aes_key_update( me);
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        /**
+        *  Precondition 2 : Write ECC-256 certificate for 0xE0E3
+         */
+        return_status = write_ecc_256_certificate( me);
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+        
+        
+        /**
+        *   Send the manifest using optiga_util_protected_update_start
+        */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_protected_update_start(me,
+                                                           0x01,
+                                                           manifest_aes_key,
+                                                           sizeof(manifest_aes_key));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_data operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing data to a data object failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+
+        /**
+        *   Send the last fragment using optiga_util_protected_update_final
+        */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_protected_update_final(me,
+                                                           aes_key_final_fragment_array,
+                                                           sizeof(aes_key_final_fragment_array));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_data operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing data to a data object failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+        #endif //samir
+    } while (FALSE);
+    
+    if (me)
+    {
+        //Destroy the instance after the completion of usecase if not required.
+        return_status = optiga_util_destroy(me);
+        if(OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro
+        }
+    }
+}
+
+static optiga_lib_status_t write_ecc_256_certificate ( optiga_util_t * me)
+{
+    optiga_lib_status_t return_status = 0;
+    uint16_t optiga_oid;
+    uint16_t offset;
+
+    do
+    {
+        /**
+        *   valid ECC-256 with sha256 certificate is available in oid 0xE0E3
+        */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        optiga_oid = 0xE0E3;
+        offset = 0x00;
+        return_status = optiga_util_write_data(me,
+                                               optiga_oid,
+                                               OPTIGA_UTIL_ERASE_AND_WRITE,
+                                               offset,
+                                               trust_anchor,
+                                               sizeof(trust_anchor));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_data operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing data to a data object failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+    } while (FALSE);
+
+    return (return_status);
+
+}
+
+static optiga_lib_status_t write_metadata_aes_key_update( optiga_util_t * me)
+{
+    optiga_lib_status_t return_status = 0;
+    uint16_t optiga_oid;
+
+    do
+    {
+        /**
+        *   set meta data "0x20 0x09 0xD0 0x03 0x21 0xE0 0xE8 0xC1 0x02 0x00 0x00" for oids 0xE0E1
+        */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        optiga_oid = 0xE200;
+        return_status = optiga_util_write_metadata(me,
+                                                   optiga_oid,
+                                                   E200_metadata,
+                                                   sizeof(E200_metadata));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_metadata operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing metadata to a data object failed.
+            return_status = optiga_lib_status;            
+            break;
+        }
+
+        /**
+        *   set meta data "0x20 0x03 0xD3 0x01 0x00" for oid 0xE0E3
+        */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        optiga_oid = 0xE0E3;
+        return_status = optiga_util_write_metadata(me,
+                                                   optiga_oid,
+                                                   E0E3_metadata,
+                                                   sizeof(E0E3_metadata));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_metadata operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing metadata to a data object failed.
+            return_status = optiga_lib_status;            
+            break;
+        }
+        
+      
+    } while (FALSE);
+
+    return (return_status);
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/usecases/example_ali_id2_rsa_key_update.c b/3rdparty/experimental/optiga/examples/optiga/usecases/example_ali_id2_rsa_key_update.c
new file mode 100644
index 000000000..b305f9c0b
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/usecases/example_ali_id2_rsa_key_update.c
@@ -0,0 +1,501 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file example_optiga_util_protected_update.c
+*
+* \brief   This file provides the example for util protected update operation using #optiga_util_protected_update_start,
+*           #optiga_util_protected_update_continue & #optiga_util_protected_update_final.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include "optiga/optiga_util.h"
+
+/**
+ * Callback when optiga_util_xxxx operation is completed asynchronously
+ */
+static volatile optiga_lib_status_t optiga_lib_status;
+//lint --e{818} suppress "argument "context" is not used in the sample provided"
+static void optiga_util_callback(void * context, optiga_lib_status_t return_status)
+{
+    optiga_lib_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+/**
+ * RSA Trust Anchor
+ */
+const uint8_t trust_anchor [] = 
+{
+    0x30, 0x82, 0x02, 0xD5, 0x30, 0x82, 0x01, 0xBD, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x4D,
+    0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30,
+    0x3C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x49, 0x4E, 0x31, 0x0D,
+    0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31, 0x1E, 0x30,
+    0x1C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x15, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x61, 0x6E,
+    0x63, 0x68, 0x6F, 0x72, 0x20, 0x72, 0x73, 0x61, 0x20, 0x32, 0x30, 0x34, 0x38, 0x30, 0x1E, 0x17,
+    0x0D, 0x31, 0x38, 0x30, 0x36, 0x31, 0x31, 0x30, 0x37, 0x32, 0x35, 0x35, 0x36, 0x5A, 0x17, 0x0D, 
+    0x32, 0x38, 0x30, 0x36, 0x30, 0x38, 0x30, 0x37, 0x32, 0x35, 0x35, 0x36, 0x5A, 0x30, 0x3C, 0x31, 
+    0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x49, 0x4E, 0x31, 0x0D, 0x30, 0x0B, 
+    0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31, 0x1E, 0x30, 0x1C, 0x06, 
+    0x03, 0x55, 0x04, 0x03, 0x0C, 0x15, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 
+    0x74, 0x65, 0x20, 0x72, 0x73, 0x61, 0x20, 0x31, 0x30, 0x32, 0x34, 0x30, 0x81, 0x9F, 0x30, 0x0D, 
+    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8D, 
+    0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xE1, 0x26, 0x9F, 0x49, 0x2B, 0xA0, 0xCF, 0x88, 
+    0xAB, 0x10, 0x6A, 0x48, 0x64, 0xAD, 0xBF, 0xED, 0x95, 0xAE, 0x49, 0xE6, 0x85, 0x78, 0x56, 0x5F, 
+    0x44, 0x0A, 0xD5, 0x3E, 0x76, 0x16, 0x70, 0xD1, 0x15, 0x04, 0x04, 0x15, 0x3A, 0xD3, 0xBE, 0xF0, 
+    0xA9, 0x68, 0x1B, 0x0A, 0x8F, 0xDC, 0xE4, 0x09, 0x5F, 0xF7, 0x27, 0xED, 0x68, 0x22, 0x54, 0xCA, 
+    0xB5, 0xB2, 0x7A, 0xD0, 0xBD, 0x60, 0x97, 0x5A, 0x17, 0x3B, 0x6B, 0x9D, 0xF7, 0x12, 0xD5, 0x01, 
+    0x9C, 0x7C, 0x89, 0x4F, 0xE2, 0x28, 0x44, 0xC8, 0x7E, 0xC4, 0x49, 0xFB, 0xDF, 0x31, 0xBF, 0x32, 
+    0xDC, 0xC6, 0x2B, 0x32, 0xDC, 0x73, 0x41, 0xB2, 0x92, 0xE9, 0x90, 0xB5, 0x93, 0xFF, 0x60, 0x10, 
+    0xC3, 0x45, 0xF3, 0xE6, 0x07, 0x04, 0xF0, 0xA2, 0x67, 0x2F, 0x5F, 0x53, 0xA5, 0xFC, 0x1B, 0x30, 
+    0xE5, 0x7E, 0x8E, 0x94, 0x85, 0x13, 0x13, 0x9B, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x66, 0x30, 
+    0x64, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x82, 0xDA, 0x0A, 0xF9, 
+    0x6A, 0x37, 0x49, 0x71, 0xA1, 0x9E, 0x61, 0x4E, 0x46, 0xEB, 0xA9, 0x19, 0x9F, 0x59, 0xAB, 0x28, 
+    0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xDF, 0xE4, 0xB1, 
+    0x34, 0x53, 0x2D, 0x46, 0x50, 0xCD, 0x7D, 0xFB, 0xF8, 0x68, 0x1F, 0xCB, 0xF4, 0x29, 0xA5, 0x4C, 
+    0xD1, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 
+    0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 
+    0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 
+    0x01, 0x0B, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x21, 0x4F, 0x0B, 0x00, 0x0E, 0x63, 0x77, 
+    0xE2, 0x6D, 0x54, 0x25, 0xDC, 0xD6, 0x5F, 0xFF, 0xED, 0x6B, 0x9B, 0x7C, 0x28, 0xA4, 0x09, 0x63, 
+    0x93, 0xCC, 0x91, 0xBB, 0xAC, 0x2A, 0xD6, 0x93, 0x56, 0x30, 0x1C, 0x11, 0x9C, 0x9D, 0xA4, 0xD9, 
+    0xD5, 0x45, 0x52, 0x26, 0xDF, 0xFA, 0x65, 0xCB, 0xA1, 0xF0, 0x63, 0xA0, 0xE4, 0xB1, 0xCD, 0xFF, 
+    0xB4, 0x52, 0x6B, 0x38, 0x35, 0x17, 0x29, 0x15, 0x8A, 0xCC, 0xEC, 0xDE, 0x5E, 0x87, 0x63, 0x47, 
+    0xDE, 0x32, 0xBA, 0xB1, 0x90, 0xAF, 0x5C, 0xCB, 0x6F, 0xBA, 0x48, 0x29, 0x55, 0xF0, 0xED, 0xA7, 
+    0xDD, 0x75, 0x7E, 0x68, 0x42, 0xD2, 0xB3, 0xC4, 0xC5, 0x2B, 0x90, 0x3B, 0xBC, 0xCF, 0xC6, 0x96, 
+    0xA6, 0x5F, 0xB9, 0x70, 0xAD, 0x05, 0x67, 0xB3, 0x3A, 0xF9, 0x9D, 0x7F, 0xEF, 0x7A, 0xDE, 0x68, 
+    0xCF, 0xEE, 0x1D, 0xDF, 0x2F, 0xFF, 0x3D, 0x38, 0x92, 0xF3, 0x85, 0x00, 0x11, 0x89, 0x9F, 0xBF, 
+    0xDD, 0x88, 0x79, 0xAE, 0xE0, 0xE2, 0xE1, 0x56, 0x46, 0x8C, 0x32, 0x37, 0xCA, 0x6D, 0x25, 0x43, 
+    0x7F, 0x90, 0xC0, 0xFB, 0xDA, 0xAC, 0xB4, 0x6D, 0xD3, 0xAF, 0x9B, 0xFD, 0x67, 0xEC, 0x3A, 0x6A, 
+    0x9E, 0x8E, 0x19, 0xA3, 0xE6, 0x19, 0x63, 0x5A, 0x94, 0x7C, 0x71, 0x2F, 0x4A, 0xD3, 0x31, 0xDA, 
+    0x8E, 0x00, 0x69, 0xD2, 0xD3, 0x1A, 0xAA, 0x3D, 0x24, 0xC1, 0xF3, 0xB5, 0x3C, 0x55, 0x76, 0xCB, 
+    0x05, 0xB9, 0x95, 0x2F, 0x53, 0xBC, 0x98, 0x5E, 0x26, 0xC3, 0xD7, 0x1F, 0x87, 0x18, 0x24, 0x36, 
+    0x9A, 0xEE, 0x8F, 0xF7, 0xF6, 0xB8, 0x06, 0xEC, 0x07, 0x7C, 0x5E, 0x96, 0x51, 0x3F, 0x13, 0x35, 
+    0x14, 0x1B, 0x67, 0x10, 0xE8, 0x28, 0xB1, 0x9E, 0xBE, 0x5B, 0xBC, 0x13, 0x48, 0x9A, 0x76, 0x2F, 
+    0x84, 0xAD, 0x63, 0x2C, 0x8F, 0xBA, 0x40, 0x6C, 0xA0
+};
+
+/**
+ * Metadata for target OID :
+ * Change access condition = Integrity protected using 0xE0E3.
+ *
+ * Note :
+ * The Reset Tag (0xC1) is added only for example execution. Recommended metadata to be used is
+ * 0x20, 0x05, 0xD0, 0x03, 0x21, 0xE0, 0xE3
+ */
+uint8_t target_oid_metadata[] = { 0x20, 0x09,
+                                      0xD0, 0x03, 0x21, 0xE0, 0xE3,
+                                      0xC1, 0x02, 0x00, 0x00 }; 
+
+
+/**
+ * Metadata for target OID with confidentiality :
+ * Change access condition = Integrity protected using 0xE0E3 & Confidentiality using 0xF1D0
+ *
+ * Note :
+ * The Reset Tag (0xC1) is added only for example execution. Recommended metadata to be used is
+ * 0x20, 0x09, 0xD0, 0x07, 0x21, 0xE0, 0xE3, 0xFD, 0x20, 0xF1, 0xD0
+ */
+uint8_t target_oid_metadata_with_confidentiality[] = { 0x20, 0x0D,
+                                                           0xC1, 0x02, 0x00, 0x00,
+                                                           0xD0, 0x07, 0x21, 0xE0, 0xE3, 0xFD, 0x20, 0xF1, 0xD0 };
+
+/**
+ * Metadata for Trust Anchor :
+ * Execute access condition = Always
+ * Data object type  =  Trust Anchor
+ */
+uint8_t trust_anchor_metadata[] = { 0x20, 0x06,
+                                        0xD3, 0x01, 0x00,
+                                        0xE8, 0x01, 0x11 };
+
+
+/**
+ * Metadata for target key OID :
+ * Change access condition = Integrity protected using 0xE0E3
+ * Execute access condition = Always
+ *
+ * Note :
+ * The Reset Tag (0xC1) is added only for example execution. Recommended metadata to be used is
+ * 0x20, 0x08,0xD0, 0x03, 0x21, 0xE0, 0xE3, 0xD3, 0x01, 0x00
+ */
+uint8_t target_key_oid_metadata[] = { 0x20, 0x0C,
+                                          0xC1, 0x02, 0x00, 0x00,
+                                          0xD0, 0x03, 0x21, 0xE0, 0xE3,
+                                          0xD3, 0x01, 0x00 };
+
+
+/**
+ * Local functions prototype
+ */
+static optiga_lib_status_t write_metadata(uint16_t oid, uint8_t * metadata, uint8_t metadata_length);
+static optiga_lib_status_t write_trust_anchor(uint16_t trust_anchor_oid);
+
+
+/**
+ * Manifest for RSA key update with integrity
+ */
+const uint8_t manifest_rsa_key[] =
+{
+        0x84, 0x43, 0xA1, 0x01, 0x26, 0xA1, 0x04, 0x42, 0xE0, 0xE3, 0x58, 0x3E, 0x86, 0x01, 0xF6, 0xF6,
+        0x84, 0x22, 0x19, 0x01, 0x0D, 0x03, 0x82, 0x18, 0x41, 0x12, 0x82, 0x82, 0x20, 0x58, 0x25, 0x82,
+        0x18, 0x29, 0x58, 0x20, 0x0C, 0x12, 0x57, 0x30, 0x55, 0x27, 0x90, 0x16, 0x5C, 0x77, 0x9F, 0x70,
+        0x05, 0x65, 0x5B, 0x9D, 0xE4, 0x84, 0xED, 0xF0, 0x7D, 0x9C, 0x0A, 0x77, 0x4A, 0x02, 0x80, 0x7B,
+        0xA1, 0xC0, 0xD6, 0x38, 0xF6, 0x82, 0x40, 0x42, 0xE0, 0xFC, 0x58, 0x40, 0x73, 0x63, 0x22, 0x51,
+        0x0B, 0x31, 0x05, 0x9F, 0xEE, 0x8B, 0x40, 0x0B, 0x0C, 0xDB, 0xD7, 0x34, 0x87, 0x8C, 0x77, 0xD9,
+        0xD3, 0x45, 0x19, 0xA0, 0x7E, 0x9E, 0x8D, 0x4B, 0x2A, 0xB5, 0x3F, 0x05, 0xE3, 0xA7, 0x70, 0xF8,
+        0xE2, 0x28, 0x07, 0x83, 0x97, 0x29, 0xE7, 0x6A, 0x90, 0x19, 0x86, 0x7A, 0x8E, 0x1D, 0x80, 0xA4,
+        0xA0, 0xBE, 0x32, 0xC2, 0x31, 0x8A, 0xCF, 0x9E, 0x3D, 0x85, 0x25, 0xEE,
+};
+
+
+/**
+ * Fragment array for final payload for RSA key update
+ */
+const uint8_t rsa_key_final_fragment_array[] =
+{
+        0x01, 0x00, 0x80, 0x46, 0xE7, 0xAA, 0x63, 0xE6, 0x91, 0x7C, 0xE7, 0x01, 0x11, 0x7C, 0x10, 0xC8,
+        0x88, 0x74, 0xCB, 0x5B, 0x9F, 0xB8, 0x7C, 0xC3, 0x19, 0x60, 0x2C, 0x0C, 0x66, 0x3E, 0xC5, 0x61,
+        0x83, 0x2D, 0xDB, 0xC5, 0x84, 0x2A, 0xF7, 0xD3, 0x24, 0x63, 0x4C, 0xD9, 0xE9, 0xEB, 0x98, 0xED,
+        0xEC, 0x98, 0xA3, 0x5B, 0x21, 0x6C, 0xA6, 0xB8, 0x3B, 0xD1, 0x8C, 0x66, 0xB7, 0x64, 0xCB, 0xA1,
+        0x52, 0x27, 0x16, 0x60, 0x5B, 0xDA, 0x85, 0x8B, 0x6C, 0xE4, 0x96, 0x71, 0xFE, 0x01, 0x4E, 0x09,
+        0xB6, 0x0C, 0x19, 0xC6, 0x3C, 0xD9, 0x9A, 0x7B, 0xE9, 0xAD, 0xEE, 0x8B, 0x46, 0x5F, 0x8C, 0x5A,
+        0x9A, 0x41, 0xAA, 0x01, 0x9A, 0x23, 0x22, 0x88, 0xFB, 0x30, 0x5D, 0xE1, 0xF6, 0xFB, 0xFB, 0x9E,
+        0x83, 0x29, 0x6C, 0x90, 0xAD, 0x73, 0x08, 0x79, 0xE7, 0xF2, 0x0D, 0x75, 0x2D, 0x5A, 0xCF, 0xAF,
+        0x6B, 0xCE, 0xC1, 0x02, 0x00, 0x80, 0xA7, 0xDF, 0x88, 0x40, 0x01, 0xAD, 0x72, 0x0B, 0x5B, 0x46,
+        0x74, 0x45, 0x67, 0x78, 0xA7, 0xC2, 0xD1, 0x50, 0xD2, 0x3C, 0x2A, 0x44, 0x01, 0x32, 0x6A, 0xD6,
+        0x91, 0xCD, 0xD2, 0x5F, 0xDC, 0x7A, 0x25, 0x0C, 0x3D, 0x68, 0x7A, 0x69, 0x52, 0xA4, 0xF1, 0xA9,
+        0xC3, 0xDB, 0x80, 0x89, 0x60, 0xD6, 0x72, 0x13, 0x24, 0x4C, 0xF4, 0x10, 0xC6, 0x35, 0xBC, 0x0F,
+        0x88, 0x51, 0xA9, 0xB1, 0x8F, 0x75, 0xDD, 0xBE, 0xB0, 0x37, 0x61, 0xC8, 0xBC, 0xF5, 0x1B, 0xCB,
+        0x85, 0x07, 0x81, 0x3C, 0x5C, 0x27, 0x1D, 0x3B, 0x09, 0x34, 0xF9, 0xD6, 0x09, 0x89, 0x40, 0x5A,
+        0x03, 0x62, 0x6C, 0x57, 0x65, 0x70, 0x4B, 0x14, 0x99, 0xF2, 0x62, 0xBC, 0x9F, 0xD0, 0x7B, 0x9F,
+        0x1B, 0xE8, 0xC5, 0xE1, 0x7F, 0xB1, 0x78, 0x79, 0x34, 0xE1, 0x7D, 0x77, 0x4F, 0x48, 0xB8, 0x8F,
+        0x53, 0x4B, 0xBC, 0x7D, 0xA9, 0x3B, 0x03, 0x00, 0x04, 0x00, 0x01, 0x00, 0x01,
+};
+
+/**
+ * Sample data of ID2 device ID
+ */
+//uint8_t device_id[] = {0x00, 0x65,0xE2, 0x29, 0xBB, 0x5F, 0x6F, 0xBB, 0xCA, 0x61, 0x68, 0x00}; //ID 2
+//uint8_t device_id[] = {0x00, 0x65, 0xE2,0x29, 0xBB, 0x5F, 0x6F, 0x8B, 0x41, 0xBD, 0xF5, 0x00}; //ID 1
+uint8_t rsa_device_id[] = {0x00, 0x65, 0xE2, 0x29, 0xBB, 0x5F, 0x6F, 0x8B, 0x41, 0xBD, 0xF5, 0x00};//0065E229BB5F6F8B41BDF500
+
+/**
+ * The below example demonstrates the protected update of rsa 1024 key with confidentiality using 
+ * #optiga_util_protected_update_start, & #optiga_util_protected_update_final
+ *
+ * This example updates an ECC into the target OID 0xE0FC using trust anchor OID 0xE0E3 and confidentiality using OID 
+ * 0xF1D0. The Signature algorithm is ECC-256.
+ *
+ * Example for #optiga_util_protected_update_start & #optiga_util_protected_update_final.
+ *
+ */
+void example_optiga_util_ali_id2_rsa_key_update(void)
+{
+    optiga_lib_status_t return_status = OPTIGA_LIB_SUCCESS;
+
+    optiga_util_t * me = NULL;
+    uint16_t optiga_oid;
+    uint16_t offset,size;
+    uint16_t target_oid  = 0xE0FC;
+    uint16_t trust_anchor_oid = 0xE0E3; 
+
+    do
+    {
+        /**
+         *  Create OPTIGA util Instance
+         *
+         */
+        me = optiga_util_create(0, optiga_util_callback, NULL);
+        if (NULL == me)
+        {
+            break;
+        }
+        #if 1
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_open_application(me, 0);
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+        while (optiga_lib_status == OPTIGA_LIB_BUSY)
+        {
+            //Wait until the optiga_util_open_application is completed
+        }
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //optiga util open application failed
+            break;
+        }
+
+        /**
+         * Write Trust Anchor to a Trust Anchor object (e.g. E0E8)
+         * using optiga_util_write_data with no shielded connection protection.
+         *
+         * Use Erase and Write (OPTIGA_UTIL_ERASE_AND_WRITE) option,
+         * to clear the remaining data in the object
+         */
+        optiga_oid = 0xf1d0;
+        offset = 0x00;
+
+        OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL(me, OPTIGA_COMMS_RESPONSE_PROTECTION);
+
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_write_data(me,
+                                               optiga_oid,
+                                               OPTIGA_UTIL_ERASE_AND_WRITE,
+                                               offset,
+                                               rsa_device_id,
+                                               sizeof(rsa_device_id));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_data operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing data to a data object failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+        #endif
+        /**
+         * Precondition 1 :
+         * Update Metadata for 0xE0FC :
+         * Change access condition = Integrity protected using 0xE0E3
+         * Execute access condition = Always
+         */
+        return_status = write_metadata(target_oid,target_key_oid_metadata,sizeof(target_key_oid_metadata));
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        /**
+         * Precondition 2 :
+         * Metadata for 0xE0E3 :
+         * Execute access condition = Always
+         * Data object type  =  Trust Anchor
+         */
+        return_status = write_metadata(trust_anchor_oid,trust_anchor_metadata,sizeof(trust_anchor_metadata));
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        /**
+        *  Precondition 4 :
+        *  Update trust anchor
+         */
+        return_status = write_trust_anchor(trust_anchor_oid);
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        /**
+        *   Send the manifest using optiga_util_protected_update_start
+        */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_protected_update_start(me,
+                                                           0x01,
+                                                           manifest_rsa_key,
+                                                           sizeof(manifest_rsa_key));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_protected_update_start operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            // optiga_util_protected_update_start failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+
+        /**
+        *   Send the last fragment using optiga_util_protected_update_final
+        */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_protected_update_final(me,
+                                                            rsa_key_final_fragment_array,
+                                                            sizeof(rsa_key_final_fragment_array));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_protected_update_final operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            // optiga_util_protected_update_final failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+        return_status = OPTIGA_LIB_SUCCESS;
+    } while (FALSE);
+    
+
+    if (me)
+    {
+        //Destroy the instance after the completion of usecase if not required.
+        return_status = optiga_util_destroy(me);
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro
+            
+        }
+    }
+}
+
+static optiga_lib_status_t write_metadata(uint16_t oid, uint8_t * metadata, uint8_t metadata_length)
+{
+    optiga_lib_status_t return_status = OPTIGA_LIB_SUCCESS;
+    optiga_util_t * me = NULL;
+
+    do
+    {
+        me = optiga_util_create(0, optiga_util_callback, NULL);
+        if (NULL == me)
+        {
+            break;
+        }
+
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_write_metadata(me,
+                                                   oid,
+                                                   metadata,
+                                                   metadata_length);
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_metadata operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing metadata to a data object failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+    } while (FALSE);
+    if (me)
+    {
+        //Destroy the instance
+        return_status = optiga_util_destroy(me);
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro
+            
+        }
+    }
+
+    return(return_status);
+}
+
+static optiga_lib_status_t write_trust_anchor(uint16_t trust_anchor_oid)
+{
+    optiga_lib_status_t return_status = OPTIGA_LIB_SUCCESS;
+    optiga_util_t * me = NULL;
+
+    do
+    {
+        me = optiga_util_create(0, optiga_util_callback, NULL);
+        if (NULL == me)
+        {
+            break;
+        }
+
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_write_data(me,
+                                               trust_anchor_oid,
+                                               OPTIGA_UTIL_ERASE_AND_WRITE,
+                                               0,
+                                               trust_anchor,
+                                               sizeof(trust_anchor));
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+            //Wait until the optiga_util_write_data operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+            //writing data to a data object failed.
+            return_status = optiga_lib_status;
+            break;
+        }
+    } while (FALSE);
+    if (me)
+    {
+        //Destroy the instance
+        return_status = optiga_util_destroy(me);
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro  
+        }
+    }
+    return(return_status);
+
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/usecases/example_optiga_hibernate_restore.c b/3rdparty/experimental/optiga/examples/optiga/usecases/example_optiga_hibernate_restore.c
new file mode 100644
index 000000000..ebfc91113
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/usecases/example_optiga_hibernate_restore.c
@@ -0,0 +1,254 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file example_optiga_hibernate_restore.c
+*
+* \brief   This file provides an example for hibernate and restore functionalities
+*
+* \ingroup grUseCases
+*
+* @{
+*/
+
+#include "optiga/optiga_util.h"
+#include "optiga/optiga_crypt.h"
+#include "optiga/pal/pal_os_timer.h"
+#include "optiga_example.h"
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION 
+//lint --e{526} suppress "the function is defined in example_pair_host_and_optiga_using_pre_shared_secret source file"
+void example_pair_host_and_optiga_using_pre_shared_secret(void);
+#endif
+/**
+ * Callback when optiga_util_xxxx operation is completed asynchronously
+ */
+static volatile optiga_lib_status_t optiga_lib_status;
+//lint --e{818} suppress "argument "context" is not used in the sample provided"
+static void optiga_lib_callback(void * context, optiga_lib_status_t return_status)
+{
+    optiga_lib_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+static const uint8_t label [] = "Firmware update";
+
+static const uint8_t random_seed [] = {
+    0x61, 0xC7, 0xDE, 0xF9, 0x0F, 0xD5, 0xCD, 0x7A,
+    0x8B, 0x7A, 0x36, 0x41, 0x04, 0xE0, 0x0D, 0x82,
+    0x38, 0x46, 0xBF, 0xB7, 0x70, 0xEE, 0xBF, 0x8F,
+    0x40, 0x25, 0x2E, 0x0A, 0x21, 0x42, 0xAF, 0x9C,
+};
+/**
+ * The below example demonstrates hibernate and restore functionalities
+ *
+ * Example for #optiga_util_open_application and #optiga_util_close_application
+ *
+ */
+void example_optiga_util_hibernate_restore(void)
+{
+    optiga_util_t * me_util = NULL;
+    optiga_crypt_t * me_crypt = NULL;
+    uint16_t bytes_to_read = 1;
+    optiga_lib_status_t return_status = !OPTIGA_LIB_SUCCESS;
+    uint8_t security_event_counter = 0;
+    const uint8_t optional_data[2] = {0x01, 0x02};
+    uint16_t optional_data_length = sizeof(optional_data);
+    uint8_t decryption_key [16] = {0};
+    uint8_t decryption_key_cmp [16] = {0};
+
+    OPTIGA_EXAMPLE_LOG_MESSAGE("Begin demonstrating hibernate feature...\n");    
+    OPTIGA_EXAMPLE_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+        //Create an instance of optiga_util and optiga_crypt
+        me_util = optiga_util_create(0, optiga_lib_callback, NULL);
+        if (NULL == me_util)
+        {
+            break;
+        }
+
+        me_crypt = optiga_crypt_create(0, optiga_lib_callback, NULL);
+        if (NULL == me_crypt)
+        {
+            break;
+        }
+
+        /**
+         * 1. Open the application on OPTIGA which is a pre-condition to perform any other operations
+         *    using optiga_util_open_application
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_open_application(me_util, 0);
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION 
+        /**
+         * 2. Pairing the Host and OPTIGA using a pre-shared secret
+         */
+        example_pair_host_and_optiga_using_pre_shared_secret();
+#endif        
+
+        /**
+         * 3. Generate 48 byte RSA Pre master secret in acquired session OID
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_crypt_rsa_generate_pre_master_secret(me_crypt,
+                                                                    optional_data,
+                                                                    optional_data_length,
+                                                                    48);
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+        /**
+         * 4. Derive key (e.g. decryption key) using optiga_crypt_tls_prf_sha256 with protected I2C communication.
+         *       - Use shared secret from session OID data object
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+
+        OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL(me_crypt, OPTIGA_COMMS_COMMAND_PROTECTION);
+        OPTIGA_CRYPT_SET_COMMS_PROTOCOL_VERSION(me_crypt, OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET);
+        return_status = optiga_crypt_tls_prf_sha256(me_crypt,
+                                                    (uint16_t)OPTIGA_KEY_ID_SESSION_BASED, /* Input secret OID */
+                                                    label,
+                                                    sizeof(label),
+                                                    random_seed,
+                                                    sizeof(random_seed),
+                                                    sizeof(decryption_key),
+                                                    TRUE,
+                                                    decryption_key);
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+        /**
+         * - The subsequent steps will hibernate OPTIGA and save the session and optiga comms related information in OPTIGA .
+         * - The session and optiga comms related information are then restored back and crypto operation are performed using these information.
+         */
+
+        /**
+         * 5. To perform the hibernate, Security Event Counter(SEC) must be 0.
+         *    Read SEC data object (0xE0C5) and wait until SEC = 0
+         */
+        do
+        {
+            optiga_lib_status = OPTIGA_LIB_BUSY;
+            return_status = optiga_util_read_data(me_util,
+                                                  0xE0C5,
+                                                  0x0000,
+                                                  &security_event_counter,
+                                                  &bytes_to_read);
+
+            WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+            pal_os_timer_delay_in_milliseconds(1000);
+        } while (0 != security_event_counter);
+
+        /**
+         * 6. Hibernate the application on OPTIGA
+         *    using optiga_util_close_application with perform_hibernate parameter as true
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_close_application(me_util, 1);
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+
+        /**
+         * 7. Restore the application on OPTIGA
+         *    using optiga_util_open_application with perform_restore parameter as true
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_open_application(me_util, 1);
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+
+        /**
+         * 8. Derive key (e.g. decryption key) using optiga_crypt_tls_prf_sha256 with protected I2C communication.
+         *       - Use shared secret from session OID data object
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+
+        OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL(me_crypt, OPTIGA_COMMS_COMMAND_PROTECTION);
+        OPTIGA_CRYPT_SET_COMMS_PROTOCOL_VERSION(me_crypt, OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET);
+        return_status = optiga_crypt_tls_prf_sha256(me_crypt,
+                                                    (uint16_t)OPTIGA_KEY_ID_SESSION_BASED, /* Input secret OID */
+                                                    label,
+                                                    sizeof(label),
+                                                    random_seed,
+                                                    sizeof(random_seed),
+                                                    sizeof(decryption_key_cmp),
+                                                    TRUE,
+                                                    decryption_key_cmp);
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+                                                    
+        /**
+         * 9. Compare the output of the Derive key to validate the secret was stored while hibernate option.
+         *       - Use shared secret from session OID data object
+         */
+        return_status = (optiga_lib_status_t)memcmp(decryption_key_cmp,decryption_key,sizeof(decryption_key_cmp));
+        if (0 != return_status)
+        {
+            break;
+        }
+        /**
+         * 10. Close the application on OPTIGA without hibernating
+         *    using optiga_util_close_application
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_close_application(me_util, 0);
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+        return_status = OPTIGA_LIB_SUCCESS;
+        OPTIGA_EXAMPLE_LOG_MESSAGE("Hibernate feature demonstration completed...\n");
+    } while (FALSE);
+    OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+
+    if (me_util)
+    {
+        //Destroy the instance after the completion of usecase if not required.
+        return_status = optiga_util_destroy(me_util);
+        if(OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro
+            OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+        }
+    }
+
+    if (me_crypt)
+    {
+        //Destroy the instance after the completion of usecase if not required.
+        return_status = optiga_crypt_destroy(me_crypt);
+        if(OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro
+            OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+        }
+    }
+}
+
+/**
+ * @}
+ */
diff --git a/3rdparty/experimental/optiga/examples/optiga/usecases/example_pair_host_and_optiga_using_pre_shared_secret.c b/3rdparty/experimental/optiga/examples/optiga/usecases/example_pair_host_and_optiga_using_pre_shared_secret.c
new file mode 100644
index 000000000..d482c29ae
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/usecases/example_pair_host_and_optiga_using_pre_shared_secret.c
@@ -0,0 +1,265 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file example_pair_host_and_optiga_using_pre_shared_secret.c
+*
+* \brief   This file provides an example for pairing the Host and OPTIGA using a preshared secret.
+*
+* \ingroup grUseCases
+*
+* @{
+*/
+
+#include "optiga/optiga_util.h"
+#include "optiga/optiga_crypt.h"
+
+#include "optiga/pal/pal_os_datastore.h"
+#include "optiga_example.h"
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION 
+// Value of Operational state
+#define LCSO_STATE_CREATION       (0x01)
+// Value of Operational state
+#define LCSO_STATE_OPERATIONAL    (0x07)
+
+//Currently set to Creation state(defualt value). At the real time/customer side this needs to be LCSO_STATE_OPERATIONAL (0x07)
+#define FINAL_LCSO_STATE          (LCSO_STATE_CREATION)
+
+/* Platform Binding Shared Secret (0xE140) Metadata to be updated */
+
+const uint8_t platform_binding_shared_secret_metadata_final [] = {
+    //Metadata to be updated
+    0x20, 0x17,
+        // LcsO
+        0xC0, 0x01,
+                    FINAL_LCSO_STATE,       // Refer Macro to see the value or some more notes
+        // Change/Write Access tag
+        0xD0, 0x07,
+                    // This allows updating the binding secret during the runtime using shielded connection
+                    // If not required to update the secret over the runtime, set this to NEV and
+                    // update Metadata length accordingly
+                    0xE1, 0xFC, LCSO_STATE_OPERATIONAL,   // LcsO < Operational state
+                    0xFE,
+                    0x20, 0xE1, 0x40,
+        // Read Access tag
+        0xD1, 0x03,
+                    0xE1, 0xFC, LCSO_STATE_OPERATIONAL,   // LcsO < Operational state
+        // Execute Access tag
+        0xD3, 0x01,
+                    0x00,   // Always
+        // Data object Type
+        0xE8, 0x01,
+                    0x22,   // Platform binding secret type
+};
+
+/**
+ * Callback when optiga_util_xxxx/optiga_crypt_xxxx operation is completed asynchronously
+ */
+static volatile optiga_lib_status_t optiga_lib_status;
+//lint --e{818} suppress "argument "context" is not used in the sample provided"
+static void optiga_lib_callback(void * context, optiga_lib_status_t return_status)
+{
+    optiga_lib_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+/**
+ * The below example demonstrates pairing the Host and OPTIGA using a preshared secret for the first time.
+ *
+ * Note:
+ *   1) If the below example is executed once, the LcsO of Platform Binding shared secret is set to Initialization.
+ *      The LcsO can't be reverted to previous states.
+ *
+ *      Please ensure the access conditions and other required settings in the metadata must be accordingly
+ *      before setting the LcsO to Initialization state.
+ *
+ *   2) The metadata gets written in this example is just an example. The user must update this to the respective
+ *      needs including LcsO state and access conditions
+ *
+ * Preconditions: The optiga_util_open_application must be executed before invoking the below example.
+ *
+ */
+void example_pair_host_and_optiga_using_pre_shared_secret(void)
+{
+    uint16_t bytes_to_read;
+    uint8_t platform_binding_secret[64];
+    uint8_t platform_binding_secret_metadata[44];
+    optiga_lib_status_t return_status = !OPTIGA_LIB_SUCCESS;
+    pal_status_t pal_return_status;
+    optiga_util_t * me_util = NULL;
+    optiga_crypt_t * me_crypt = NULL;
+
+    OPTIGA_EXAMPLE_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+        /**
+         * 1. Create OPTIGA Util and Crypt Instances
+         */
+        me_util = optiga_util_create(0, optiga_lib_callback, NULL);
+        if (NULL == me_util)
+        {
+            break;
+        }
+
+        me_crypt = optiga_crypt_create(0, optiga_lib_callback, NULL);
+        if (NULL == me_crypt)
+        {
+            break;
+        }
+
+        /**
+         * 2. Initialize the protection level and protocol version for the instances
+         */
+        OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL(me_util,OPTIGA_COMMS_NO_PROTECTION);
+        OPTIGA_UTIL_SET_COMMS_PROTOCOL_VERSION(me_util,OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET);
+
+        OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL(me_crypt,OPTIGA_COMMS_NO_PROTECTION);
+        OPTIGA_CRYPT_SET_COMMS_PROTOCOL_VERSION(me_crypt,OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET);
+
+        /**
+         * 3. Read Platform Binding Shared secret (0xE140) data object metadata from OPTIGA
+         *    using optiga_util_read_metadata.
+         */
+        bytes_to_read = sizeof(platform_binding_secret_metadata);
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_read_metadata(me_util,
+                                                  0xE140,
+                                                  platform_binding_secret_metadata,
+                                                  &bytes_to_read);
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+
+        /**
+         * 4. Validate LcsO in the metadata.
+         *    Skip the rest of the procedure if LcsO is greater than or equal to operational state(0x07)
+         */
+        if (platform_binding_secret_metadata[4] >= LCSO_STATE_OPERATIONAL)
+        {
+            // The LcsO is already greater than or equal to operational state
+            break;
+        }
+
+        /**
+         * 5. Generate Random using optiga_crypt_random
+         *       - Specify the Random type as TRNG
+         *    a. The maximum supported size of secret is 64 bytes.
+         *       The minimum recommended is 32 bytes.
+         *    b. If the host platform doesn't support random generation,
+         *       use OPTIGA to generate the maximum size chosen.
+         *       else choose the appropriate length of random to be generated by OPTIGA
+         *
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_crypt_random(me_crypt,
+                                            OPTIGA_RNG_TYPE_TRNG,
+                                            platform_binding_secret,
+                                            sizeof(platform_binding_secret));
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+
+        /**
+         * 6. Generate random on Host
+         *    If the host platform doesn't support, skip this step
+         */
+
+
+        /**
+         * 7. Write random(secret) to OPTIGA platform Binding shared secret data object (0xE140)
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL(me_util,OPTIGA_COMMS_NO_PROTECTION);
+        return_status = optiga_util_write_data(me_util,
+                                               0xE140,
+                                               OPTIGA_UTIL_ERASE_AND_WRITE,
+                                               0,
+                                               platform_binding_secret,
+                                               sizeof(platform_binding_secret));
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+
+        /**
+         * 8. Write/store the random(secret) on the Host platform
+         *
+         */
+        pal_return_status = pal_os_datastore_write(OPTIGA_PLATFORM_BINDING_SHARED_SECRET_ID,
+                                                   platform_binding_secret,
+                                                   sizeof(platform_binding_secret));
+
+        if (PAL_STATUS_SUCCESS != pal_return_status)
+        {
+            //Storing of Pre-shared secret on Host failed.
+            optiga_lib_status = pal_return_status;
+            break;
+        }
+
+
+
+        /**
+         * 9. Update metadata of OPTIGA Platform Binding shared secret data object (0xE140)
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL(me_util,OPTIGA_COMMS_NO_PROTECTION);
+        return_status = optiga_util_write_metadata(me_util,
+                                                   0xE140,
+                                                   platform_binding_shared_secret_metadata_final,
+                                                   sizeof(platform_binding_shared_secret_metadata_final));
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+
+        return_status = OPTIGA_LIB_SUCCESS;
+
+    } while(FALSE);
+    OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+    
+    if(me_util)
+    {
+        //Destroy the instance after the completion of usecase if not required.
+        return_status = optiga_util_destroy(me_util);
+        if(OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro
+            OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+        }
+    }
+    if(me_crypt)
+    {
+        //Destroy the instance after the completion of usecase if not required.
+        return_status = optiga_crypt_destroy(me_crypt);
+        if(OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro
+            OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+        }
+    }
+    
+}
+#endif
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga/usecases/example_read_coprocessor_id.c b/3rdparty/experimental/optiga/examples/optiga/usecases/example_read_coprocessor_id.c
new file mode 100644
index 000000000..8bf6e48f5
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga/usecases/example_read_coprocessor_id.c
@@ -0,0 +1,228 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file example_read_coprocessor_id.c
+*
+* \brief   This file provides an example for reading the Coprocessor ID and displaying it's fields.
+*
+* \ingroup grUseCases
+*
+* @{
+*/
+
+#include "optiga/optiga_util.h"
+#include "optiga_example.h"
+#include "optiga/pal/pal_logger.h"
+#include "optiga/pal/pal_os_memory.h"
+
+extern pal_logger_t logger_console;
+
+/**
+ * Callback when optiga_util_xxxx operation is completed asynchronously
+ */
+static volatile optiga_lib_status_t optiga_lib_status;
+//lint --e{818} suppress "argument "context" is not used in the sample provided"
+static void optiga_lib_callback(void * context, optiga_lib_status_t return_status)
+{
+    optiga_lib_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+#if defined (OPTIGA_LIB_ENABLE_EXAMPLE_LOGGING)
+/*Convert Byte to HexString */
+#define OPTIGA_LOGGER_CONVERT_BYTE_TO_HEX(hex_byte, p_hex_string, index) \
+{ \
+    uint8_t nibble;                       \
+    nibble = (hex_byte & 0xF0)>>4;         \
+    p_hex_string [index++] = ((nibble > 0x09)) ? (nibble + 0x37) : (nibble + 0x30); \
+    nibble = hex_byte & 0x0F;         \
+    p_hex_string [index++] = ((nibble > 0x09)) ? (nibble + 0x37) : (nibble + 0x30); \
+}
+
+/* Converts the uint8 array to hex string format */
+static void optiga_lib_byte_to_hex_string(const uint8_t * p_array_buffer,
+                                             uint8_t * p_hex_string,
+                                             uint32_t length,
+                                             bool_t is_input_byte_array)
+{
+    uint32_t loop = 0;
+    uint8_t hex_byte = 0, index = 0;
+
+    do
+    {
+        if ((NULL == p_array_buffer) || (NULL == p_hex_string))
+        {
+            return;
+        }
+
+        for (loop = 0; loop < length; loop++)
+        {
+            index = 0;
+            hex_byte = p_array_buffer[loop];
+            if (TRUE == is_input_byte_array)
+            {
+                p_hex_string [index++] = '0';
+                p_hex_string [index++] = 'x';
+            }
+
+            /*Convert Byte to HexString */
+            OPTIGA_LOGGER_CONVERT_BYTE_TO_HEX(hex_byte,p_hex_string, index);
+            
+            p_hex_string [index++] = ' ';
+            p_hex_string += index;
+        }
+        *p_hex_string = 0x00;
+    } while(0);
+}
+
+static void optiga_lib_print_coprocessor_data(const uint8_t * p_log_string,
+                                              uint16_t length,
+                                              const char_t * p_log_color)
+{
+    uint8_t temp_buffer[100];
+    char_t output_buffer[100];
+    uint16_t index;
+    uint16_t temp_length;
+    uint8_t new_line_characters[2] = {0x0D, 0x0A};
+    uint8_t buffer_window = 32; // Alignment of 16 bytes per line
+    
+    //Logging the arrays in chunks of 16 bytes through chaining
+    for (index = 0; index < length; index+=buffer_window)
+    {
+        temp_length = buffer_window;
+        if ((length - index) < buffer_window)
+        {
+            temp_length =  length - index;
+        }
+
+        pal_os_memset(temp_buffer, 0x00, sizeof(temp_buffer));
+        pal_os_memset(output_buffer, 0x00, sizeof(output_buffer));
+
+        optiga_lib_byte_to_hex_string((uint8_t*)(p_log_string + index), temp_buffer, temp_length, FALSE);
+
+        sprintf((char_t *)output_buffer, "%s%s%s", p_log_color, temp_buffer, OPTIGA_LIB_LOGGER_COLOR_DEFAULT);
+
+        // New line characted entered at the end of each segment
+        output_buffer[strlen(output_buffer)] = (char_t)new_line_characters[0];
+        output_buffer[strlen(output_buffer)+1] = (char_t)new_line_characters[1];
+        //lint --e{534} The return value is not used hence not checked*/
+        pal_logger_write(&logger_console, (const uint8_t *)output_buffer, strlen(output_buffer) + 2);
+    }
+}
+
+static void optiga_lib_print_coprocessor_components(const char_t * p_log_string,
+                                                    const uint8_t * p_log_array,
+                                                    uint16_t length)
+{
+    char_t color_buffer[100];
+
+    OPTIGA_LIB_LOGGER_PRINT_INFO(color_buffer, p_log_string, OPTIGA_EXAMPLE, OPTIGA_EXAMPLE_COLOR);
+    //lint --e{534} The return value is not used hence not checked*/
+    pal_logger_write(&logger_console, (const uint8_t *)color_buffer, strlen(color_buffer));
+    optiga_lib_print_coprocessor_data(p_log_array, length, OPTIGA_EXAMPLE_COLOR);
+}
+
+#define OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO(msg, array, length) \
+                                               optiga_lib_print_coprocessor_components(msg, array, length)
+#else
+#define OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO(msg, array, length)
+#endif
+
+/**
+ * The below example demonstrates reading of Coprocessor ID and displaying it's individual components.
+ *
+ * Preconditions: The optiga_util_open_application must be executed before invoking the below example.
+ *
+ */
+void example_read_coprocessor_id(void)
+{
+    uint16_t bytes_to_read;
+    uint8_t coprocessor_uid[32];
+    optiga_lib_status_t return_status = !OPTIGA_LIB_SUCCESS;
+    optiga_util_t * me_util = NULL;
+
+    OPTIGA_EXAMPLE_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+        /**
+         * 1. Create OPTIGA Util Instance
+         */
+        me_util = optiga_util_create(0, optiga_lib_callback, NULL);
+        if (NULL == me_util)
+        {
+            break;
+        }
+
+        /**
+         * 2. Read Coprocessor UID (0xE0C2) data object from OPTIGA
+         *    using optiga_util_read_data.
+         */
+        bytes_to_read = sizeof(coprocessor_uid);
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_read_data(me_util,
+                                              0xE0C2,
+                                              0x0000,
+                                              coprocessor_uid,
+                                              &bytes_to_read);
+
+        WAIT_AND_CHECK_STATUS(return_status, optiga_lib_status);
+        return_status = OPTIGA_LIB_SUCCESS;
+        OPTIGA_EXAMPLE_LOG_MESSAGE("Coprocessor UID components are mentioned below:\n");
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("CIM Identifier                       : ", &coprocessor_uid[0], 0x01);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("Platform Identifier                  : ", &coprocessor_uid[1], 0x01);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("Model Identifier                     : ", &coprocessor_uid[2], 0x01);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("ROM mask ID                          : ", &coprocessor_uid[3], 0x02);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("Chip type                            : ", &coprocessor_uid[5], 0x06);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("Batch number                         : ", &coprocessor_uid[11], 0x06);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("Chip position on wafer: X-coordinate : ", &coprocessor_uid[17], 0x02);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("Chip position on wafer: Y-coordinate : ", &coprocessor_uid[19], 0x02);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("Firmware Identifier                  : ", &coprocessor_uid[21], 0x04);
+        OPTIGA_EXAMPLE_LOG_COPROCESSOR_ID_INFO("ESW build number, BCD coded          : ", &coprocessor_uid[25], 0x02);
+        optiga_lib_print_string_with_newline("");
+    } while(FALSE);
+    OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+    
+    if(me_util)
+    {
+        //Destroy the instance after the completion of usecase if not required.
+        return_status = optiga_util_destroy(me_util);
+        if(OPTIGA_LIB_SUCCESS != return_status)
+        {
+            //lint --e{774} suppress This is a generic macro
+            OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+        }
+    }
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/optiga_shell.c b/3rdparty/experimental/optiga/examples/optiga_shell.c
new file mode 100644
index 000000000..6a6f1247d
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/optiga_shell.c
@@ -0,0 +1,743 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_shell.c
+*
+* \brief   This file provides the shell prompt implementation.
+*
+* \ingroup grOptigaExamples
+*
+* @{
+*/
+
+#include <DAVE.h>
+#include "optiga/optiga_crypt.h"
+#include "optiga/optiga_util.h"
+#include "optiga/common/optiga_lib_logger.h"
+#include "optiga/pal/pal_os_event.h"
+#include "optiga/pal/pal.h"
+#include "optiga/pal/pal_os_timer.h"
+#include "optiga_example.h"
+#include "optiga/pal/pal_logger.h"
+
+#define OPTIGA_SHELL_MODULE "[optiga shell]  : "
+#define OPTIGA_SHELL_LOG_MESSAGE(msg) \
+                            optiga_lib_print_message(msg, OPTIGA_SHELL_MODULE, OPTIGA_LIB_LOGGER_COLOR_LIGHT_GREEN);
+                            
+#define OPTIGA_SHELL_LOG_ERROR_MESSAGE(msg) \
+                            optiga_lib_print_message(msg, OPTIGA_SHELL_MODULE, OPTIGA_LIB_LOGGER_COLOR_YELLOW);
+
+extern void example_optiga_crypt_hash (void);
+extern void example_optiga_crypt_random(void);
+extern void example_optiga_crypt_tls_prf_sha256(void);
+extern void example_optiga_util_read_data(void);
+extern void example_optiga_util_write_data(void);
+extern void example_optiga_crypt_rsa_generate_keypair(void);
+extern void example_optiga_crypt_rsa_sign(void);
+extern void example_optiga_crypt_rsa_verify(void);
+extern void example_optiga_crypt_rsa_decrypt_and_export(void);
+extern void example_optiga_crypt_rsa_decrypt_and_store(void);
+extern void example_optiga_crypt_rsa_encrypt_message(void);
+extern void example_optiga_crypt_rsa_encrypt_session(void);
+extern void example_optiga_util_update_count(void);
+extern void example_optiga_util_protected_update(void);
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION 
+extern void example_pair_host_and_optiga_using_pre_shared_secret(void);
+#endif
+extern void example_optiga_util_hibernate_restore(void);
+extern void example_optiga_crypt_symmetric_encrypt_decrypt_ecb(void);
+extern void example_optiga_crypt_symmetric_encrypt_decrypt_cbc(void);
+extern void example_optiga_crypt_symmetric_encrypt_cbcmac(void);
+extern void example_optiga_crypt_hmac(void);
+extern void example_optiga_crypt_hkdf(void);
+extern void example_optiga_crypt_symmetric_generate_key(void);
+extern void example_optiga_hmac_verify_with_authorization_reference(void);
+extern void example_optiga_crypt_clear_auto_state(void);
+extern void example_read_coprocessor_id(void);
+extern void example_optiga_crypt_hash_data(void);
+
+extern pal_logger_t logger_console;
+/**
+ * Callback when optiga_util_xxxx operation is completed asynchronously
+ */
+static volatile optiga_lib_status_t optiga_lib_status;
+//lint --e{818,715} suppress "argument "context" is not used in the sample provided"
+static void optiga_util_callback(void * context, optiga_lib_status_t return_status)
+{
+    optiga_lib_status = return_status;
+}
+
+optiga_util_t * me_util = NULL;
+
+typedef struct optiga_example_cmd
+{
+    const char_t * cmd_description;
+    const char_t * cmd_options;
+    void (*cmd_handler)(void);
+}optiga_example_cmd_t;
+
+static void optiga_shell_init(void)
+{
+    optiga_lib_status_t return_status = !OPTIGA_LIB_SUCCESS;
+    uint16_t optiga_oid = 0xE0C4;
+    uint8_t required_current[] = {0x0F};
+
+    do
+    {
+        //Create an instance of optiga_util to open the application on OPTIGA.
+        me_util = optiga_util_create(0, optiga_util_callback, NULL);
+
+        OPTIGA_EXAMPLE_LOG_MESSAGE("Initializing OPTIGA for example demonstration...\n");
+        /**
+         * Open the application on OPTIGA which is a precondition to perform any other operations
+         * using optiga_util_open_application
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_open_application(me_util, 0);
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+        while (optiga_lib_status == OPTIGA_LIB_BUSY)
+        {
+            //Wait until the optiga_util_open_application is completed
+        }
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+        	return_status = optiga_lib_status;
+            //optiga util open application failed
+            break;
+        }
+
+        OPTIGA_SHELL_LOG_MESSAGE("Initializing OPTIGA completed...\n\n");
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION 
+        OPTIGA_SHELL_LOG_MESSAGE("Begin pairing of host and OPTIGA...");
+        // Usercase: Generate the pre-shared secret on host and write it to OPTIGA
+        example_pair_host_and_optiga_using_pre_shared_secret();
+        OPTIGA_SHELL_LOG_MESSAGE("Pairing of host and OPTIGA completed...");
+#endif
+        // Usercase: Generate the pre-shared secret on host and write it to OPTIGA
+        return_status = optiga_util_write_data(me_util,
+                                               optiga_oid,
+                                               OPTIGA_UTIL_ERASE_AND_WRITE,
+                                               0,
+                                               required_current,
+                                               1);
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == optiga_lib_status)
+        {
+        	return_status = optiga_lib_status;
+            //Wait until the optiga_util_write_data operation is completed
+        }
+        OPTIGA_SHELL_LOG_MESSAGE("Setting current limitation to maximum...");
+        OPTIGA_SHELL_LOG_MESSAGE("Starting OPTIGA example demonstration..\n");
+    }while(FALSE);
+    OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+}
+
+static void optiga_shell_deinit(void)
+{
+    optiga_lib_status_t return_status = !OPTIGA_LIB_SUCCESS;;
+    do
+    {
+        OPTIGA_EXAMPLE_LOG_MESSAGE("Deinitializing OPTIGA for example demonstration...\n");
+        /**
+         * Close the application on OPTIGA after all the operations are executed
+         * using optiga_util_close_application
+         */
+        optiga_lib_status = OPTIGA_LIB_BUSY;
+        return_status = optiga_util_close_application(me_util, 0);
+
+        if (OPTIGA_LIB_SUCCESS != return_status)
+        {
+            break;
+        }
+
+        while (optiga_lib_status == OPTIGA_LIB_BUSY)
+        {
+            //Wait until the optiga_util_close_application is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != optiga_lib_status)
+        {
+        	return_status = optiga_lib_status;
+            //optiga util close application failed
+            break;
+        }
+
+        // destroy util and crypt instances
+        //lint --e{534} suppress "Error handling is not required so return value is not checked"
+        optiga_util_destroy(me_util);
+    }while(FALSE);
+    OPTIGA_EXAMPLE_LOG_STATUS(return_status);
+}
+
+static void optiga_shell_util_read_data(void)
+{
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Read Data/Metadata Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Read Certificate ");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Read Certificate Metadata");
+    example_optiga_util_read_data();
+}
+
+static void optiga_shell_util_write_data(void)
+{
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Write Data/Metadata Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Write Sample Certificate in Trust Anchor Data Object ");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Write new Metadata");
+    example_optiga_util_write_data();
+}
+
+static void optiga_shell_util_read_coprocessor_id(void)
+{
+    OPTIGA_SHELL_LOG_MESSAGE("Starting reading of Coprocessor ID and displaying it's individual components Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Read Coprocessor UID from OID(0xE0C2) ");
+    example_read_coprocessor_id();
+}
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION 
+static void optiga_shell_pair_host_optiga(void)
+{
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Pairing of Host and Trust M Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Read and Check existing Metadata for the Binding Secret");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Generate Random for the new Binding Secret");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Write new Binding Secret");
+    OPTIGA_SHELL_LOG_MESSAGE("4 Step: Store new Binding Secret on the Host");
+    example_pair_host_and_optiga_using_pre_shared_secret();
+}
+#endif
+static void optiga_shell_util_hibernate_restore(void)
+{
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Hibernate and Restore Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Open Application on the security chip");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Pair the host and the security chip if shielded connection is enable");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Select Protected I2C Connection if shielded connection is enable");
+    OPTIGA_SHELL_LOG_MESSAGE("4 Step: Generate 48 byte RSA Pre master secret in acquired session OID");
+    OPTIGA_SHELL_LOG_MESSAGE("5 Step: Derive key (e.g. decryption key) using optiga_crypt_tls_prf_sha256 with secret from session as OID data object");
+    OPTIGA_SHELL_LOG_MESSAGE("6 Step: Check Security Event Counter and wait till it reaches 0");
+    OPTIGA_SHELL_LOG_MESSAGE("7 Step: Perform Close application with Hibernate parameter set to True");
+    OPTIGA_SHELL_LOG_MESSAGE("8 Step: Open Application on the security chip");
+    OPTIGA_SHELL_LOG_MESSAGE("9 Step: Derive key (e.g. decryption key) using optiga_crypt_tls_prf_sha256 with secret from session as OID data object");
+    OPTIGA_SHELL_LOG_MESSAGE("10 Step: Close Applicaiton on the chip");
+    OPTIGA_SHELL_LOG_MESSAGE("Important note: To continue with other examples you need to call the init parameter once again");
+    example_optiga_util_hibernate_restore();
+}
+
+static void optiga_shell_util_update_count(void)
+{
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Update Counter Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Write Initial Counter Value");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Increase Counter Object");
+    example_optiga_util_update_count();
+}
+
+static void optiga_shell_util_protected_update(void)
+{
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Protected Update Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Update Metadata for the Object to be updated and the Trust Anchor used to verify the update");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Write Trust Anchor used by the Trust M to verify the update");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Start Protected update with prepared manifest and fragments");
+    example_optiga_util_protected_update();
+}
+
+static void optiga_shell_crypt_hash(void)
+{
+#ifdef OPTIGA_CRYPT_HASH_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Hash Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Hash given data with Start, Update and Finalize calls");
+    example_optiga_crypt_hash();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_HASH_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_hash_data(void)
+{
+#ifdef OPTIGA_CRYPT_HASH_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting generation of digest Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate hash of given user data ");
+    example_optiga_crypt_hash_data();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_HASH_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_tls_prf_sha256(void)
+{
+#ifdef OPTIGA_CRYPT_TLS_PRF_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting TLS PRF SHA256 (Key Deriviation) Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Write prepared Shared Secret into an Arbitrary Data Object");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Update Metadata of the Object to use the Arbitrary Data Object only via Shielded I2C Connection");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Generate Shared Secret using the Shared Secret from the Arbitrary Data Object");
+    OPTIGA_SHELL_LOG_MESSAGE("4 Step: Restore Metadata of the Arbitrary Data Object");
+    example_optiga_crypt_tls_prf_sha256();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_TLS_PRF_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_random(void)
+{
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Generate Random Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate 32 bytes random");
+    example_optiga_crypt_random();
+}
+
+static void optiga_shell_crypt_rsa_sign(void)
+{
+#ifdef OPTIGA_CRYPT_RSA_SIGN_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting signing example for PKCS#1 Ver1.5 SHA256 Signature scheme (RSA)");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Sign prepared Data and export the signature");
+    example_optiga_crypt_rsa_sign();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_RSA_SIGN_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_rsa_verify(void)
+{
+#ifdef OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting signing example for PKCS#1 Ver1.5 SHA256 Signature scheme (RSA)");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Verify prepared signature, with prepared public key and digest");
+    example_optiga_crypt_rsa_verify();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_RSA_VERIFY_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_generate_keypair(void)
+{
+#ifdef OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting generate RSA Key Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate RSA 1024 Key Pair and export the public key");
+    example_optiga_crypt_rsa_generate_keypair();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_rsa_decrypt_and_export(void)
+{
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Decrypt and Export Data with RSA Key Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate RSA 1024 Key Pair and export the public key");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Encrypt a message with RSAES PKCS#1 Ver1.5 Scheme");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Select Protected I2C Connection");
+    OPTIGA_SHELL_LOG_MESSAGE("4 Step: Decrypt the message with RSAES PKCS#1 Ver1.5 Scheme and export it");
+    example_optiga_crypt_rsa_decrypt_and_export();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_RSA_DECRYPT_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_rsa_decrypt_and_store(void)
+{
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Decrypt and Store Data on the chip with RSA Key Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate RSA 1024 Key Pair and export the public key");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Generate 70 bytes RSA Pre master secret which is stored in acquired session OID");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Select Protected I2C Connection");
+    OPTIGA_SHELL_LOG_MESSAGE("4 Step: Encrypt Session Data with RSA Public Key");
+    OPTIGA_SHELL_LOG_MESSAGE("5 Step: Decrypt the message with RSAES PKCS#1 Ver1.5 Scheme and store it on chip");
+    example_optiga_crypt_rsa_decrypt_and_store();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_RSA_DECRYPT_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_rsa_encrypt_message(void)
+{
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Encrypt Data with RSA Key Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Encrypt a message with RSAES PKCS#1 Ver1.5 Scheme");
+    example_optiga_crypt_rsa_encrypt_message();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_RSA_DECRYPT_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_rsa_encrypt_session(void)
+{
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting Encrypt Data in Session Object on chip with RSA Key Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Encrypt a message with RSAES PKCS#1 Ver1.5 Scheme stored on chip in Session Object");
+    example_optiga_crypt_rsa_encrypt_session();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_RSA_DECRYPT_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_symmetric_encrypt_decrypt_ecb(void)
+{
+#if defined (OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) && defined (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED)
+    OPTIGA_SHELL_LOG_MESSAGE("Starting symmetric Encrypt and Decrypt Data for ECB mode Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate and store the AES 128 Symmetric key in OPTIGA Key store OID(E200)");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Encrypt the plain data with ECB mode");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Decrypt the encrypted data from step 2");
+    example_optiga_crypt_symmetric_encrypt_decrypt_ecb();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED and OPTIGA_CRYPT_SYM_DECRYPT_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_symmetric_encrypt_decrypt_cbc(void)
+{
+#if defined (OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) && defined (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED)
+    OPTIGA_SHELL_LOG_MESSAGE("Starting symmetric Encrypt and Decrypt Data for CBC mode Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate and store the AES 128 Symmetric key in OPTIGA Key store OID(E200)");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Encrypt the plain data with CBC mode");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Decrypt the encrypted data from step 2");
+    example_optiga_crypt_symmetric_encrypt_decrypt_cbc();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED and OPTIGA_CRYPT_SYM_DECRYPT_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_symmetric_encrypt_cbcmac(void)
+{
+#if defined (OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) && defined (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED)
+    OPTIGA_SHELL_LOG_MESSAGE("Starting symmetric Encrypt Data for CBCMAC mode Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate and store the AES 128 Symmetric key in OPTIGA Key store OID(E200)");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Encrypt the plain data with CBCMAC mode");
+    example_optiga_crypt_symmetric_encrypt_cbcmac();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED and OPTIGA_CRYPT_SYM_DECRYPT_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_hmac(void)
+{
+#ifdef OPTIGA_CRYPT_HMAC_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting HMAC-SHA256 generation Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Change metadata for OID(0xF1D0) as Execute access condition = Always and Data object type  =  Pre-shared secret");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Generate HMAC");
+    example_optiga_crypt_hmac();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_HMAC_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_hkdf(void)
+{
+#ifdef OPTIGA_CRYPT_HKDF_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting HKDF-SHA256 key derivation Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Write the shared secret to the Arbitrary data object F1D0");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Change metadata of OID(0xF1D0) Data object type  =  Pre-shared secret");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Derive HKDF");
+    example_optiga_crypt_hkdf();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_HKDF_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_symmetric_generate_key(void)
+{
+#ifdef OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+    OPTIGA_SHELL_LOG_MESSAGE("Starting generation of symmetric AES-128 key");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Generate symmetric AES-128 key and store it in OID(E200)");
+    example_optiga_crypt_symmetric_generate_key();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_hmac_verify_with_authorization_reference(void)
+{
+#if defined (OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED) && defined (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED)
+    OPTIGA_SHELL_LOG_MESSAGE("Starting HMAC verify with authorization reference Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Get the User Secret and store it in OID(0xF1D0)");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Set the metadata of 0xF1E0 to Auto with 0xF1D0");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Generate authorization code with optional data");
+    OPTIGA_SHELL_LOG_MESSAGE("4 Step: Calculate HMAC on host using mbedtls");
+    OPTIGA_SHELL_LOG_MESSAGE("5 Step: Perform HMAC verification");
+    example_optiga_hmac_verify_with_authorization_reference();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED and OPTIGA_CRYPT_HMAC_VERIFY_ENABLED");
+#endif
+}
+
+static void optiga_shell_crypt_clear_auto_state(void)
+{
+#if defined (OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED) && defined (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED) && defined (OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED)
+    OPTIGA_SHELL_LOG_MESSAGE("Starting clear auto state Example");
+    OPTIGA_SHELL_LOG_MESSAGE("1 Step: Change metadata of OID(0xF1D0) Data object type  =  Pre-shared secret");
+    OPTIGA_SHELL_LOG_MESSAGE("2 Step: Get the User Secret and store it in OID(0xF1D0)");
+    OPTIGA_SHELL_LOG_MESSAGE("3 Step: Generate auth code with optional data");
+    OPTIGA_SHELL_LOG_MESSAGE("4 Step: Calculate HMAC on host using mbedtls");
+    OPTIGA_SHELL_LOG_MESSAGE("5 Step: Perform HMAC verification");
+    OPTIGA_SHELL_LOG_MESSAGE("6 Step: Perform clear auto state");
+    example_optiga_crypt_clear_auto_state();
+#else
+     OPTIGA_SHELL_LOG_ERROR_MESSAGE("This option is disabled, to use this option enable macro OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED, OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED and OPTIGA_CRYPT_HMAC_VERIFY_ENABLED");
+#endif
+}
+
+void print_performance_results(void (*test_case)(void)) 
+{
+    char buffer_string[30];
+    unsigned int timestamp = pal_os_timer_get_time_in_milliseconds(); 
+    test_case(); 
+    //lint --e{713} suppress "Due to function parameter typecasting is done from unsigned int to int "
+    sprintf(buffer_string, "Example takes %d msec", (int) (pal_os_timer_get_time_in_milliseconds() - timestamp));
+    OPTIGA_SHELL_LOG_MESSAGE(buffer_string); 
+    optiga_lib_print_string_with_newline(""); 
+    pal_os_timer_delay_in_milliseconds(2000);
+}
+
+static void optiga_shell_selftest(void)
+{
+    print_performance_results(optiga_shell_init);
+    print_performance_results(optiga_shell_util_read_data);
+    print_performance_results(optiga_shell_util_write_data);
+    print_performance_results(optiga_shell_util_read_coprocessor_id);
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION 
+    print_performance_results(optiga_shell_pair_host_optiga);
+#endif
+    print_performance_results(optiga_shell_util_update_count);
+    print_performance_results(optiga_shell_util_protected_update);
+
+    print_performance_results(optiga_shell_crypt_hash);
+    print_performance_results(optiga_shell_crypt_hash_data);
+    print_performance_results(optiga_shell_crypt_tls_prf_sha256);
+    print_performance_results(optiga_shell_crypt_random);
+
+    print_performance_results(optiga_shell_crypt_generate_keypair);
+    print_performance_results(optiga_shell_crypt_rsa_sign);
+    print_performance_results(optiga_shell_crypt_rsa_verify);
+    print_performance_results(optiga_shell_crypt_rsa_encrypt_message);
+    print_performance_results(optiga_shell_crypt_rsa_encrypt_session);
+    print_performance_results(optiga_shell_crypt_rsa_decrypt_and_store);
+    print_performance_results(optiga_shell_crypt_rsa_decrypt_and_export);
+    
+    print_performance_results(optiga_shell_crypt_symmetric_encrypt_decrypt_ecb);
+    print_performance_results(optiga_shell_crypt_symmetric_encrypt_decrypt_cbc);
+    print_performance_results(optiga_shell_crypt_symmetric_encrypt_cbcmac);
+    print_performance_results(optiga_shell_crypt_hmac);
+    print_performance_results(optiga_shell_crypt_symmetric_generate_key);
+    print_performance_results(optiga_shell_crypt_clear_auto_state);
+    print_performance_results(optiga_shell_crypt_hmac_verify_with_authorization_reference);
+}
+
+
+static void optiga_shell_show_usage(void);
+
+
+optiga_example_cmd_t optiga_cmds [] =
+{
+        {"",                                            "help",            optiga_shell_show_usage},
+        {"    initialize optiga                        : optiga --","init",            optiga_shell_init},
+        {"    de-initialize optiga                     : optiga --","deinit",          optiga_shell_deinit},
+        {"    run all tests at once                    : optiga --","selftest",        optiga_shell_selftest},
+        {"    read data                                : optiga --","readdata",        optiga_shell_util_read_data},
+        {"    write data                               : optiga --","writedata",       optiga_shell_util_write_data},
+        {"    read coprocessor id                      : optiga --","coprocid",        optiga_shell_util_read_coprocessor_id},
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION 
+        {"    binding host with optiga                 : optiga --","bind",            optiga_shell_pair_host_optiga},
+#endif
+        {"    hibernate and restore                    : optiga --","hibernate",       optiga_shell_util_hibernate_restore},
+        {"    update counter                           : optiga --","counter",         optiga_shell_util_update_count},
+        {"    protected update                         : optiga --","protected",       optiga_shell_util_protected_update},
+
+        {"    hashing of data                          : optiga --","hash",            optiga_shell_crypt_hash},
+        {"    hash single function                     : optiga --","hashsha256",      optiga_shell_crypt_hash_data},
+        {"    tls prf sha256                           : optiga --","prf",             optiga_shell_crypt_tls_prf_sha256},
+        {"    random number generation                 : optiga --","random",          optiga_shell_crypt_random},
+
+        {"    rsa key pair generation                  : optiga --","rsakeygen",       optiga_shell_crypt_generate_keypair},
+        {"    rsa sign                                 : optiga --","rsasign",         optiga_shell_crypt_rsa_sign},
+        {"    rsa verify sign                          : optiga --","rsaverify",       optiga_shell_crypt_rsa_verify},
+        {"    rsa encrypt message                      : optiga --","rsaencmsg",       optiga_shell_crypt_rsa_encrypt_message},
+        {"    rsa encrypt session                      : optiga --","rsaencsession",   optiga_shell_crypt_rsa_encrypt_session},
+        {"    rsa decrypt and store                    : optiga --","rsadecstore",     optiga_shell_crypt_rsa_decrypt_and_store},
+        {"    rsa decrypt and export                   : optiga --","rsadecexp",       optiga_shell_crypt_rsa_decrypt_and_export},
+
+        {"    symmetric ecb encrypt and decrypt        : optiga --","ecbencdec",       optiga_shell_crypt_symmetric_encrypt_decrypt_ecb},
+        {"    symmetric cbc encrypt and decrypt        : optiga --","cbcencdec",       optiga_shell_crypt_symmetric_encrypt_decrypt_cbc},
+        {"    symmetric cbcmac encrypt                 : optiga --","cbcmacenc",       optiga_shell_crypt_symmetric_encrypt_cbcmac},
+        {"    hmac-sha256 generation                   : optiga --","hmac",            optiga_shell_crypt_hmac},
+        {"    hkdf-sha256 key derivation               : optiga --","hkdf",            optiga_shell_crypt_hkdf},
+        {"    generate symmetric aes-128 key           : optiga --","aeskeygen",       optiga_shell_crypt_symmetric_generate_key},
+        {"    clear auto state                         : optiga --","clrautostate",    optiga_shell_crypt_clear_auto_state},
+        {"    hmac verify                              : optiga --","hmacverify",      optiga_shell_crypt_hmac_verify_with_authorization_reference},
+};
+
+#define OPTIGA_SIZE_OF_CMDS            (sizeof(optiga_cmds)/sizeof(optiga_example_cmd_t))
+
+static void optiga_shell_show_usage()
+{
+    uint8_t number_of_cmds = OPTIGA_SIZE_OF_CMDS;
+    uint8_t index;
+    optiga_example_cmd_t * current_cmd;
+    optiga_lib_print_string_with_newline("");
+    optiga_lib_print_string_with_newline("    usage                : optiga -<cmd>");
+    for(index = 0; index < number_of_cmds; index++)
+    {
+        current_cmd = &optiga_cmds[index];
+        if(0 != strcmp("help",current_cmd->cmd_options))
+        {
+            optiga_lib_print_string(current_cmd->cmd_description);
+            optiga_lib_print_string_with_newline(current_cmd->cmd_options);
+        }
+    }
+}
+
+static void optiga_shell_trim_cmd(char_t * user_cmd)
+{
+    char_t* i = user_cmd;
+    char_t* j = user_cmd;
+    while(*j != 0)
+    {
+        *i = *j++;
+        if(*i != ' ')
+            i++;
+    }
+    *i = 0;
+    if(strlen(user_cmd)>strlen("optiga --"))
+    {
+        strcpy(user_cmd,user_cmd+strlen("optiga --")-1);
+    }
+}
+
+static void optiga_shell_execute_example(char_t * user_cmd)
+{
+    uint8_t number_of_cmds = OPTIGA_SIZE_OF_CMDS;
+    uint8_t index,cmd_found = 0;
+    char_t * optiga_cmd_option = "optiga --";
+    optiga_example_cmd_t * current_cmd;
+
+    
+    do
+    {
+        if (0 != strncmp(user_cmd,optiga_cmd_option,9))
+        {
+            break;
+        }
+        optiga_shell_trim_cmd(user_cmd);
+        for(index = 0; index < number_of_cmds; index++)
+        {
+            current_cmd = &optiga_cmds[index];
+            if(0 == strcmp(user_cmd,current_cmd->cmd_options))
+            {
+                if(NULL != current_cmd->cmd_handler)
+                {
+                    unsigned int timestamp = pal_os_timer_get_time_in_milliseconds();
+                    current_cmd->cmd_handler();
+                    char buffer_string[30];
+                    //lint --e{713,705,737} suppress "Due to function parameter typecasting is done from unsigned int to int "
+                    sprintf(buffer_string, "Example takes %d msec", (int) pal_os_timer_get_time_in_milliseconds() - timestamp);
+                    OPTIGA_EXAMPLE_LOG_MESSAGE(buffer_string);
+                    optiga_lib_print_string_with_newline("");
+                    cmd_found = 1;
+                    break;
+                }
+                else
+                {
+                    optiga_lib_print_string_with_newline("No example exists for this request");
+                    break;
+                }
+            }
+        }
+    } while (FALSE);
+    if(!cmd_found)
+    {
+        optiga_lib_print_string_with_newline("");
+        optiga_lib_print_string_with_newline("No example exists for this request chose below options");
+        optiga_shell_show_usage();
+    }
+
+}
+
+static void optiga_shell_show_prompt()
+{
+    optiga_lib_print_string("$");
+}
+
+void optiga_shell_begin(void)
+{
+    uint8_t ch = 0;
+    char_t user_cmd[50];
+    uint8_t index = 0;
+
+    optiga_shell_show_prompt();
+    optiga_shell_show_usage();
+    optiga_shell_show_prompt();
+
+    //lint --e{716} Suppress the infinite loop
+    while(TRUE)
+    {
+        if (0 == pal_logger_read(&logger_console,&ch,1))
+        {
+
+            if(ch == 0x0d || ch == 0x0a)
+            {
+                user_cmd[index++] = 0;
+                index = 0;
+                optiga_lib_print_string_with_newline("");
+                //start cmd parsing
+                optiga_shell_execute_example((char_t * )user_cmd);
+                optiga_shell_show_prompt();
+            }
+            else
+            {
+                //keep adding
+                //lint --e{534,713} The return value is not used hence not checked*/
+                pal_logger_write(&logger_console, &ch, 1);
+                user_cmd[index++] = ch;
+            }
+        }
+    }
+}
+
+void optiga_shell_wait_for_user(void)
+{
+    uint16_t bytes = 0;
+    uint8_t ch = 0;
+    //lint --e{716} Suppress the infinite loop
+    while(TRUE)
+    {
+        bytes = USBD_VCOM_BytesReceived();
+        if (bytes)
+        {
+            //lint --e{534} The return value is not used hence not checked*/
+            pal_logger_read(&logger_console,&ch,1);
+            break;
+        }
+        else
+        {
+            optiga_lib_print_string_with_newline("Press any key to start optiga mini shell");
+            pal_os_timer_delay_in_milliseconds(2000);
+        }
+        bytes = 0;
+        CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
+    }
+}
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/bin/protected_update_data_set.exe b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/bin/protected_update_data_set.exe
new file mode 100644
index 0000000000000000000000000000000000000000..aa8e6d888137c92e704fee65ade669dbf0cea2f1
GIT binary patch
literal 109568
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%0A#V}2@trDhSI<~k`rDTvuS_6c#QD`=
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

literal 0
HcmV?d00001

diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/cbor.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/cbor.h
new file mode 100644
index 000000000..cab409226
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/cbor.h
@@ -0,0 +1,65 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file cbor.h
+*
+* \brief   This file defines APIs, types and data structures used for cbor format coding.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#ifndef _PROTECTED_UPDATE_CBOR_H_
+#define _PROTECTED_UPDATE_CBOR_H_
+
+#include <stdint.h>
+
+// Encodes cbor NULL
+int32_t cbor_set_null(uint8_t * buffer, uint16_t * offset);
+// Encodes cbor array
+int32_t cbor_set_array_of_data(uint8_t * buffer, uint32_t value, uint16_t * offset);
+// Encodes cbor unsiged integer
+int32_t cbor_set_unsigned_integer(uint8_t * buffer, uint32_t value, uint16_t * offset);
+// Encodes cbor unsiged integer
+int32_t cbor_set_signed_integer(uint8_t * buffer, int32_t value, uint16_t * offset);
+// Encodes cbor byte string
+int32_t cbor_set_byte_string(uint8_t * buffer, uint32_t value, uint16_t * offset);
+// Set the tag for map
+void cbor_set_map_tag(uint8_t * buffer, uint8_t map_number, uint16_t * offset);
+// Encodes cbor map for unsigned type
+int32_t cbor_set_map_unsigned_type(uint8_t * buffer, uint32_t key_data_item, uint32_t value_data_item, uint16_t * offset);
+// Encodes cbor map for signed type
+int32_t cbor_set_map_signed_type(uint8_t * buffer, uint32_t key_data_item, int32_t value_data_item, uint16_t * offset);
+// Encodes cbor map for byte array type
+int32_t cbor_set_map_byte_string_type(uint8_t * buffer, uint32_t key_data_item, const uint8_t * value_data_item, uint16_t value_data_item_len, uint16_t * offset);
+
+#endif //_PROTECTED_UPDATE_CBOR_H_
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/common_utilites.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/common_utilites.h
new file mode 100644
index 000000000..466e85cb5
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/common_utilites.h
@@ -0,0 +1,59 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file common_utilities.h
+*
+* \brief   This file defines APIs for common utilities.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#ifndef _PROTECTED_UPDATE_COMMON_UTILITIES_H_
+#define _PROTECTED_UPDATE_COMMON_UTILITIES_H_
+
+#include <stdint.h>
+
+// Copies 2 bytes of uint16 type value to the buffer
+void protected_tool_common_set_uint16 (uint8_t * p_output_buffer,uint16_t * offset,uint16_t two_byte_value);
+
+// Copies 3 bytes to the buffer
+void protected_tool_common_set_uint24 (uint8_t * p_output_buffer,uint16_t * offset,uint32_t three_byte_value);
+
+// Copies 4 bytes of uint32 type value to the buffer
+void protected_tool_common_set_uint32 (uint8_t* p_output_buffer, uint16_t * offset,uint32_t four_byte_value);
+
+// Copies 2 bytes of uint16 type value to the buffer without updating offset
+void protected_tool_common_set_uint16_without_offset (uint8_t * p_output_buffer, uint16_t two_byte_value);
+
+#endif //_PROTECTED_UPDATE_COMMON_UTILITIES_H_
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_crypt.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_crypt.h
new file mode 100644
index 000000000..b1fda1820
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_crypt.h
@@ -0,0 +1,125 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_crypt.h
+*
+* \brief   This file defines APIs, types and data structures used for protected update pal crypt.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+
+#ifndef _PROTECTED_UPDATE_PAL_CRYPTO_
+#define _PROTECTED_UPDATE_PAL_CRYPTO_
+
+#include <stdint.h>
+#include "protected_update_data_set.h"
+
+typedef struct pal_crypt
+{
+    /// callback
+    void * callback_ctx;
+}pal_crypt_t;
+
+/**
+ * @brief PAL return status.
+ */
+typedef uint16_t pal_status_t;
+
+// Generates hash
+pal_status_t pal_crypt_hash(pal_crypt_t* p_pal_crypt,
+                            uint8_t hash_algorithm,
+                            const uint8_t * p_message,
+                            uint32_t message_length,
+                            uint8_t * p_digest);
+
+// Calculates signature
+pal_status_t pal_crypt_sign(pal_crypt_t* p_pal_crypt,
+                            uint8_t * p_digest, 
+                            uint16_t digest_length,
+                            uint8_t * p_signature,
+                            uint16_t * signature_length,
+                            const uint8_t * p_private_key,
+                            uint16_t private_key_length);
+
+// Gets the signature length based on private key
+pal_status_t pal_crypt_get_signature_length( uint8_t * p_private_key,
+                                            uint16_t * sign_len,
+                                            signature_algo_t sign_algo);
+
+// Generate encrypted data
+pal_status_t pal_crypt_encrypt_aes128_ccm(  pal_crypt_t* p_pal_crypt,
+                                            const uint8_t * p_plain_text,
+                                            uint16_t plain_text_length,
+                                            const uint8_t * p_encrypt_key,
+                                            const uint8_t * p_nonce,
+                                            uint16_t nonce_length,
+                                            const uint8_t * p_associated_data,
+                                            uint16_t associated_data_length,
+                                            uint8_t mac_size,
+                                            uint8_t * p_cipher_text);
+// Derive key
+pal_status_t pal_crypt_tls_prf_sha256(  pal_crypt_t* p_pal_crypt,
+                                        const uint8_t * p_secret,
+                                        uint16_t secret_length,
+                                        const uint8_t * p_label,
+                                        uint16_t label_length,
+                                        const uint8_t * p_seed,
+                                        uint16_t seed_length,
+                                        uint8_t * p_derived_key,
+                                        uint16_t derived_key_length);
+
+
+// Generate random
+pal_status_t pal_crypt_generate_random(pal_crypt_t* p_pal_crypt,
+                                       uint8_t * p_random_data ,
+                                       uint16_t random_data_length );
+
+// Set seed
+pal_status_t pal_crypt_set_seed(pal_crypt_t* p_pal_crypt,
+                                uint8_t * p_seed,
+                                uint16_t seed_length);
+
+pal_status_t pal_crypt_get_key_type(int8_t * key_file);
+
+pal_status_t pal_crypt_parse_ecc_key(void * key_file,
+                                    uint8_t ** D, uint16_t * D_length,
+                                    uint8_t ** X, uint16_t * X_length,
+                                    uint8_t ** Y, uint16_t * Y_length);
+
+pal_status_t pal_crypt_parse_rsa_key(void * key_file,
+                                    uint8_t ** N, uint16_t * N_length,
+                                    uint8_t ** E, uint16_t * E_length,
+                                    uint8_t ** D, uint16_t * D_length);
+
+#endif //_PROTECTED_UPDATE_PAL_CRYPTO_
+/**
+* @}
+*/
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_file_system.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_file_system.h
new file mode 100644
index 000000000..ea3452bee
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_file_system.h
@@ -0,0 +1,60 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_file_system.h
+*
+* \brief   This file defines APIs, types and data structures used for protect update tool file system.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+
+#ifndef _PROTECTED_UPDATE_PAL_FILE_SYSTEM_
+#define _PROTECTED_UPDATE_PAL_FILE_SYSTEM_
+
+#include <stdint.h>
+
+// Read file to a byte array
+int32_t pal_file_system_read_file_to_array( const int8_t * file_name,
+                                        uint8_t ** byte_array,
+                                        uint16_t * byte_array_length);
+
+int32_t pal_file_system_read_file_to_array_in_hex(  const int8_t * file_name, 
+                                                uint8_t ** byte_array, 
+                                                uint16_t * byte_array_length);
+
+int32_t pal_file_system_write_to_file( const int8_t * file_name, 
+                                                int8_t * byte_array, 
+                                                uint16_t byte_array_length);
+#endif //_PROTECTED_UPDATE_PAL_FILE_SYSTEM_
+
+/**
+* @}
+*/
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_logger.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_logger.h
new file mode 100644
index 000000000..1232ca098
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_logger.h
@@ -0,0 +1,63 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_logger.h
+*
+* \brief   This file defines APIs, types and data structures used for protected update logger.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+#ifndef _PROTECTED_UPDATE_PAL_LOGGER_H_
+#define _PROTECTED_UPDATE_PAL_LOGGER_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+// Prints byte of data
+void pal_logger_print_byte(uint8_t datam);
+
+// Prints messge
+void pal_logger_print_message(const int8_t * str);
+
+// Prints hex data
+void pal_logger_print_hex_data(const uint8_t * data, uint16_t data_len);
+
+// Prints varibale name
+void pal_logger_print_variable_name(uint8_t * var_name, uint8_t value);
+
+// Prints data in file
+void pal_logger_print_to_file(int8_t * byte_array, uint16_t size);
+
+#endif //_PROTECTED_UPDATE_PAL_LOGGER_H_
+
+/**
+* @}
+*/
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_os_memory.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_os_memory.h
new file mode 100644
index 000000000..5fc32700f
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/pal/pal_os_memory.h
@@ -0,0 +1,63 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_memory.h
+*
+* \brief   This file defines APIs, for protected update tool memory system.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+
+#ifndef _PROTECTED_UPDATE_PAL_OS_MEMORY_H_
+#define _PROTECTED_UPDATE_PAL_OS_MEMORY_H_
+
+#include <stdint.h>
+
+// Allocates a block of memory specified by the block size and return the pointer to it
+void * pal_os_malloc(uint32_t block_size);
+
+// Allocates a block of memory specified by the block size and return the pointer to it
+void * pal_os_calloc(uint32_t number_of_blocks , uint32_t block_size);
+
+// Frees the block of memory specified by the block pointer
+void pal_os_free(void * p_block);
+
+// Copies data from source to destination
+void pal_os_memcpy(void * p_destination, const void * p_source, uint32_t size);
+
+// Sets the buffer with the given value
+void pal_os_memset(void * p_buffer, uint32_t value, uint32_t size);
+
+#endif //_PROTECTED_UPDATE_PAL_OS_MEMORY_H_
+
+/**
+* @}
+*/
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/protected_update_data_set.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/protected_update_data_set.h
new file mode 100644
index 000000000..11efe51d0
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/protected_update_data_set.h
@@ -0,0 +1,265 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file protected_update_data_set.h
+*
+* \brief   This file defines APIs, types and data structures used for protected update data set creation.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+#ifndef _PROTECTED_UPDATE_DATA_SET_H_
+#define _PROTECTED_UPDATE_DATA_SET_H_
+
+#include <stdint.h>
+
+#define FRAGMENT_DIGEST_LENGTH                      (0x20)
+#define MAX_PAYLOAD_SIZE                            (640U)
+#define MAC_SIZE                                    (8U)
+#define MAX_PAYLOAD_FRAGMENT_SIZE                   (MAX_PAYLOAD_SIZE - FRAGMENT_DIGEST_LENGTH)
+
+#define NONCE_LENGTH                                (11U)
+#define FRAGMENT_NUMBER_LENGTH                      (2U)
+#define ASSOCIATED_DATA_LENGTH                      (8U)
+#define SESSION_KEY_LENGTH                          (27U) 
+
+#define PAYLOAD_TYPE_KEY                            "key"
+#define PAYLOAD_TYPE_DATA                           "data"
+#define PROTECTED_INTEGRATY_TYPE                    "integrity"
+#define PROTECTED_CONFIDENTIALITY_TYPE              "confidentiality"
+#define TRUE                                        (1U)
+#define FALSE                                       (0U)
+
+typedef enum key_type
+{
+    eRSA = 1,
+    eECC = 2,
+    eAES = 3
+}key_type_d;
+
+typedef enum payload_type
+{
+    ePAYLOAD_DATA       = -1,
+    ePAYLOAD_METADATA   = -2,
+    ePAYLOAD_KEY        = -3,
+} payload_type_t;
+
+typedef enum key_algorithm
+{
+    eECC_NIST_P_256     = 0x03,
+    eECC_NIST_P_384     = 0x04,
+    eRSA_1024_EXP       = 0x41,
+    eRSA_2048_EXP       = 0x42,
+    eAES_128            = 0x81,
+} key_algorithm_t;
+
+typedef enum key_usage
+{
+    eAUTH                = 0x01,
+    eENC                 = 0x02,
+    eSIGN                = 0x10,
+    eKEY_AGREE           = 0x20
+}key_usage_t;
+
+
+typedef enum encryption_algo
+{
+    eAES_CCM_16_64_128          = 10,
+}encryption_algo_t;
+
+typedef enum kdf_algo
+{
+    eIFX_KDF_TLS12_PRF_SHA256   = -65720,
+}kdf_algo_t;
+
+typedef enum content_reset_type
+{
+    eMETADATA_IDENTIFIER_FLAG = 0,
+    eZEROES = 1,
+    eRANDOM = 2
+}content_reset_type_t;
+
+// Structure to store key derivation
+typedef struct kdf
+{
+    uint16_t shared_secret_oid;
+    uint8_t * shared_secret;
+    uint16_t shared_secret_length;
+    const uint8_t * label;
+    uint16_t label_length;
+    uint8_t * seed;
+    uint8_t seed_length;
+    kdf_algo_t key_derivation_algo;  
+} kdf_t;
+
+// Structure to store encrypt data parameters
+typedef struct enc_params
+{
+    encryption_algo_t encrypt_algo;
+    uint8_t session_key[SESSION_KEY_LENGTH];
+    uint8_t session_key_length;
+    uint8_t nonce_length;
+    uint8_t nonce_data[NONCE_LENGTH];
+    uint8_t associated_data[ASSOCIATED_DATA_LENGTH];
+    uint8_t mac_size;
+} enc_params_t;
+
+typedef struct confidentiality
+{
+    kdf_t kdf_data;
+    enc_params_t enc_params;
+}confidentiality_t;
+
+typedef struct data_payload
+{
+    uint32_t offset_in_oid;
+    uint8_t * data;
+    uint16_t data_length;
+    uint8_t write_type;
+}data_payload_t;
+
+typedef struct ecc_key
+{
+    uint8_t * D;
+    uint16_t D_length;
+    uint8_t * X;
+    uint16_t X_length;
+    uint8_t * Y;
+    uint16_t Y_length;
+}ecc_key_t;
+
+typedef struct rsa_key
+{
+    uint8_t * N;
+    uint16_t N_length;
+    uint8_t * E;
+    uint16_t E_length;
+    uint8_t * D;
+    uint16_t D_length;
+}rsa_key_t;
+
+typedef struct aes_key
+{
+    uint8_t * key;
+    uint16_t key_length;
+}aes_key_t;
+
+typedef union key_params
+{ 
+    rsa_key_t rsa_key;
+    ecc_key_t ecc_key;
+    aes_key_t aes_key;
+}key_params_t;
+
+typedef struct key_payload
+{
+    key_type_d key_type;
+    key_usage_t key_usage;
+    key_algorithm_t key_algorithm;
+    key_params_t key_params;
+    const int8_t * key_data_file_path;
+}key_payload_t;
+
+typedef struct metadata_payload
+{
+    key_type_d content_reset;
+    uint8_t additional_flag;
+    uint8_t * metadata;
+    uint16_t metadata_length;
+}metadata_payload_t;
+
+typedef enum signature_algo
+{
+    eES_SHA                     = -7,
+    eRSA_SSA_PKCS1_V1_5_SHA_256 = -65700,
+}signature_algo_t;
+
+typedef enum digest_algo
+{
+    eSHA_256                    = 41,
+}digest_algo_t;
+
+// Structure to store manifest data
+typedef struct manifest
+{
+    uint16_t payload_version;
+    uint16_t trust_anchor_oid;
+    uint16_t target_oid;
+    const uint8_t * couid;
+    signature_algo_t signature_algo;
+    const int8_t * private_key;
+    digest_algo_t digest_algo;
+    uint8_t * payload;
+    uint32_t payload_length;
+    payload_type_t payload_type;
+    
+    // confidentiality
+    confidentiality_t * p_confidentiality;
+    // payload data
+    data_payload_t * p_data_payload;
+    // payload key
+    key_payload_t * p_key_payload;
+    // payload metadata
+    metadata_payload_t * p_metadata_payload;
+
+} manifest_t;
+
+// Structure to store protect update data set
+typedef struct protected_update_data_set
+{
+    uint8_t * data;
+    uint16_t data_length;
+
+    uint8_t * fragments;
+    uint16_t fragments_length;
+    uint16_t actual_memory_allocated;
+
+}protected_update_data_set_d;
+
+// Create protected update manifest
+int32_t protected_update_create_manifest(   manifest_t * manifest_data, 
+                                        protected_update_data_set_d * p_cbor_manifest);
+
+// Create protected update payload fragments
+int32_t protected_update_create_fragments(  manifest_t * manifest_data, 
+                                        protected_update_data_set_d * p_cbor_manifest);
+
+void protected_update_print_output_dataset(const protected_update_data_set_d * p_cbor_manifest);
+
+#ifndef _NO_STATIC_H
+#define _STATIC_H static
+#else
+#define _STATIC_H
+#endif
+
+#endif //_PROTECTED_UPDATE_DATA_SET_H_
+
+/**
+* @}
+*/
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/protected_update_data_set_version.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/protected_update_data_set_version.h
new file mode 100644
index 000000000..dc65d2c84
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/protected_update_data_set_version.h
@@ -0,0 +1,47 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file protected_update_data_set_version.h
+*
+* \brief   This file defines the version for protect update tool version.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+#ifndef _PROTECTED_UPDATE_DATA_SET_VERSION_H_
+#define _PROTECTED_UPDATE_DATA_SET_VERSION_H_
+
+#define PROTECTED_UPDATE_VERSION    "2.00.2473"
+
+#endif //_PROTECTED_UPDATE_DATA_SET_VERSION_H_
+/**
+* @}
+*/
+
+
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/user_input_parser.h b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/user_input_parser.h
new file mode 100644
index 000000000..28f49bd40
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/include/user_input_parser.h
@@ -0,0 +1,54 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file user_input_parser.h
+*
+* \brief   This file defines APIs, types and data structures used for protected update logger.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#ifndef _PROTECTED_UPDATE_USER_INPUT_PARSER_H_
+#define _PROTECTED_UPDATE_USER_INPUT_PARSER_H_
+
+#include <stdint.h>
+
+//  Gets the user inputs
+int32_t tool_get_user_inputs(int32_t argc, int8_t *argv[]);
+//  Sets the user inputs
+int32_t tool_set_user_inputs(manifest_t* manifest_data);
+//  Clears all inputs
+int32_t tool_clear_inputs(manifest_t* p_manifest_data);
+
+#endif //_PROTECTED_UPDATE_USER_INPUT_PARSER_H_
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_crypt_mbedtls.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_crypt_mbedtls.c
new file mode 100644
index 000000000..fd2b8a0a8
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_crypt_mbedtls.c
@@ -0,0 +1,557 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_crypt_mbedtls.c
+*
+* \brief   This file implements APIs, types and data structures used for protected update pal crypt.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "mbedtls\sha256.h"
+#include "mbedtls\rsa.h"
+#include "mbedtls\pk.h"
+#include "mbedtls\entropy.h"
+#include "mbedtls\ctr_drbg.h"
+#include "pal\pal_logger.h"
+#include "mbedtls\ccm.h"
+#include "mbedtls\ssl.h"
+#include "pal\pal_crypt.h"
+#include "protected_update_data_set.h"
+#include "pal\pal_os_memory.h"
+#include "pal\pal_logger.h"
+
+static uint16_t pal_crypt_calculate_sha256_hash(    const uint8_t * message,
+                                            uint16_t message_len,
+                                            uint8_t * digest)
+{
+    uint16_t status = 1;
+    mbedtls_sha256_context sha256_ctx;
+    do
+    {
+        mbedtls_sha256_init(&sha256_ctx);
+
+        if (0 != mbedtls_sha256_starts_ret(&sha256_ctx, 0))
+        {
+            pal_logger_print_message(" Error : Failed in mbedtls_sha256_starts_ret\n");
+            break;
+        }
+        if (0 != mbedtls_sha256_update_ret(&sha256_ctx, message, message_len))
+        {
+            pal_logger_print_message(" Error : Failed in mbedtls_sha256_update_ret\n");
+            break;
+        }
+
+        if (0 != mbedtls_sha256_finish_ret(&sha256_ctx, digest))
+        {
+            pal_logger_print_message(" Error : Failed in mbedtls_sha256_finish_ret\n");
+            break;
+        }
+        mbedtls_sha256_free(&sha256_ctx);
+        status = 0;
+    } while (0);
+    return status;
+}
+
+//lint --e{715} suppress "argument "p_pal_crypt" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_hash( pal_crypt_t* p_pal_crypt,
+                    uint8_t hash_algorithm,
+                    const uint8_t * p_message,
+                    uint32_t message_length,
+                    uint8_t * p_digest)
+{
+    pal_status_t status = 1;
+
+    if((uint8_t)eSHA_256 == hash_algorithm) // SHA-256
+    {
+        status = pal_crypt_calculate_sha256_hash(p_message, (uint16_t)message_length, p_digest);
+    }
+
+    return status;
+}
+
+pal_status_t pal_crypt_get_signature_length(uint8_t * p_private_key, uint16_t * sign_len, signature_algo_t sign_algo)
+{
+    pal_status_t status = 1;
+    mbedtls_pk_context ctx;
+    mbedtls_ecp_keypair * ecc_ctx;
+    mbedtls_rsa_context * rsa_ctx;
+    mbedtls_pk_type_t key_type;
+    
+    mbedtls_pk_init(&ctx);
+    do
+    {
+        if (0 != mbedtls_pk_parse_keyfile(&ctx, (const int8_t*)p_private_key, ""))
+        {
+            pal_logger_print_message(" Error : Failed in mbedtls_pk_parse_keyfile\n");
+            break;
+        }
+
+        key_type = mbedtls_pk_get_type(&ctx);
+        if(eES_SHA == sign_algo)
+        {
+            if(MBEDTLS_PK_ECKEY == key_type)
+            {
+                ecc_ctx = (mbedtls_ecp_keypair *)ctx.pk_ctx;
+                // Signature length is (n/8)*2 hence to get the length of R & S component, 8/2 = 4
+                // Mod operation is performed to get non divisible key size in case of secp521r1.
+                *sign_len = (uint16_t)((ecc_ctx->grp.nbits)/4 + ((ecc_ctx->grp.nbits)%4?2:0)); 
+            }
+            else
+            {
+                pal_logger_print_message(" Error : Key type not mismatch\n");
+                break;
+            }
+        }
+        else if(eRSA_SSA_PKCS1_V1_5_SHA_256 == sign_algo)
+        {
+            if(MBEDTLS_PK_RSA == key_type)
+            {
+                rsa_ctx = (mbedtls_rsa_context *)ctx.pk_ctx;
+                // Signature length is (n/8)*2 hence to get the length of R & S component, 8/2 = 4
+                // Mod operation is performed to get non divisible key size in case of secp521r1.
+                *sign_len = (uint16_t)rsa_ctx->len; 
+            }
+            else
+            {
+                pal_logger_print_message(" Error : Key type not mismatch\n");
+                break;
+            }
+        }
+        else
+        {
+            pal_logger_print_message(" Error : Invalid sign algo\n");
+            break;
+        }
+        status = 0;
+    }while(0);
+
+    mbedtls_pk_free(&ctx);
+    return status;
+}
+
+//lint --e{715} suppress "argument "p_pal_crypt", "private_key_length" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_sign( pal_crypt_t* p_pal_crypt,
+                    uint8_t * p_digest, 
+                    uint16_t digest_length,
+                    uint8_t * p_signature,
+                    uint16_t * signature_length,
+                    const uint8_t * p_private_key,
+                    uint16_t private_key_length)
+{
+    pal_status_t status = 1;
+    mbedtls_pk_context ctx;
+    mbedtls_entropy_context entropy;
+    mbedtls_ctr_drbg_context ctr_drbg;
+    uint8_t hash[32];
+    const int8_t *pers = (const int8_t *)"mbedtls_pk_sign";
+    size_t signature_buff_len;
+
+    do
+    {
+            mbedtls_entropy_init(&entropy);
+            mbedtls_ctr_drbg_init(&ctr_drbg);
+            mbedtls_pk_init(&ctx);
+
+            if(0 != mbedtls_ctr_drbg_seed(  &ctr_drbg, mbedtls_entropy_func, 
+                                            &entropy, 
+                                            (const uint8_t *)pers, 
+                                            strlen(pers)))
+            {
+                pal_logger_print_message(" Error : Failed in mbedtls_ctr_drbg_seed\n");
+                break;
+            }
+            //Read key into an array
+            if (0 != mbedtls_pk_parse_keyfile(&ctx, (const int8_t*)p_private_key, ""))
+            {
+                pal_logger_print_message(" Error : Failed in mbedtls_pk_parse_keyfile\n");
+                break;
+            }
+
+            // generate hash
+            if (0 != pal_crypt_hash(NULL, (uint8_t)eSHA_256, p_digest, digest_length, hash))
+            {
+                pal_logger_print_message(" Error : Failed in pal_crypt_hash\n");
+                break;
+            }
+
+            if (0 != mbedtls_pk_sign(&ctx, MBEDTLS_MD_SHA256, hash, 0, p_signature, &signature_buff_len,
+                mbedtls_ctr_drbg_random, &ctr_drbg))
+            {
+                pal_logger_print_message(" Error : Failed in mbedtls_pk_sign\n");
+                break;
+            }
+            *signature_length = (uint16_t)signature_buff_len;
+            mbedtls_pk_free(&ctx);
+            mbedtls_ctr_drbg_free(&ctr_drbg);
+            mbedtls_entropy_free(&entropy);
+            status = 0;
+    } while (0);
+    return status;
+}
+
+//lint --e{715} suppress "argument "p_pal_crypt" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_encrypt_aes128_ccm(pal_crypt_t* p_pal_crypt,
+                                 const uint8_t * p_plain_text,
+                                 uint16_t plain_text_length,
+                                 const uint8_t * p_encrypt_key,
+                                 const uint8_t * p_nonce,
+                                 uint16_t nonce_length,
+                                 const uint8_t * p_associated_data,
+                                 uint16_t associated_data_length,
+                                 uint8_t mac_size,
+                                 uint8_t * p_cipher_text)
+{
+    #define AES128_KEY_BITS_SIZE    (16U)
+    #define MAC_TAG_BUFFER_SIZE     (16U)
+    
+    pal_status_t status = 1;
+    uint8_t mac_output[MAC_TAG_BUFFER_SIZE];
+    mbedtls_ccm_context encrypt;
+
+    mbedtls_ccm_init(&encrypt);
+
+    do
+    {
+
+        if (0 != mbedtls_ccm_setkey(&encrypt, MBEDTLS_CIPHER_ID_AES, p_encrypt_key, 8 * AES128_KEY_BITS_SIZE))
+        {
+            break;
+        }
+        
+        if (0 != mbedtls_ccm_encrypt_and_tag(&encrypt,
+                                              plain_text_length,
+                                              p_nonce,
+                                              nonce_length,
+                                              p_associated_data,
+                                              associated_data_length,
+                                              p_plain_text,
+                                              p_cipher_text,
+                                              mac_output,
+                                              mac_size))
+        
+        {
+            break;
+        }
+
+        memcpy((p_cipher_text + plain_text_length), mac_output, mac_size);
+        status = 0;
+    } while (0);
+    mbedtls_ccm_free(&encrypt);
+    #undef AES128_KEY_BITS_SIZE
+    #undef MAC_TAG_BUFFER_SIZE    
+    return status;
+}
+
+//lint --e{715} suppress "argument "p_pal_crypt" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_tls_prf_sha256(pal_crypt_t* p_pal_crypt,
+                            const uint8_t * p_secret,
+                            uint16_t secret_length,
+                            const uint8_t * p_label,
+                            uint16_t label_length,
+                            const uint8_t * p_seed,
+                            uint16_t seed_length,
+                            uint8_t * p_derived_key,
+                            uint16_t derived_key_length)
+{
+    #define PAL_CRYPT_DIGEST_MAX_SIZE    (32U)
+    #define PAL_CRYPT_MAX_LABEL_SEED_LENGTH     (96U)
+
+    pal_status_t return_value = 1;
+    uint8_t message_digest_length = PAL_CRYPT_DIGEST_MAX_SIZE;
+    uint16_t derive_key_len_index, hmac_checksum_result_index;
+    uint16_t hmac_result_length;
+    uint8_t md_hmac_temp_array[PAL_CRYPT_MAX_LABEL_SEED_LENGTH + PAL_CRYPT_DIGEST_MAX_SIZE];
+    uint8_t hmac_checksum_result[PAL_CRYPT_DIGEST_MAX_SIZE];
+    const mbedtls_md_info_t *message_digest_info;
+    mbedtls_md_context_t message_digest_context;
+    uint16_t final_seed_length = 0;
+       
+    mbedtls_md_init(&message_digest_context);
+    
+    do
+    {
+        if (sizeof(md_hmac_temp_array ) < (uint32_t)(message_digest_length + label_length + seed_length))
+        {
+            //return_value = PAL_STATUS_INVALID_INPUT;
+            break;
+        }
+
+        message_digest_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
+
+        memcpy(md_hmac_temp_array + message_digest_length, p_label, label_length);
+        memcpy(md_hmac_temp_array + message_digest_length + label_length, p_seed, seed_length);
+        final_seed_length = label_length + seed_length;
+
+        if (0 != (mbedtls_md_setup(&message_digest_context,message_digest_info,1)))
+        {
+            //return_value = PAL_STATUS_INVALID_INPUT;
+            break;
+        }
+
+        if (0 != mbedtls_md_hmac_starts(&message_digest_context, p_secret, secret_length))
+        {
+            break;
+        }
+       
+        if (0 != mbedtls_md_hmac_update(&message_digest_context, md_hmac_temp_array + message_digest_length, final_seed_length))
+        {
+            break;
+        }
+        
+        if (0 != mbedtls_md_hmac_finish(&message_digest_context, md_hmac_temp_array))
+        {
+            break;
+        }
+
+        for (derive_key_len_index = 0; derive_key_len_index < derived_key_length; 
+             derive_key_len_index += message_digest_length)
+        {
+            if (0 != mbedtls_md_hmac_reset(&message_digest_context))
+            {
+                break;
+            }
+            if (0 != mbedtls_md_hmac_update(&message_digest_context, md_hmac_temp_array, 
+                            message_digest_length + final_seed_length))
+            {
+                break;                
+            }
+            if (0 != mbedtls_md_hmac_finish(&message_digest_context, hmac_checksum_result))
+            {
+                break;                                
+            }
+
+            if (0 != mbedtls_md_hmac_reset(&message_digest_context))
+            {
+                break;                
+            }
+            if (0 != mbedtls_md_hmac_update(&message_digest_context, md_hmac_temp_array, message_digest_length))
+            {
+                break;                                
+            }
+            if (0 != mbedtls_md_hmac_finish(&message_digest_context, md_hmac_temp_array))
+            {
+                break;                                
+            }
+
+            hmac_result_length = ((derive_key_len_index + message_digest_length) > derived_key_length) ? 
+                                  (derived_key_length % message_digest_length) : (message_digest_length);
+
+            for (hmac_checksum_result_index = 0; hmac_checksum_result_index < hmac_result_length; 
+                 hmac_checksum_result_index++)
+            {
+                p_derived_key[derive_key_len_index + hmac_checksum_result_index] = hmac_checksum_result[hmac_checksum_result_index];
+            }
+        }
+        if (derive_key_len_index >= derived_key_length)
+        {
+            return_value = 0;
+        }
+    } while (FALSE);
+    
+    mbedtls_md_free(&message_digest_context);
+
+    memset(md_hmac_temp_array, 0x00, sizeof(md_hmac_temp_array));
+    memset(hmac_checksum_result, 0x00, sizeof(hmac_checksum_result));    
+    #undef PAL_CRYPT_DIGEST_MAX_SIZE
+    #undef PAL_CRYPT_MAX_LABEL_SEED_LENGTH
+    return return_value;
+}
+
+//lint --e{715} suppress "argument "p_pal_crypt" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_generate_random( pal_crypt_t* p_pal_crypt,
+                               uint8_t * p_random_data ,
+                               uint16_t random_data_length )
+{
+    pal_status_t return_value = 1;
+    mbedtls_ctr_drbg_context ctr_drbg;
+    mbedtls_entropy_context entropy;
+    const int8_t *pers = (const int8_t *)"mbedtls_pk_sign";
+
+
+    mbedtls_ctr_drbg_init(&ctr_drbg);
+    mbedtls_entropy_init(&entropy);
+
+    do
+    {
+        if(0 != mbedtls_ctr_drbg_seed(  &ctr_drbg, mbedtls_entropy_func, 
+                                        &entropy, 
+                                        (const uint8_t *)pers, 
+                                        strlen(pers)))
+        {
+            pal_logger_print_message(" Error : Failed in mbedtls_ctr_drbg_seed\n");
+            break;
+        }
+        if (0 != mbedtls_ctr_drbg_random(&ctr_drbg, p_random_data, random_data_length))
+        {
+            pal_logger_print_message(" Error : Failed in mbedtls_pk_parse_keyfile\n");
+            break;
+        }        
+        return_value = 0;
+    } while (FALSE);
+
+    mbedtls_ctr_drbg_free(&ctr_drbg);
+    mbedtls_entropy_free(&entropy);
+    return return_value;
+}
+
+//lint --e{715} suppress "argument "p_pal_crypt" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_set_seed(pal_crypt_t* p_pal_crypt,
+                       uint8_t * p_seed,
+                       uint16_t seed_length)
+{
+    return(pal_crypt_generate_random(p_pal_crypt, p_seed, seed_length));
+}
+
+pal_status_t pal_crypt_get_key_type(int8_t * key_file)
+{
+    pal_status_t status = 1;
+    mbedtls_pk_context ctx;
+    mbedtls_pk_type_t key_type;
+    int8_t buffer[200];
+
+    mbedtls_pk_init(&ctx);
+
+    do
+    {
+        if (0 != mbedtls_pk_parse_keyfile(&ctx, key_file, ""))
+        {
+            sprintf(buffer, "Error : Parsing of the key file");
+            pal_logger_print_message(buffer);
+            break;
+        }
+        key_type = mbedtls_pk_get_type(&ctx);
+        switch (key_type)
+        {
+        case MBEDTLS_PK_RSA:
+            status = (uint16_t)eRSA;
+            break;
+        case MBEDTLS_PK_ECKEY:
+            status = (uint16_t)eECC;
+            break;
+        case MBEDTLS_PK_NONE:
+        case MBEDTLS_PK_ECKEY_DH:
+        case MBEDTLS_PK_ECDSA:
+        case MBEDTLS_PK_RSA_ALT:
+        case MBEDTLS_PK_RSASSA_PSS:
+        default :
+            break;
+        }
+    } while (0);
+
+    mbedtls_pk_free(&ctx);
+    return status;
+}
+
+static inline void pal_crypt_set_buffer(uint8_t ** dest, uint16_t * dest_len, uint16_t len)
+{
+    void * x = pal_os_malloc(len);
+    *dest = x;
+    *dest_len = len;
+}
+
+pal_status_t pal_crypt_parse_ecc_key(void * key_file,
+    uint8_t ** D, uint16_t * D_length,
+    uint8_t ** X, uint16_t * X_length,
+    uint8_t ** Y, uint16_t * Y_length)
+{
+    int32_t status = 1;
+    mbedtls_pk_context ctx;
+    mbedtls_ecp_keypair * ecc_ctx;
+    int8_t buffer[200];
+
+    mbedtls_pk_init(&ctx);
+    
+    do
+    {
+        if (0 != mbedtls_pk_parse_keyfile(&ctx, key_file, ""))
+        {
+            sprintf(buffer, "Error : Parsing of the ecc key file");
+            pal_logger_print_message(buffer);
+        }
+        ecc_ctx = (mbedtls_ecp_keypair *)ctx.pk_ctx;
+
+        // Check for curve which is not divisible by 8
+        pal_crypt_set_buffer(D, D_length, (uint16_t)(((ecc_ctx->grp.nbits)/8) + ((ecc_ctx->grp.nbits)%8?1:0)));
+        pal_crypt_set_buffer(X, X_length, (uint16_t)(((ecc_ctx->grp.nbits)/8) + ((ecc_ctx->grp.nbits)%8?1:0)));
+        pal_crypt_set_buffer(Y, Y_length, (uint16_t)(((ecc_ctx->grp.nbits)/8) + ((ecc_ctx->grp.nbits)%8?1:0)));
+
+        status = mbedtls_mpi_write_binary(&(ecc_ctx->d), *D, *D_length);
+        status |= mbedtls_mpi_write_binary(&(ecc_ctx->Q.X), *X, *X_length);
+        status |= mbedtls_mpi_write_binary(&(ecc_ctx->Q.Y), *Y, *Y_length);
+
+    } while (0);
+    mbedtls_pk_free(&ctx);
+    return (pal_status_t)status;
+}
+
+
+pal_status_t pal_crypt_parse_rsa_key(void * key_file,
+    uint8_t ** N, uint16_t * N_length,
+    uint8_t ** E, uint16_t * E_length,
+    uint8_t ** D, uint16_t * D_length)
+{
+    int32_t status = 1;
+    mbedtls_pk_context ctx;
+    mbedtls_rsa_context * rsa_ctx;
+    int8_t buffer[200];
+
+    mbedtls_pk_init(&ctx);
+
+    do
+    {
+        if (0 != mbedtls_pk_parse_keyfile(&ctx, key_file, ""))
+        {
+            sprintf(buffer,"Error : Parsing of the rsa key file");
+            pal_logger_print_message(buffer);
+            break;
+        }
+        rsa_ctx = (mbedtls_rsa_context *)ctx.pk_ctx;
+        pal_crypt_set_buffer(N, N_length, (uint16_t)rsa_ctx->len);
+        pal_crypt_set_buffer(E, E_length, 4);
+        pal_crypt_set_buffer(D, D_length, (uint16_t)rsa_ctx->len);
+
+        status = mbedtls_mpi_write_binary(&(rsa_ctx->N), *N, *N_length);
+        status |= mbedtls_mpi_write_binary(&(rsa_ctx->E), *E, *E_length);
+        status |= mbedtls_mpi_write_binary(&(rsa_ctx->D), *D, *D_length);
+
+    } while (0);
+
+    mbedtls_pk_free(&ctx);
+    return (pal_status_t)status;
+}
+
+/** 
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_file_system.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_file_system.c
new file mode 100644
index 000000000..3d6124ce0
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_file_system.c
@@ -0,0 +1,196 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_file_system.c
+*
+* \brief   This file implements APIs, types and data structures used for protect update tool file system.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "pal\pal_logger.h"
+#include "pal\pal_os_memory.h"
+
+int32_t pal_file_system_read_file_to_array( const int8_t * file_name, 
+                                        uint8_t ** byte_array, 
+                                        uint16_t * byte_array_length)
+{
+    int32_t status = -1;
+
+    FILE * fp = NULL;
+    uint32_t filelen;
+    int8_t * buffer = NULL;
+
+    do
+    {
+        if (NULL == file_name)
+        {
+            pal_logger_print_message(" Error : File name is NULL\n");
+            break;
+        }
+        fp = fopen(file_name, "rb");
+        if (NULL == fp)
+        {
+            pal_logger_print_message(" Error : Failed in fopen\n");
+            break;
+        }
+        // Jump to the end of the file
+        (void)fseek(fp, 0, SEEK_END);      
+        // Get the current byte offset in the file
+        filelen = (uint32_t)ftell(fp);       
+        // Jump back to the beginning of the file
+        rewind(fp);                      
+        // Enough memory for file + \0
+        buffer = (int8_t *)pal_os_malloc((filelen)*sizeof(int8_t)); 
+        // Read in the entire file
+        if(NULL != buffer)
+        {
+            (void)fread(buffer, filelen, 1, fp);
+            *byte_array = (uint8_t*)buffer;
+            *byte_array_length = (uint16_t)filelen;
+            status = 0;
+        }   
+    } while (0);
+    if (NULL != fp)
+    {
+        (void)fclose(fp); 
+    }
+    return status;
+}
+
+int32_t pal_file_system_read_file_to_array_in_hex(  const int8_t * file_name, 
+                                                uint8_t ** byte_array, 
+                                                uint16_t * byte_array_length)
+{
+    int32_t status = -1;
+
+    FILE * fp = NULL;
+    int32_t idx = 0;
+    uint32_t val;
+    uint32_t filelen = 0;
+    int8_t * buffer = NULL;
+    uint32_t data_copied_count = 0;
+    int32_t c;
+
+    do
+    {
+        if (NULL == file_name)
+        {
+            pal_logger_print_message(" Error : File name is NULL\n");
+            break;
+        }
+        fp = fopen(file_name, "rb");
+        if (NULL == fp)
+        {
+            pal_logger_print_message(" Error : Failed in fopen\n");
+            break;
+        }
+
+        // Get the number of characters in file
+        for (c = getc(fp); c != EOF;c = getc(fp))
+        {
+            // Increment count for this character 
+            if(('\r' != (uint8_t)c) && ('\n' != (uint8_t)c))
+            {
+                filelen = filelen + 1; 
+            }
+        }
+        filelen = filelen/2;
+
+        // Jump back to the beginning of the file
+        rewind(fp);
+
+        // Enough memory for file + \0
+        buffer = (int8_t *)pal_os_malloc((filelen)*sizeof(int8_t)); 
+        if(NULL == buffer)
+        {
+            break;
+        }
+
+        while (fscanf(fp, "%2x", &val) != EOF) {
+            buffer[idx++] = (int8_t)val;
+            data_copied_count++;
+        }
+
+        if(filelen != data_copied_count)
+        {
+            break;
+        }
+        *byte_array = (uint8_t *)buffer;
+        *byte_array_length = (uint16_t)filelen;
+        status = 0;
+    } while (0);
+
+    if (NULL != fp)
+    {
+        (void)fclose(fp); 
+    }
+    return status;
+}
+
+//lint --e{715} suppress "byte_array_length is kept in case where number of bytes write needs to be mentioned"
+int32_t pal_file_system_write_to_file( const int8_t * file_name, 
+                                                int8_t * byte_array, 
+                                                uint16_t byte_array_length)
+{
+    int32_t status = -1;
+
+    FILE * fp = NULL;
+
+    do
+    {
+        if (NULL == file_name)
+        {
+            pal_logger_print_message(" Error : File name is NULL");
+            break;
+        }
+        fp = fopen(file_name, "a+");
+        if (NULL == fp)
+        {
+            pal_logger_print_message(" Error : Failed in fopen");
+            break;
+        }
+
+        fprintf(fp, "%s", byte_array);
+        status = 0;
+    } while (0);
+
+    if (NULL != fp)
+    {
+        (void)fclose(fp); 
+    }
+    return status;
+}
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_logger.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_logger.c
new file mode 100644
index 000000000..ce5240432
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_logger.c
@@ -0,0 +1,118 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_logger.c
+*
+* \brief   This file defines APIs, types and data structures used for cbor format coding.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+#include <stdio.h>
+#include "pal\pal_logger.h"
+#include "pal\pal_file_system.h"
+
+#define PRINT_C_CODE_FORMAT_ENABLED    1
+
+const uint8_t * dataset_file_path = NULL;
+
+void pal_logger_print_byte(uint8_t datam)
+{
+#if PRINT_C_CODE_FORMAT_ENABLED
+    printf("0x%02X, ", datam);
+#else
+
+    printf("%02X ", datam);
+#endif
+
+}
+
+void pal_logger_print_message(const int8_t * str)
+{
+    printf("%s", str);
+}
+
+void pal_logger_print_format_message(const int8_t * str, ...)
+{
+    printf("%s\n", str);
+}
+
+void pal_logger_print_hex_data( const uint8_t * data, 
+                                uint16_t  data_len)
+{
+    uint32_t  count = data_len;
+    uint32_t  index;
+    for (index = 0; index < count; index++)
+    {
+        pal_logger_print_byte(data[index]);
+        if (0 == ((index + 1)) % 16)
+        {
+            printf("\n\t");
+        }
+    }
+    printf("\b");
+}
+
+void pal_logger_print_variable_name(uint8_t * var_name, 
+                                    uint8_t value)
+{
+#if PRINT_C_CODE_FORMAT_ENABLED
+    if (NULL != var_name)
+    {
+        if (0 == value)
+        {
+            printf("%s %s%s", "uint8_t", var_name, "[] = \n");
+        }
+        else
+        {
+            printf("%s %s%s%02d%s", "uint8_t", var_name,"_", value,"[] = \n");
+        }
+        printf("\t%s", "{\n\t");
+    }
+    else
+    {
+        printf("\n\t%s", "};");
+    }
+#endif
+}
+
+void pal_logger_print_to_file(int8_t * byte_array, uint16_t size)
+{
+    if(NULL != dataset_file_path)
+    {
+        if (0 != pal_file_system_write_to_file((const int8_t *)dataset_file_path, byte_array, size))
+        {
+            pal_logger_print_message("Error : Unable to write to file\n");
+        }
+    } 
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_os_memory.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_os_memory.c
new file mode 100644
index 000000000..2ef069991
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/pal/pal_os_memory.c
@@ -0,0 +1,70 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_memory.c
+*
+* \brief   This file implements the platform abstraction layer APIs for memory.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+void * pal_os_malloc(uint32_t block_size)
+{
+    return (malloc(block_size));
+}
+
+void * pal_os_calloc(uint32_t number_of_blocks , uint32_t block_size)
+{
+    return (calloc(number_of_blocks, block_size));
+}
+
+void pal_os_free(void * p_block)
+{
+    free(p_block);
+}
+
+void pal_os_memcpy(void * p_destination, const void * p_source, uint32_t size)
+{
+    memcpy(p_destination, p_source, size);
+}
+
+void pal_os_memset(void * p_buffer, uint32_t value, uint32_t size)
+{
+    memset(p_buffer, (int32_t)value, size);
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/readme.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/readme.txt
new file mode 100644
index 000000000..f0ca113dc
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/readme.txt
@@ -0,0 +1,32 @@
+1. Usage
+	protected_update_data_set.exe input1=<value> input2=<value> ...
+	
+	For more information run "protected_update_data_set.exe /?" on command prompt
+		
+2. Sample :
+	A sample script demonstrating the usage of the tool is available in ..\samples\sample.bat
+	
+3. Limitations
+	a. Only SHA-256 digest algorithm is supported for hash calculation
+	b. Manifest version number is 1	
+    	
+4. Environment
+	a. The available executable is built using microsoft visual studio 2010 in windows 10 (64 bit)
+	b. Install Microsoft Visual C++ 2010 x86 redistributable (vcredist_x86.exe) package to execute application on machine which does not have Visual Studio.
+	c. mbedTLS 2.16.0 is used for crypto operation.
+	d. The following MACRO must be disabled/ enabled when using mbedTLS for this tool.
+		i. Enable :
+			MBEDTLS_FS_IO
+			MBEDTLS_PEM_PARSE_C
+			MBEDTLS_BASE64_C
+			MBEDTLS_ECDSA_DETERMINISTIC
+			MBEDTLS_HMAC_DRBG_C
+			MBEDTLS_ECDSA_DETERMINISTIC_DEBUG
+			MBEDTLS_RSA_C
+			MBEDTLS_PKCS1_V15
+			MBEDTLS_PK_RSA_ALT_SUPPORT
+			MBEDTLS_TIMING_C
+			MBEDTLS_ENTROPY_C
+			MBEDTLS_CTR_DRBG_C
+			MBEDTLS_ECP_DP_SECP256R1_ENABLED
+			MBEDTLS_ECP_DP_SECP384R1_ENABLED
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/confidentiality/secret.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/confidentiality/secret.txt
new file mode 100644
index 000000000..8b757002a
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/confidentiality/secret.txt
@@ -0,0 +1 @@
+49c9f492a992f6d4c54f5b12c57edb27ced224048f25482aa149c9f492a992f649c9f492a992f6d4c54f5b12c57edb27ced224048f25482aa149c9f492a992f6
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_data_update_data_set.bat b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_data_update_data_set.bat
new file mode 100644
index 000000000..b812aad9d
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_data_update_data_set.bat
@@ -0,0 +1,11 @@
+set PATH=..\bin
+
+:: Data update 
+::RSA-SSA-PKCS1-V1_5-SHA-256 (RSA-1024)
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E0E1 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=data offset=00 write_type=1 in_data_format="ascii" data=..\samples\payload\data\ascii_data.txt secret=..\samples\confidentiality\secret.txt label="test" seed_length=64 enc_algo="AES-CCM-16-64-128" secret_oid=F1D1
+
+::RSA-SSA-PKCS1-V1_5-SHA-256 (RSA-2048)
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E0E1 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_2048_priv.pem payload_type=data offset=00 write_type=1 in_data_format="ascii" data=..\samples\payload\data\ascii_data.txt secret=..\samples\confidentiality\secret.txt label="test" seed_length=64 enc_algo="AES-CCM-16-64-128" secret_oid=F1D1
+
+::RSA-SSA-PKCS1-V1_5-SHA-256 (RSA-1024) with hex file format
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E0E1 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=data offset=00 write_type=1 in_data_format="hex" data=..\samples\payload\data\hex_data.txt secret=..\samples\confidentiality\secret.txt label="test" seed_length=64 enc_algo="AES-CCM-16-64-128" secret_oid=F1D1
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_key_update_data_set.bat b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_key_update_data_set.bat
new file mode 100644
index 000000000..20c8b70bb
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_key_update_data_set.bat
@@ -0,0 +1,22 @@
+set PATH=..\bin
+
+:: Key update 
+
+:: RSA-1024 key update
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E0FC sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=key key_algo=65 key_usage=12 key_data=..\samples\payload\key\rsa_1024_test.pem secret=..\samples\confidentiality\secret.txt label="test" seed_length=64 enc_algo="AES-CCM-16-64-128" secret_oid=F1D1
+
+:: RSA-2048 key update
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E0FD sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_2048_priv.pem payload_type=key key_algo=66 key_usage=10 key_data=..\samples\payload\key\rsa_2048_test.pem
+
+:: AES-128 key update
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E200 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=key key_algo=129 key_usage=02 key_data=..\samples\payload\key\aes_key_128.txt secret=..\samples\confidentiality\secret.txt label="test" seed_length=64 enc_algo="AES-CCM-16-64-128" secret_oid=F1D1
+
+:: AES-192 key update
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E200 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=key key_algo=130 key_usage=02 key_data=..\samples\payload\key\aes_key_192.txt secret=..\samples\confidentiality\secret.txt label="test" seed_length=64 enc_algo="AES-CCM-16-64-128" secret_oid=F1D1
+
+:: AES-256 key update
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E200 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=key key_algo=131 key_usage=02 key_data=..\samples\payload\key\aes_key_256.txt secret=..\samples\confidentiality\secret.txt label="test" seed_length=64 enc_algo="AES-CCM-16-64-128" secret_oid=F1D1
+
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E200 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=key key_algo=129 key_usage=02 key_data=..\samples\payload\key\aes_key_128.txt 
+
+%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E0FC sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=key key_algo=65 key_usage=12 key_data=..\samples\payload\key\rsa_1024_test.pem 
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_metadata_update_data_set.bat b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_metadata_update_data_set.bat
new file mode 100644
index 000000000..0252bc268
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/gen_metadata_update_data_set.bat
@@ -0,0 +1,7 @@
+set PATH=..\bin
+
+:: Metadata update 
+
+%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E0E2 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=metadata metadata=..\samples\payload\metadata\metadata.txt content_reset=0 secret=..\samples\confidentiality\secret.txt label="test" enc_algo="AES-CCM-16-64-128" secret_oid=F1D1
+
+::%PATH%\protected_update_data_set.exe payload_version=3 trust_anchor_oid=E0E3 target_oid=E0E2 sign_algo=RSA-SSA-PKCS1-V1_5-SHA-256 priv_key=..\samples\integrity\sample_rsa_1024_priv.pem payload_type=metadata metadata=..\samples\payload\metadata\metadata.txt content_reset=0
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_1024_cert.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_1024_cert.txt
new file mode 100644
index 000000000..4cf225604
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_1024_cert.txt
@@ -0,0 +1,46 @@
+0x30, 0x82, 0x02, 0xD5, 0x30, 0x82, 0x01, 0xBD, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x4D,
+0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30,
+0x3C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x49, 0x4E, 0x31, 0x0D,
+0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31, 0x1E, 0x30,
+0x1C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x15, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x61, 0x6E,
+0x63, 0x68, 0x6F, 0x72, 0x20, 0x72, 0x73, 0x61, 0x20, 0x32, 0x30, 0x34, 0x38, 0x30, 0x1E, 0x17,
+0x0D, 0x31, 0x38, 0x30, 0x36, 0x31, 0x31, 0x30, 0x37, 0x32, 0x35, 0x35, 0x36, 0x5A, 0x17, 0x0D, 
+0x32, 0x38, 0x30, 0x36, 0x30, 0x38, 0x30, 0x37, 0x32, 0x35, 0x35, 0x36, 0x5A, 0x30, 0x3C, 0x31, 
+0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x49, 0x4E, 0x31, 0x0D, 0x30, 0x0B, 
+0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31, 0x1E, 0x30, 0x1C, 0x06, 
+0x03, 0x55, 0x04, 0x03, 0x0C, 0x15, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 
+0x74, 0x65, 0x20, 0x72, 0x73, 0x61, 0x20, 0x31, 0x30, 0x32, 0x34, 0x30, 0x81, 0x9F, 0x30, 0x0D, 
+0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8D, 
+0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xE1, 0x26, 0x9F, 0x49, 0x2B, 0xA0, 0xCF, 0x88, 
+0xAB, 0x10, 0x6A, 0x48, 0x64, 0xAD, 0xBF, 0xED, 0x95, 0xAE, 0x49, 0xE6, 0x85, 0x78, 0x56, 0x5F, 
+0x44, 0x0A, 0xD5, 0x3E, 0x76, 0x16, 0x70, 0xD1, 0x15, 0x04, 0x04, 0x15, 0x3A, 0xD3, 0xBE, 0xF0, 
+0xA9, 0x68, 0x1B, 0x0A, 0x8F, 0xDC, 0xE4, 0x09, 0x5F, 0xF7, 0x27, 0xED, 0x68, 0x22, 0x54, 0xCA, 
+0xB5, 0xB2, 0x7A, 0xD0, 0xBD, 0x60, 0x97, 0x5A, 0x17, 0x3B, 0x6B, 0x9D, 0xF7, 0x12, 0xD5, 0x01, 
+0x9C, 0x7C, 0x89, 0x4F, 0xE2, 0x28, 0x44, 0xC8, 0x7E, 0xC4, 0x49, 0xFB, 0xDF, 0x31, 0xBF, 0x32, 
+0xDC, 0xC6, 0x2B, 0x32, 0xDC, 0x73, 0x41, 0xB2, 0x92, 0xE9, 0x90, 0xB5, 0x93, 0xFF, 0x60, 0x10, 
+0xC3, 0x45, 0xF3, 0xE6, 0x07, 0x04, 0xF0, 0xA2, 0x67, 0x2F, 0x5F, 0x53, 0xA5, 0xFC, 0x1B, 0x30, 
+0xE5, 0x7E, 0x8E, 0x94, 0x85, 0x13, 0x13, 0x9B, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x66, 0x30, 
+0x64, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x82, 0xDA, 0x0A, 0xF9, 
+0x6A, 0x37, 0x49, 0x71, 0xA1, 0x9E, 0x61, 0x4E, 0x46, 0xEB, 0xA9, 0x19, 0x9F, 0x59, 0xAB, 0x28, 
+0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xDF, 0xE4, 0xB1, 
+0x34, 0x53, 0x2D, 0x46, 0x50, 0xCD, 0x7D, 0xFB, 0xF8, 0x68, 0x1F, 0xCB, 0xF4, 0x29, 0xA5, 0x4C, 
+0xD1, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 
+0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 
+0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 
+0x01, 0x0B, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x21, 0x4F, 0x0B, 0x00, 0x0E, 0x63, 0x77, 
+0xE2, 0x6D, 0x54, 0x25, 0xDC, 0xD6, 0x5F, 0xFF, 0xED, 0x6B, 0x9B, 0x7C, 0x28, 0xA4, 0x09, 0x63, 
+0x93, 0xCC, 0x91, 0xBB, 0xAC, 0x2A, 0xD6, 0x93, 0x56, 0x30, 0x1C, 0x11, 0x9C, 0x9D, 0xA4, 0xD9, 
+0xD5, 0x45, 0x52, 0x26, 0xDF, 0xFA, 0x65, 0xCB, 0xA1, 0xF0, 0x63, 0xA0, 0xE4, 0xB1, 0xCD, 0xFF, 
+0xB4, 0x52, 0x6B, 0x38, 0x35, 0x17, 0x29, 0x15, 0x8A, 0xCC, 0xEC, 0xDE, 0x5E, 0x87, 0x63, 0x47, 
+0xDE, 0x32, 0xBA, 0xB1, 0x90, 0xAF, 0x5C, 0xCB, 0x6F, 0xBA, 0x48, 0x29, 0x55, 0xF0, 0xED, 0xA7, 
+0xDD, 0x75, 0x7E, 0x68, 0x42, 0xD2, 0xB3, 0xC4, 0xC5, 0x2B, 0x90, 0x3B, 0xBC, 0xCF, 0xC6, 0x96, 
+0xA6, 0x5F, 0xB9, 0x70, 0xAD, 0x05, 0x67, 0xB3, 0x3A, 0xF9, 0x9D, 0x7F, 0xEF, 0x7A, 0xDE, 0x68, 
+0xCF, 0xEE, 0x1D, 0xDF, 0x2F, 0xFF, 0x3D, 0x38, 0x92, 0xF3, 0x85, 0x00, 0x11, 0x89, 0x9F, 0xBF, 
+0xDD, 0x88, 0x79, 0xAE, 0xE0, 0xE2, 0xE1, 0x56, 0x46, 0x8C, 0x32, 0x37, 0xCA, 0x6D, 0x25, 0x43, 
+0x7F, 0x90, 0xC0, 0xFB, 0xDA, 0xAC, 0xB4, 0x6D, 0xD3, 0xAF, 0x9B, 0xFD, 0x67, 0xEC, 0x3A, 0x6A, 
+0x9E, 0x8E, 0x19, 0xA3, 0xE6, 0x19, 0x63, 0x5A, 0x94, 0x7C, 0x71, 0x2F, 0x4A, 0xD3, 0x31, 0xDA, 
+0x8E, 0x00, 0x69, 0xD2, 0xD3, 0x1A, 0xAA, 0x3D, 0x24, 0xC1, 0xF3, 0xB5, 0x3C, 0x55, 0x76, 0xCB, 
+0x05, 0xB9, 0x95, 0x2F, 0x53, 0xBC, 0x98, 0x5E, 0x26, 0xC3, 0xD7, 0x1F, 0x87, 0x18, 0x24, 0x36, 
+0x9A, 0xEE, 0x8F, 0xF7, 0xF6, 0xB8, 0x06, 0xEC, 0x07, 0x7C, 0x5E, 0x96, 0x51, 0x3F, 0x13, 0x35, 
+0x14, 0x1B, 0x67, 0x10, 0xE8, 0x28, 0xB1, 0x9E, 0xBE, 0x5B, 0xBC, 0x13, 0x48, 0x9A, 0x76, 0x2F, 
+0x84, 0xAD, 0x63, 0x2C, 0x8F, 0xBA, 0x40, 0x6C, 0xA0
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_1024_priv.pem b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_1024_priv.pem
new file mode 100644
index 000000000..0475f4f0e
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_1024_priv.pem
@@ -0,0 +1,15 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIICXAIBAAKBgQDhJp9JK6DPiKsQakhkrb/tla5J5oV4Vl9ECtU+dhZw0RUEBBU6
+077wqWgbCo/c5Alf9yftaCJUyrWyetC9YJdaFztrnfcS1QGcfIlP4ihEyH7ESfvf
+Mb8y3MYrMtxzQbKS6ZC1k/9gEMNF8+YHBPCiZy9fU6X8GzDlfo6UhRMTmwIDAQAB
+AoGATPDh5iNepQ1TSBzJ+H3X5N0N3ntEiUca7ym0jc/VA2CwCdtLVfseeSerR/Jo
+D1huS7kuj9bSRJ+xT/jgdJcZoS+L+JbYKklxO6QQzCzzixTcXvOaC1m65Gm9WS6C
+VOX8GQa404/sY9vRbL6Mt0WYKo+YqsjpzjZpzkbKFFkqzeECQQD+NfiUD9bTZtye
+Q+siOiM686B9byzZ1T5sSXUv6m0nWFS1vcdNj06UYqRZJ1CFkIZ2xFQj+0kbnG8o
+YvIg9e/nAkEA4rxKuZsjqd5cUM0A6umaqsQ0H0u8reRl3pzGVgdWV5v1GxEiBj52
+QXjnSSjQWZ13hh9M01iu4X6NpfO5w4vYLQJBAPMZCa4Nt5JSO4fdy23fyvEFKeTJ
+/EoT8q37UWWQ+PE3N0rVQVKaSLr92cyoHAiePPg2p4ABPdh5sJMejA2ZIuECQGkL
+qWcifDxoG8cHo4QyZIj3S9qwASNjbNrdMXqL/bGrPLykjGnuKGWe+TDI6vaJ4OVP
+vQ0xyhwIwOGA8LCrKqUCQHIaTOBUmjMQhQM8qjvPdyhFxIQAe8+fqFAxsX6wQy5F
+t47jVKFdnTz2a6hJK+IJSg98xMBGQxb7dHCAOhIo8IY=
+-----END RSA PRIVATE KEY-----
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_2048_cert.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_2048_cert.txt
new file mode 100644
index 000000000..2a26ef7bf
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_2048_cert.txt
@@ -0,0 +1,55 @@
+0x30, 0x82, 0x03, 0x66, 0x30, 0x82, 0x02, 0xCF, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x4E,
+0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30,
+0x3C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x49, 0x4E, 0x31, 0x0D,
+0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31, 0x1E, 0x30,
+0x1C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x15, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64,
+0x69, 0x61, 0x74, 0x65, 0x20, 0x72, 0x73, 0x61, 0x20, 0x31, 0x30, 0x32, 0x34, 0x30, 0x1E, 0x17,
+0x0D, 0x31, 0x38, 0x30, 0x36, 0x31, 0x31, 0x30, 0x37, 0x32, 0x36, 0x33, 0x39, 0x5A, 0x17, 0x0D,
+0x31, 0x39, 0x30, 0x36, 0x32, 0x31, 0x30, 0x37, 0x32, 0x36, 0x33, 0x39, 0x5A, 0x30, 0x2E, 0x31,
+0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31, 0x1D,
+0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x14, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20,
+0x63, 0x65, 0x72, 0x74, 0x20, 0x72, 0x73, 0x61, 0x20, 0x32, 0x30, 0x34, 0x38, 0x30, 0x82, 0x01,
+0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00,
+0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xDB, 0x7F,
+0xDF, 0x59, 0x6F, 0x70, 0xD8, 0x69, 0x47, 0x7B, 0xED, 0x59, 0x3B, 0xBD, 0xC1, 0x89, 0x3E, 0x94,
+0x8F, 0x6E, 0xB4, 0x38, 0x3B, 0xD4, 0x21, 0x0E, 0x8C, 0xBE, 0x8C, 0x57, 0xF3, 0x34, 0xD4, 0x9A,
+0x83, 0xC8, 0x82, 0x3D, 0x3A, 0x93, 0xC2, 0xB5, 0x90, 0x2A, 0x1D, 0x1B, 0x07, 0xEF, 0x0F, 0x14,
+0x1C, 0x3B, 0xFE, 0xE1, 0x2A, 0x11, 0xCE, 0x03, 0x00, 0x83, 0x2F, 0x7F, 0x49, 0xBC, 0xF7, 0x80,
+0x5E, 0x66, 0x6E, 0x62, 0x1B, 0x0F, 0xB1, 0xEE, 0xE7, 0x84, 0x2D, 0x3C, 0x32, 0x30, 0x7F, 0x8B,
+0x9D, 0x5E, 0x2D, 0x06, 0xE2, 0x3B, 0xD7, 0x60, 0x26, 0x37, 0xA2, 0xA7, 0xE5, 0x82, 0xC4, 0x9D,
+0x62, 0x14, 0xAA, 0xB5, 0x5D, 0xFE, 0x84, 0x56, 0xA1, 0xA3, 0x5B, 0x0E, 0xED, 0x1C, 0x34, 0x2E,
+0x29, 0xC4, 0xCB, 0x21, 0x8F, 0x18, 0xDF, 0xD9, 0x66, 0xD1, 0x7B, 0x88, 0xF2, 0x04, 0xCE, 0x0B,
+0x07, 0x03, 0xF4, 0x1B, 0xC0, 0xEE, 0x84, 0x02, 0xCA, 0xBC, 0x16, 0xA0, 0xED, 0xA0, 0xAD, 0x62,
+0xB8, 0x33, 0xED, 0x4E, 0xAF, 0xB4, 0xBA, 0xB2, 0xA2, 0x3C, 0xC5, 0x32, 0xEC, 0xFD, 0x75, 0xE7,
+0x9E, 0x49, 0xEB, 0xF6, 0xCD, 0xD1, 0x59, 0xC8, 0xD0, 0x84, 0xB7, 0xE1, 0x1C, 0x37, 0x0B, 0x22,
+0x4A, 0xC8, 0x4E, 0x12, 0x5F, 0x6A, 0x22, 0xE2, 0x1B, 0x07, 0x22, 0x0C, 0x8C, 0x48, 0xC2, 0xBC,
+0xBD, 0x63, 0xBD, 0xB4, 0xDB, 0x95, 0x0B, 0x0A, 0xE3, 0xF3, 0x88, 0x41, 0x99, 0xBA, 0x99, 0xE8,
+0x0B, 0xE2, 0xE8, 0x9F, 0xF1, 0x0B, 0xF2, 0x3C, 0xB4, 0x99, 0x5A, 0xBB, 0x44, 0x88, 0x4E, 0x2B,
+0xD5, 0x79, 0x82, 0x3E, 0x44, 0xFB, 0xCD, 0xB5, 0x11, 0x4E, 0xA9, 0xFC, 0x81, 0xE4, 0x4E, 0xB0,
+0x2C, 0x41, 0x24, 0xFD, 0xC1, 0x3B, 0x66, 0x26, 0xB2, 0xB5, 0xEE, 0x00, 0x9B, 0xFB, 0x02, 0x03,
+0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0x00, 0x30, 0x81, 0xFD, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1D,
+0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x11, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42,
+0x01, 0x01, 0x04, 0x04, 0x03, 0x02, 0x06, 0x40, 0x30, 0x33, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
+0x86, 0xF8, 0x42, 0x01, 0x0D, 0x04, 0x26, 0x16, 0x24, 0x4F, 0x70, 0x65, 0x6E, 0x53, 0x53, 0x4C,
+0x20, 0x47, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65,
+0x72, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x30, 0x1D, 0x06,
+0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x37, 0xF0, 0x38, 0xC3, 0xD4, 0x84, 0x24, 0xE0,
+0xF2, 0x35, 0x11, 0x60, 0xFD, 0x6E, 0x77, 0x87, 0x1D, 0x65, 0x45, 0xF8, 0x30, 0x64, 0x06, 0x03,
+0x55, 0x1D, 0x23, 0x04, 0x5D, 0x30, 0x5B, 0x80, 0x14, 0x82, 0xDA, 0x0A, 0xF9, 0x6A, 0x37, 0x49,
+0x71, 0xA1, 0x9E, 0x61, 0x4E, 0x46, 0xEB, 0xA9, 0x19, 0x9F, 0x59, 0xAB, 0x28, 0xA1, 0x40, 0xA4,
+0x3E, 0x30, 0x3C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x49, 0x4E,
+0x31, 0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x49, 0x46, 0x49, 0x4E, 0x31,
+0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x15, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20,
+0x61, 0x6E, 0x63, 0x68, 0x6F, 0x72, 0x20, 0x72, 0x73, 0x61, 0x20, 0x32, 0x30, 0x34, 0x38, 0x82,
+0x01, 0x4D, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02,
+0x05, 0xA0, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B,
+0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
+0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x7F, 0x64, 0xA2, 0xD4, 0xC6, 0x4A,
+0x2B, 0xBB, 0xF9, 0xC1, 0xC9, 0x81, 0xAD, 0xC6, 0x39, 0x21, 0xB4, 0xD2, 0x4E, 0x80, 0xD1, 0x6C,
+0x4C, 0xC5, 0x73, 0x12, 0x42, 0x0E, 0xE4, 0xE1, 0x66, 0xA1, 0x9A, 0xD2, 0x65, 0x93, 0x55, 0x63,
+0xC3, 0xBC, 0xFE, 0xCC, 0x08, 0x18, 0x6A, 0x9F, 0x0A, 0x1F, 0xED, 0xB7, 0xB8, 0xB9, 0x0C, 0xDE,
+0xD6, 0x46, 0x57, 0x75, 0x13, 0x93, 0xFB, 0x25, 0x05, 0x3D, 0x27, 0x27, 0xB4, 0xEE, 0x67, 0xCE,
+0x96, 0x34, 0xDE, 0x4E, 0x16, 0x5C, 0xFE, 0xD8, 0x24, 0xEB, 0xD6, 0x0B, 0x12, 0xD1, 0xEC, 0x6A,
+0xC0, 0xE6, 0x0B, 0x62, 0xE5, 0xBD, 0x9A, 0x1F, 0x73, 0x86, 0x55, 0x1A, 0xB5, 0x86, 0xCE, 0x0E,
+0x8B, 0x6E, 0x07, 0x22, 0x2C, 0x2A, 0xC7, 0xBC, 0xD4, 0x56, 0x95, 0x7C, 0x59, 0xB7, 0x78, 0x5A,
+0x20, 0xCE, 0xD0, 0x5B, 0x7A, 0x9C, 0x17, 0x41, 0x6D, 0x33,
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_2048_priv.pem b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_2048_priv.pem
new file mode 100644
index 000000000..f55d63324
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/integrity/sample_rsa_2048_priv.pem
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEogIBAAKCAQEA23/fWW9w2GlHe+1ZO73BiT6Uj260ODvUIQ6MvoxX8zTUmoPI
+gj06k8K1kCodGwfvDxQcO/7hKhHOAwCDL39JvPeAXmZuYhsPse7nhC08MjB/i51e
+LQbiO9dgJjeip+WCxJ1iFKq1Xf6EVqGjWw7tHDQuKcTLIY8Y39lm0XuI8gTOCwcD
+9BvA7oQCyrwWoO2grWK4M+1Or7S6sqI8xTLs/XXnnknr9s3RWcjQhLfhHDcLIkrI
+ThJfaiLiGwciDIxIwry9Y72025ULCuPziEGZupnoC+Lon/EL8jy0mVq7RIhOK9V5
+gj5E+821EU6p/IHkTrAsQST9wTtmJrK17gCb+wIDAQABAoIBAEbflhWBpzUpYTyB
+mcNxdNFE1KEvhJ93qfn2gblxBWDxGQi/LnnnHUfioc9n2bgFqsn6m1c/6CI2V4ee
+nb0zY3LRk7BncJLa3Al+82A5Xutxv20sJeFyDJB37YLJigqeT8f+bVHxANjVupNi
+Y6WePy9RJeq0sUYnt0doIgvX0JMcIvhUF0jtWzowju73LWZS9xRlBibBVFj/l8Hn
+iTP0Y674Ll5Gb3IiJNRuXD0u9ryXhfobFiQfn0wvehuar6H5T8s/++6RdEVPsPos
+qtx0pP58J0iaY0u5Gd1smcNTzRjDaC9E3uIIFJrgrU/h1RcZHTH+Z8WHu5y38dxz
+3J94dLkCgYEA75JbioYQFiruCOOmZcVA7/Cmsi3OWXdY2MW9uJ3NfBLbKw0eUtlg
+KiiHRJvUvIyYGRUYXZfyMXae39sG73A8K5qG6bfMbY96zYHkfU7FT4LTPI6QNdEr
+n7LJSTLed1Y5ZKjNIXk7FxNH7KcDpu/+kd/BdMh2moKnkTeuUdT8tP8CgYEA6o0m
+iX7UV58vtm1kcVCVJLCJ6Hvi8JhIUs2g6a8mV/2iw/DwM57IPccoG+cCehXRXKlE
+2c1kemlD++wCPUXWzPqILIK7o54sh1U5UybZUOTt1UD7yiSTV95yFiYFmxBhpvQ+
+EWwFSeo/yHsktfmgPn62dxBbPP+BWf3je/l/7QUCgYAnBryK0FQGiG/GWu9cXMm7
+TISbOgMHZ/29Mlk5nds/fwLc/IIYFPkpZPjEIG6DWJPeYiVZ+cqmbCBtbwyuLKZg
+pAeeQya2Ik1q9OH318Ektrcagk7TtYNZvJI1rme3IQCweR8ReOI7XBS3ZG2f4DCk
+KsMk9xL7EJWjfmKTShLwmQKBgGyiZ6DzP0I+Fok17XmWSx2tLpKhHqE0xvqjBs51
+Mxs5/HMoWvhtqG0Emw0hV8JX7JowRBVkzg7sRnKeAwOCH1TdDMkg2+uSTSl5TY23
+xptzDLzi1jvv6NafztN3VM1XLwN2yHClSWXMuzIN5xjpv1Byu+w1hSyhYrXdo8k9
+7ARJAoGAGot7vEgIXZwd6B39Uzy52TQDKBs46Lplrb9auK7zSw2X+S8l2QdgwwX0
+2hEa1WmB3gXeGs81l7fK+5rWYBP7xKoDHrJROYBivebg0GW6ORSeG50v6bmjVQu3
+puFtZ7gK4h7k9mVU+a2TPR0k2vIIZEn68RoFBwsH6hzoCnSfSA8=
+-----END RSA PRIVATE KEY-----
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/data/ascii_data.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/data/ascii_data.txt
new file mode 100644
index 000000000..246eda126
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/data/ascii_data.txt
@@ -0,0 +1,11 @@
+line1 : This is a sample payload to demonstrate the protected update data set generator.
+line2 : This is a sample payload to demonstrate the protected update data set generator.
+line3 : This is a sample payload to demonstrate the protected update data set generator.
+line4 : This is a sample payload to demonstrate the protected update data set generator.
+line5 : This is a sample payload to demonstrate the protected update data set generator.
+line6 : This is a sample payload to demonstrate the protected update data set generator.
+line7 : This is a sample payload to demonstrate the protected update data set generator.
+line8 : This is a sample payload to demonstrate the protected update data set generator.
+line9 : This is a sample payload to demonstrate the protected update data set generator.
+
+
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/data/hex_data.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/data/hex_data.txt
new file mode 100644
index 000000000..e199134b4
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/data/hex_data.txt
@@ -0,0 +1,19 @@
+6c696e6531203a205468697320697320
+612073616d706c65207061796c6f6164
+20746f2064656d6f6e73747261746520
+7468652070726f746563746564207570
+64617465206461746120736574206765
+6e657261746f722e0a6c696e6532203a
+205468697320697320612073616d706c
+65207061796c6f616420746f2064656d
+6f6e737472617465207468652070726f
+74656374656420757064617465206461
+7461207365742067656e657261746f72
+2e0a6c696e6533203a20546869732069
+7320612073616d706c65207061796c6f
+616420746f2064656d6f6e7374726174
+65207468652070726f74656374656420
+75706461746520646174612073657420
+67656e657261746f722e0a6c696e6534
+203a205468697320697320612073616d
+706c65207061796c6f616420746f2064
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_128.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_128.txt
new file mode 100644
index 000000000..00a310c1b
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_128.txt
@@ -0,0 +1 @@
+22385ea7eb6194b9d7ffd41ca56834d3
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_192.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_192.txt
new file mode 100644
index 000000000..63ba0a8ca
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_192.txt
@@ -0,0 +1,2 @@
+a2f9fab4814f6806423f6fc621d02e10
+a2f9fab4814f6806
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_256.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_256.txt
new file mode 100644
index 000000000..feed9505a
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/aes_key_256.txt
@@ -0,0 +1,2 @@
+a2f9fab4814f6806423f6fc621d02e10
+a2f9fab4814f6806423f6fc621d02e10
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_1024_test.pem b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_1024_test.pem
new file mode 100644
index 000000000..55fe4410e
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_1024_test.pem
@@ -0,0 +1,15 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIICWwIBAAKBgQCNjP4xKrKQ/X9KweDa9igv0syvmdK7iiCvWkmyG2BVPq0mEsPV
+0t8S3v93bCOZkD90iKcpzfwMdkqIBmuuucUWXBX7ScEQqSTXj0GDXNdjR2qgeIG7
+pGaUK1DKH/d+VLKvQ5tZK66r93lx8ktk/LuGZ3B1RHQLzl9QBaUSh8156QIDAQAB
+AoGAR2aRafehryVPqkP1yj1UtBrfCMzM0bCxIAKpHeBVTWqaKJRamGcQAxLdRj4U
+DwgGGiA8QggXVantmoOymaY3VXktb+KsI86uQzcS35t/H5InFBMp6wMCIzVF8bHN
+jICaRo4RRsim2qHc9tlqhpAq2BHIMV9LurwpqsdOSR5Q5yECQQDQvI07LPgPgyq8
++wmXVAqccLTxfWJnYQGCyznlU5JqykLjpr2OKaCwmzen21FqetBYzLtvShocmp5c
+vmN4Eb5dAkEArZoBoAaEZ76Pldc4eLffhuJkYLsa1I/wvI3fd59F1eBAkoJopSR/
+cjzGp6ocIXlpH7CSa3stlkolbK0A5SA4/QJABGOSjKX7aUgWw/Z7UyU/O97azyEV
+ypqtj3R6eSnysDAki+jbn3ucl1oMJ4ljAtwmOVfEsShbuDJAFi8ipEmrOQJASgNf
+7/73UlfPVb31aJpUJWi+DPOYg8l+hJUkEhcIqh+6x/vra4T9BRJeS7td1POzWvxn
+4IUasXmZLRUxTX6IbQJANWtmC9cYYc5BNUTs6C+M4JPvu3JAssV1MO3M2WKQfI+D
+9SL5vojE4qfj1PoNXRfcJmyXz2DWCClDkF+aX+6xdw==
+-----END RSA PRIVATE KEY-----
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_1024_test.pem1 b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_1024_test.pem1
new file mode 100644
index 000000000..20817d3ef
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_1024_test.pem1
@@ -0,0 +1,15 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIICXQIBAAKBgQDPr/zMYfAZJY0IacRehXsuyb0A8EcBz4t6hZ6zYlCCK/SmUHuQ
+1PZBwsfU9siu+2BlxC2X1c1nRVUZmsl0r9Sx9Sn/zXVE+l72Jand/1g5F6QOEisQ
+y+97or8qgiE5cos2nSszuNQzltqPo0c71swXp4vyPNY9L6amFuz1dovLzwIDAQAB
+AoGAK/uSJtpq1Xh9WJXFj1rnTm5Mx4EbGIgSer0HcefVMuwKIJqUwIRJLn4IgdJN
+h7kWnhagrTILEN6++fAsz7hY64FUq3Qq8WxsyzMmWTubNMPRHt2i2ulZdkhdchjD
+C/kZwYOGJkRTRW9PjXAznWW5Ne+XrTUnHjBKOg0r2btimlkCQQDspq49sOmLVZum
+GNaJhopPJw28ZL4KB3vj4/QMymBIAmGXZv2PVE/sRuA4J21H2SqCiVKPS9ulaMIL
+tD9ELWxTAkEA4KsSY9eCwIEyzjAhOpojOhNVwkrlk7G9fmn87JWagVxZfYS6LwE2
+azyOF7bhQWmusWc+4YgIPVYaW38eWiFTFQJBAIRF2ghDVRZ7QCeDpI5z8+SwCH5v
+tMT4T+gd5rArgcteAVxVxY4SayW+q97XMr7BBIC37ryHgvqeZi+SjPY3iV8CQQCV
+TRpLf0xE4ZcBrrpmV0hRr8et9lfabqOe/pA2KLUkglp2L14LHqMrYHKND9thvPl6
+q0H+XogbOr0JUNC61KqBAkAGk55LBl4fxP5euUQCmntcgJrxW0WpoXxAwuj0og96
+bhFDaFsu/sc63xlqGppxRAybrXPRp/lgZy4BjPudl4uF
+-----END RSA PRIVATE KEY-----
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_2048_test.pem b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_2048_test.pem
new file mode 100644
index 000000000..206408756
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/key/rsa_2048_test.pem
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpQIBAAKCAQEAuC4L9iVlEOTJHgfwHA2anoDtdPkKfKuU3nqPw3z1F1otB9d0
+yTnSp0OVgKDDyfHuOiJQsl9eQNKE1Yn63k72oejZ3TcjHvGrVjp+CXkZp9V3pFUR
+f3JmjDHpQ82Uujj0BW3b0qTgms4dgla2OqKJnRJmOZttDetGcweGjw9hmBbGYZ/N
+I/5YYYlOSz1hRePhrkfKoC0Sgk5mDC5oGuNqcXMeiAaHtMOPvmNbzAotMOgCwxUt
+IHDrNiT9VXy+AdnWwHaAlK4r02sg7XU8jvucYIFh8yRA2OmJOT9Q0NOyV1xT/9cI
+mGBchEK8AoObEKgsIzfmZzjwu6lxa0c2iMFgCQIDAQABAoIBAAnN3LHkhXPf4+NS
++5l4sWp+1TUY9TGT/iOWLV00A4Vz1coRMmysRO4Fs1mCpU10kRB752UJXdZwRmUq
+GEY5eJg/kYpcryRMa8kWKcOmFEMqgjkHlLv+ql4L4Z2L/d7oXXgFBDK7N2ASOQCp
+Tj/Ci3YGptWp9AUNyUUiCUwH/vNWKrhCSnDw39/2syjvW8oXpWoC55ln5EnP219B
+W8IrT7I87oqwajyezJ+Eu4MSDEP6nq979s6DkeRGNufv0U8yyuRgvacKxBfVgnZO
+4V4l1eZYcCmXh5LV9iyOlhYCfg0mT2HcZYvTRNfnDGrlDB9IEEYGkjCf0S+XXvM+
+9dlhRSECgYEA9tAU+wJhukawWmlJLnsnt7gl0eBu6fiVNRxU+x828qRq9//VdxB6
+u4sqMyaIs9Zjl8UTKG2vIDKu9mGmJrecwzVKngA/3gbNKWvnujTmUMP8DsV7pWpK
+qrvgHCD/IhXwi8ZapRAiqoYZfhRWfeZxI1i5tFCvPN+fJgWrSFIjxyECgYEAvwkg
+JXdhbkNP0kXz9jgfsjEI1vF6SOJbf0gXgVzct4drlH6G3yAFaQfknK+gw85gYCks
+M1C83XPtsut01Daz1mB/5TNmMcwFwI6LLPPIqdQ19mBS0ka1LSKED235V2bwL+/A
+/SPG868edXmczuqPti8/bfr7kVJtfBYGQMwjw+kCgYEAuPTGRDRMuCMxFQ/BX6u6
+39qHvPfLJlq6tco9hNKngr3jy2VUup0G3HQ1c4908g+/IoT1Dl7j1eUlaE1VDb6b
+I05UVIMrWV8Pb/ME/G2YCv5TbV5ggl1dBwUztOClUQ3P7W7/jqLA17kWcX0cM8z1
+C9/5ij7Mk3mg8gVdjhy/4wECgYEAgJVT3eQM4HrOL2qGWyRLsVTv7j17YbN6gqGz
+sI8gwSeVcc34WhbjjV6SsiREwYcXt6H+7ktZ1HVDeTqi2HQ5eAJcE5oVH0+ET6ei
+Zg9w8V61M7CCDqcpK8gfu4L6YaoX4SwvajO6pispBUlmEqAvOyFyQES/L4Gbz/nD
+G7pMGIECgYEA6HtxcAA5vfa15XdqSjDrFdVqNefX4YAKaeONAW1ezF0i4nLqHGwn
+QAqfaanOspzWpa8W1v4zFtzm60rcVfiacqczflYIsXSwaUXac4GFT9r+qecnqWNi
+a0SlYQlpexQASdWqHYxfOkxSK8WBan/t7y6Mwv9l/YQBKw70MApG4cs=
+-----END RSA PRIVATE KEY-----
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/metadata/metadata.txt b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/metadata/metadata.txt
new file mode 100644
index 000000000..73865d6c7
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/samples/payload/metadata/metadata.txt
@@ -0,0 +1 @@
+200BC00103D10100D003E1FC07
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/cbor.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/cbor.c
new file mode 100644
index 000000000..c97873454
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/cbor.c
@@ -0,0 +1,158 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file cbor.c
+*
+* \brief   This file implements APIs, types and data structures used for cbor format coding.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#include "cbor.h"
+#include "common_utilites.h" 
+
+#define CBOR_MAJOR_TYPE_0                   (0x00)
+#define CBOR_MAJOR_TYPE_1                   (0x20)
+#define CBOR_MAJOR_TYPE_2                   (0x40)
+//lint --e{750} suppress "macro kept as per cbor standard for future use"
+#define CBOR_MAJOR_TYPE_3                   (0x60)
+#define CBOR_MAJOR_TYPE_4                   (0x80)
+#define CBOR_MAJOR_TYPE_5                   (0xA0)
+#define CBOR_MAJOR_TYPE_7                   (0xF6)
+
+#define CBOR_ADDITIONAL_TYPE_0x17           (0x17)
+#define CBOR_ADDITIONAL_TYPE_0x18           (0x18)
+#define CBOR_ADDITIONAL_TYPE_0x19           (0x19)
+#define CBOR_ADDITIONAL_TYPE_0x1A           (0x1A)
+
+static int32_t cbor_encode_data(uint8_t * buffer, uint32_t value, uint16_t * offset, uint8_t major_type)
+{
+    int32_t status = 0;
+    if (CBOR_ADDITIONAL_TYPE_0x17 >= value)
+    {
+        buffer[*offset] = (uint8_t)(major_type | value);
+        (*offset)++;
+    }
+    else if ((CBOR_ADDITIONAL_TYPE_0x17 < value) && (0xFF >= value))
+    {
+        buffer[*offset] = (major_type | CBOR_ADDITIONAL_TYPE_0x18);
+        (*offset)++;
+        buffer[*offset] = (uint8_t)value;
+        (*offset)++;
+    }
+    else if ((0xFF < value) && (0xFFFF >= value))
+    {
+        buffer[*offset] = (major_type | CBOR_ADDITIONAL_TYPE_0x19);
+        (*offset)++;
+        protected_tool_common_set_uint16(&buffer[*offset], offset, (uint16_t)value);
+    }
+    else if (0xFFFF < value)
+    {
+        buffer[*offset] = (major_type | CBOR_ADDITIONAL_TYPE_0x1A);
+        (*offset)++;
+        protected_tool_common_set_uint32(&buffer[*offset], offset, value);
+    }
+    else
+    {
+        status = -1;
+    }
+    return status;
+
+}
+
+int32_t cbor_set_null(uint8_t * buffer, uint16_t * offset)
+{
+    buffer[*offset] = CBOR_MAJOR_TYPE_7;
+    *offset += 1;
+    return 1;
+}
+
+int32_t cbor_set_array_of_data(uint8_t * buffer,uint32_t value ,uint16_t * offset)
+{
+    buffer[*offset] = (CBOR_MAJOR_TYPE_4 | (uint8_t)value);
+    *offset += 1;
+    return 1;
+}
+
+int32_t cbor_set_unsigned_integer(uint8_t * buffer, uint32_t value, uint16_t * offset)
+{
+    return (cbor_encode_data(buffer, value, offset, CBOR_MAJOR_TYPE_0));
+}
+
+//lint --e{702, 737} suppress "Shifting an int value"
+int32_t cbor_set_signed_integer(uint8_t * buffer, int32_t value, uint16_t * offset)
+{
+    /* adapted from code in RFC 7049 appendix C (pseudocode) */
+    uint32_t temp_value = (value >> 31);              /* extend sign to whole length */
+    temp_value ^= value;                            /* complement negatives */
+    return (cbor_encode_data(buffer, temp_value, offset, CBOR_MAJOR_TYPE_1));
+}
+
+int32_t cbor_set_byte_string(uint8_t * buffer, uint32_t value, uint16_t * offset)
+{
+    return (cbor_encode_data(buffer, value, offset, CBOR_MAJOR_TYPE_2));
+}
+
+void cbor_set_map_tag(uint8_t * buffer, uint8_t map_number, uint16_t * offset)
+{
+    (void)cbor_encode_data(buffer, map_number, offset, CBOR_MAJOR_TYPE_5);
+}
+
+int32_t cbor_set_map_unsigned_type(uint8_t * buffer, uint32_t key_data_item, uint32_t value_data_item, uint16_t * offset)
+{
+    (void)cbor_set_unsigned_integer(buffer, key_data_item, offset);
+    (void)cbor_set_unsigned_integer(buffer, value_data_item, offset);
+    return 1;
+}
+
+int32_t cbor_set_map_signed_type(uint8_t * buffer, uint32_t key_data_item, int32_t value_data_item, uint16_t * offset)
+{
+    (void)cbor_set_unsigned_integer(buffer, key_data_item, offset);
+    (void)cbor_set_signed_integer(buffer, value_data_item, offset);
+    return 1;
+}
+
+int32_t cbor_set_map_byte_string_type(uint8_t * buffer, uint32_t key_data_item, const uint8_t * value_data_item, uint16_t value_data_item_len, uint16_t * offset)
+{
+    uint16_t index;
+
+    (void)cbor_set_unsigned_integer(buffer, key_data_item, offset);
+    (void)cbor_set_byte_string(buffer, value_data_item_len, offset);
+    for(index = 0; index < value_data_item_len; index++)
+    {
+        buffer[*offset] = *(((uint8_t *)value_data_item) + ((value_data_item_len - index) - 1));
+        (*offset)++;
+    }
+    return 1;
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/common_utilities.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/common_utilities.c
new file mode 100644
index 000000000..1dcf5ec36
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/common_utilities.c
@@ -0,0 +1,81 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file common_utilities.c
+*
+* \brief   This file implements commonly used functions.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+void protected_tool_common_set_uint16 (uint8_t * p_output_buffer,uint16_t * offset,uint16_t two_byte_value)
+{
+    *p_output_buffer = (uint8_t)(two_byte_value >> 8);
+    (*offset)++;
+    *(p_output_buffer + 1) = (uint8_t)(two_byte_value);
+    (*offset)++;
+}
+
+void protected_tool_common_set_uint24 (uint8_t * p_output_buffer,uint16_t * offset, uint32_t three_byte_value)
+{
+    *p_output_buffer = (uint8_t)(three_byte_value >> 16);
+    (*offset)++;
+    *(p_output_buffer + 1)= (uint8_t)(three_byte_value >> 8);
+    (*offset)++;
+    *(p_output_buffer + 2) = (uint8_t)(three_byte_value);
+    (*offset)++;
+}
+
+void protected_tool_common_set_uint32 (uint8_t* p_output_buffer, uint16_t * offset, uint32_t four_byte_value)
+{
+    *(p_output_buffer) = (uint8_t)(four_byte_value >> 24);
+    (*offset)++;
+    *(p_output_buffer + 1) = (uint8_t)(four_byte_value >> 16);
+    (*offset)++;
+    *(p_output_buffer + 2) = (uint8_t)(four_byte_value >> 8);
+    (*offset)++;
+    *(p_output_buffer + 3) = (uint8_t)(four_byte_value);
+    (*offset)++;
+}
+
+void protected_tool_common_set_uint16_without_offset (uint8_t * p_output_buffer, uint16_t two_byte_value)
+{
+    *p_output_buffer = (uint8_t)(two_byte_value >> 8);
+    *(p_output_buffer + 1) = (uint8_t)(two_byte_value);
+}
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/protected_update_data_set.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/protected_update_data_set.c
new file mode 100644
index 000000000..d4fb2d380
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/protected_update_data_set.c
@@ -0,0 +1,1149 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file protected_update_data_set.c
+*
+* \brief   This file implements APIs, types and data structures used for protected update data set creation.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>    
+#include "pal\pal_logger.h"
+#include "protected_update_data_set.h"
+#include "pal\pal_crypt.h"
+#include "cbor.h"
+#include "pal\pal_os_memory.h"
+#include "common_utilites.h" 
+
+#define PROTECT_UPDATE_MANIFEST_VERSION             (1U)
+
+#define TAG_SIZE                                    (1U)
+#define LENGTH_SIZE                                 (2U)
+#define ECC_P_256_PRIVATE_KEY_SIZE                  (32U)
+#define ECC_P_256_X_Y_KEY_SIZE                      (32U)
+#define ECC_P_256_PUBLIC_KEY_SIZE                   (64U)
+#define ECC_P_384_PRIVATE_KEY_SIZE                  (48U)
+#define ECC_P_384_X_Y_KEY_SIZE                      (48U)
+#define ECC_P_384_PUBLIC_KEY_SIZE                   (96U)
+#define ECC_P_512_PRIVATE_KEY_SIZE                  (64U)
+#define ECC_P_512_X_Y_KEY_SIZE                      (64U)
+#define ECC_P_512_PUBLIC_KEY_SIZE                   (128U)
+#define ECC_P_521_PRIVATE_KEY_SIZE                  (66U)
+#define ECC_P_521_X_Y_KEY_SIZE                      (66U)
+#define ECC_P_521_PUBLIC_KEY_SIZE                   (132U)
+#define ECC_PRIVATE_KEY_TAG                         (1U)
+#define ECC_PUBLIC_KEY_TAG                          (2U)
+#define AES_128_KEY_LENGTH                          (16U)
+#define AES_128_KEY_TAG                             (1U)
+#define AES_192_KEY_LENGTH                          (24U)
+#define AES_256_KEY_LENGTH                          (32U)
+#define RSA_PRIVATE_EXPONENT_TAG                    (1U)
+#define RSA_MODULUS_TAG                             (2U)
+#define RSA_PUBLIC_EXPONENT_TAG                     (3U)
+#define RSA_1024_PUBLIC_EXPONENT_SIZE               (4U)
+#define RSA_1024_PRIVATE_EXPONENT_SIZE              (128U)
+#define RSA_1024_MODULUS_SIZE                       (128U)
+#define RSA_2048_PUBLIC_EXPONENT_SIZE               (4U)
+#define RSA_2048_PRIVATE_EXPONENT_SIZE              (256U)
+#define RSA_2048_MODULUS_SIZE                       (256U)
+
+// This will be replaced by code
+const int8_t signature_string[] = "Signature1";
+uint8_t  signature_header[25];
+
+uint8_t  local_manifest_buffer[550];
+extern uint8_t * dataset_file_path;
+
+// Prints protected update manifest and fragment to console
+static void protected_update_print_output_to_console(const protected_update_data_set_d * p_cbor_manifest)
+{
+    uint16_t  count = p_cbor_manifest->data_length;
+    uint16_t  index;
+    uint16_t  fragment_length;
+    uint8_t fragment_number;
+    int8_t buffer[100] = {0};
+
+    // Print manifest
+    sprintf(buffer, "Manifest Data , size : [%03d]\n\t", p_cbor_manifest->data_length );
+    pal_logger_print_message(buffer);
+    pal_logger_print_variable_name((uint8_t  *)"manifest_data", 0);
+
+    for (index = 0; index < count; index++)
+    {
+        pal_logger_print_byte(p_cbor_manifest->data[index]);
+        sprintf(buffer, "0x%02X, ", p_cbor_manifest->data[index] );
+
+        if (0 == ((index + 1)) % 16)
+        {
+            pal_logger_print_message("\n\t");
+        }
+    }
+    pal_logger_print_variable_name(NULL,0);
+    pal_logger_print_message("");
+
+    // Print fragment
+    count = p_cbor_manifest->fragments_length;
+    memset(buffer, 0x00, sizeof(buffer));
+
+    for (index = 0; index < count; index++)
+    {
+        if ((index % MAX_PAYLOAD_SIZE) == 0)
+        {
+            fragment_length = (p_cbor_manifest->fragments_length - index );
+            fragment_length = (fragment_length > MAX_PAYLOAD_SIZE) ? MAX_PAYLOAD_SIZE : fragment_length;
+
+            if (0 != index)    
+            { 
+                pal_logger_print_variable_name(NULL, 0);
+            }
+            sprintf(buffer, "\n\nFragment number:[%02d], size:[%03d]\n\t", ((uint8_t)(index / MAX_PAYLOAD_SIZE)+1), fragment_length);
+            pal_logger_print_message(buffer);
+            pal_logger_print_variable_name((uint8_t  *)"fragment", (uint8_t )(index / MAX_PAYLOAD_SIZE) + 1);
+            fragment_number = (uint8_t )(index / MAX_PAYLOAD_SIZE) + 1;  
+            sprintf(buffer, "uint8_t fragment_%02d[] = \n\t{\n\t", fragment_number);
+        }
+        pal_logger_print_byte(p_cbor_manifest->fragments[index]);
+        sprintf(buffer, "0x%02X, ", p_cbor_manifest->fragments[index] );
+
+        if (0 == ((index + 1)) % 16)
+        {
+            pal_logger_print_message("\n\t");
+        }
+    }
+    if (count == index)    
+    { 
+        pal_logger_print_variable_name(NULL, 0);
+    }
+}
+
+// Prints protected update manifest and fragment to file
+static void protected_update_print_output_to_file(const protected_update_data_set_d * p_cbor_manifest)
+{
+    uint16_t  count = p_cbor_manifest->data_length;
+    uint16_t  index;
+    uint16_t  fragment_length = 0;
+    uint8_t fragment_number = 0;
+    int8_t buffer[100] = {0};  
+
+    // print manifest to file
+    pal_logger_print_to_file("\tuint8_t manifest_data[] = \n\t{\n\t\t", 0);
+
+    for (index = 0; index < count; index++)
+    {
+        sprintf(buffer, "0x%02X, ", p_cbor_manifest->data[index] );
+        pal_logger_print_to_file(buffer, 0);
+
+        if (0 == ((index + 1)) % 16)
+        {
+            pal_logger_print_to_file("\n\t\t", 0);
+        }
+    }
+    pal_logger_print_to_file("\n\t};\n", 0);
+
+    // print fragment to file
+    count = p_cbor_manifest->fragments_length;
+    memset(buffer, 0x00, sizeof(buffer));
+    for (index = 0; index < count; index++)
+    {
+        if ((index % MAX_PAYLOAD_SIZE) == 0)
+        {
+            fragment_length = (p_cbor_manifest->fragments_length - index );
+            fragment_length = (fragment_length > MAX_PAYLOAD_SIZE) ? MAX_PAYLOAD_SIZE : fragment_length;
+
+            if (0 != index)    
+            { 
+                pal_logger_print_to_file("};\n", 0);
+            }
+            pal_logger_print_to_file("\n", 0);
+            fragment_number = (uint8_t )(index / MAX_PAYLOAD_SIZE) + 1;  
+            sprintf(buffer, "\tuint8_t fragment_%02d[] = \n\t{\n\t\t", fragment_number);
+            pal_logger_print_to_file(buffer, 0);
+        }
+        sprintf(buffer, "0x%02X, ", p_cbor_manifest->fragments[index] );
+        pal_logger_print_to_file(buffer, 0);
+
+        if (0 == ((index + 1)) % 16)
+        {
+            pal_logger_print_to_file("\n\t\t", 0);
+        }
+    }
+    if (count == index)    
+    { 
+        pal_logger_print_to_file("\n\t};", 0);
+    }
+}
+
+// Prints protected update manifest and fragment 
+void protected_update_print_output_dataset(const protected_update_data_set_d * p_cbor_manifest)
+{
+    // prints to console by default
+    protected_update_print_output_to_console(p_cbor_manifest);
+
+    // if the file path is provided then print to file
+    if (NULL != dataset_file_path)
+    {
+        protected_update_print_output_to_file(p_cbor_manifest);
+    }
+}
+
+//Decodes ECC signature compoenents
+_STATIC_H int32_t protected_update_decode_ecc_signature(   const uint8_t  * in_signature,
+                                                    uint8_t  * out_signature,
+                                                    uint16_t  sign_len)
+{
+    uint16_t  offset = 3;
+    uint8_t  round = 0;
+    uint16_t  out_index = 0;
+    uint16_t  length_to_copy = 0;
+    uint16_t  r_s_comp_length = sign_len/2;
+
+    // if the sign len is greater than 0x7F and length is represented in 2 bytes
+    if (0x7F < sign_len)
+    {
+        offset++;
+    }
+
+    while (round < 2)
+    {
+        // if compoenents are negative
+        if (*(in_signature + offset) == (r_s_comp_length + 1))
+        {
+            length_to_copy = r_s_comp_length;
+            offset+=2;
+        }
+        // if compoenents are less than key size
+        else if (*(in_signature + offset) < r_s_comp_length)
+        {
+            length_to_copy = *(in_signature + offset);
+            offset++;
+            out_index += (uint16_t )(r_s_comp_length - length_to_copy);
+        }
+        else
+        {
+            offset++;
+            length_to_copy = r_s_comp_length;
+        }
+
+        memcpy( out_signature + out_index,
+                in_signature + offset,
+                length_to_copy);
+
+        offset += (uint16_t )(length_to_copy + 1);
+        out_index += (uint16_t )length_to_copy;
+        round++;
+    } ;
+
+    return 0;
+}
+
+_STATIC_H int32_t protected_update_get_ecc_key_size(const manifest_t * manifest_data,void * p_key_size, uint32_t * key_size)
+{
+    int32_t status = -1;
+    ecc_key_t ecc_key = {0x00};
+    uint16_t pub_key_length = 0;
+    ecc_key.D_length = manifest_data->p_key_payload->key_params.ecc_key.D_length;
+
+    switch (ecc_key.D_length)
+    {
+        case ECC_P_256_PRIVATE_KEY_SIZE:
+            ecc_key.X_length = ECC_P_256_X_Y_KEY_SIZE;
+            ecc_key.Y_length = ECC_P_256_X_Y_KEY_SIZE;
+            pub_key_length = ECC_P_256_PUBLIC_KEY_SIZE;
+            break;
+
+        case ECC_P_384_PRIVATE_KEY_SIZE:
+            ecc_key.X_length = ECC_P_384_X_Y_KEY_SIZE;
+            ecc_key.Y_length = ECC_P_384_X_Y_KEY_SIZE;
+            pub_key_length = ECC_P_384_PUBLIC_KEY_SIZE;
+            break;
+
+        case ECC_P_512_PRIVATE_KEY_SIZE:
+            ecc_key.X_length = ECC_P_512_X_Y_KEY_SIZE;
+            ecc_key.Y_length = ECC_P_512_X_Y_KEY_SIZE;
+            pub_key_length = ECC_P_512_PUBLIC_KEY_SIZE;
+            break;
+
+        case ECC_P_521_PRIVATE_KEY_SIZE:
+            ecc_key.X_length = ECC_P_521_X_Y_KEY_SIZE;
+            ecc_key.Y_length = ECC_P_521_X_Y_KEY_SIZE;
+            pub_key_length = ECC_P_521_PUBLIC_KEY_SIZE;
+            break;
+
+        default:
+            break;
+    }
+
+    if (ecc_key.X_length && ecc_key.Y_length)
+    {
+        if ((ecc_key.D_length >= manifest_data->p_key_payload->key_params.ecc_key.D_length) &&
+            (ecc_key.X_length >= manifest_data->p_key_payload->key_params.ecc_key.X_length) &&
+            (ecc_key.Y_length >= manifest_data->p_key_payload->key_params.ecc_key.Y_length))
+        {
+            *key_size = (TAG_SIZE + LENGTH_SIZE + ecc_key.D_length);
+            ((ecc_key_t *)p_key_size)->D_length = ecc_key.D_length;
+            // if public key is available
+            if ((NULL != manifest_data->p_key_payload->key_params.ecc_key.X) &&
+                (NULL != manifest_data->p_key_payload->key_params.ecc_key.Y))
+            {
+                *key_size += (TAG_SIZE + LENGTH_SIZE + pub_key_length);
+                ((ecc_key_t *)p_key_size)->X_length = ecc_key.X_length;
+                ((ecc_key_t *)p_key_size)->Y_length = ecc_key.Y_length;
+                status = 0;
+            }        
+        }
+    }
+
+    return status;
+}
+
+_STATIC_H int32_t protected_update_get_rsa_key_size(const manifest_t * manifest_data,void * p_key_size, uint32_t * key_size)
+{
+    int32_t status = -1;
+    rsa_key_t rsa_key = {0x00};
+    rsa_key.D_length = manifest_data->p_key_payload->key_params.rsa_key.D_length;
+
+    switch (rsa_key.D_length)
+    {
+        case RSA_1024_PRIVATE_EXPONENT_SIZE:
+            rsa_key.E_length = RSA_1024_PUBLIC_EXPONENT_SIZE;
+            rsa_key.N_length = RSA_1024_MODULUS_SIZE;
+            break;
+
+        case RSA_2048_PRIVATE_EXPONENT_SIZE:
+            rsa_key.E_length = RSA_2048_PUBLIC_EXPONENT_SIZE;
+            rsa_key.N_length = RSA_2048_MODULUS_SIZE;
+            break;
+
+        default:
+            break;
+    }
+
+    if (rsa_key.E_length && rsa_key.N_length)
+    {
+        if ((manifest_data->p_key_payload->key_params.rsa_key.D_length <= rsa_key.D_length) &&
+            (manifest_data->p_key_payload->key_params.rsa_key.E_length <= rsa_key.E_length) &&
+            (manifest_data->p_key_payload->key_params.rsa_key.N_length <= rsa_key.N_length))
+            {
+                *key_size = TAG_SIZE + LENGTH_SIZE + rsa_key.E_length + TAG_SIZE +
+                                LENGTH_SIZE + rsa_key.D_length + TAG_SIZE + LENGTH_SIZE + rsa_key.N_length;
+                ((rsa_key_t *)p_key_size)->D_length = rsa_key.D_length;
+                ((rsa_key_t *)p_key_size)->E_length = rsa_key.E_length;
+                ((rsa_key_t *)p_key_size)->N_length = rsa_key.N_length;
+                status = 0;
+            }
+    }
+
+    return status;
+}
+
+_STATIC_H int32_t protected_update_get_aes_key_size(const manifest_t * manifest_data,void * p_key_size, uint32_t * key_size)
+{
+    int32_t status = -1;
+    aes_key_t aes_key = {0x00};
+    aes_key.key_length = manifest_data->p_key_payload->key_params.aes_key.key_length;
+
+    switch (aes_key.key_length)
+    {
+        case AES_128_KEY_LENGTH:
+        case AES_192_KEY_LENGTH:
+        case AES_256_KEY_LENGTH:
+            break;
+
+        default:
+            break;
+    }
+
+    if (aes_key.key_length)
+    {
+        *key_size = aes_key.key_length + TAG_SIZE + LENGTH_SIZE;
+        ((aes_key_t *)p_key_size)->key_length = aes_key.key_length;
+        status = 0;
+    }
+
+    return status;
+}
+
+_STATIC_H int32_t protected_update_get_key_size(const manifest_t * manifest_data,void * p_key_size, uint32_t * key_size)
+{
+    int32_t status = -1;
+
+    switch (manifest_data->p_key_payload->key_type)
+    {
+        case eECC:
+                status = protected_update_get_ecc_key_size(manifest_data, p_key_size, key_size);
+                if (0 != status)
+                {
+                    pal_logger_print_message(" Error : Incorrect ECC key \n");
+                }
+                break;
+
+        case eRSA:
+                status = protected_update_get_rsa_key_size(manifest_data, p_key_size, key_size);
+                if (0 != status)
+                {
+                    pal_logger_print_message(" Error : Incorrect RSA key \n");
+                }
+                break;
+
+        case eAES:
+                status = protected_update_get_aes_key_size(manifest_data, p_key_size, key_size);
+                if (0 != status)
+                {
+                    pal_logger_print_message(" Error : Incorrect AES key \n");
+                }
+                break;
+
+        default:
+                status = -1;
+    }
+
+    return status;
+}
+
+_STATIC_H void protected_update_form_key_payload_tlv_format(uint8_t  * payload_buffer,
+                                                         const uint8_t  * key_buffer,
+                                                         uint32_t * offset,
+                                                         uint32_t tag_value,
+                                                         uint32_t user_key_length,
+                                                         uint32_t max_key_length)
+{
+    payload_buffer[(*offset)++] = (uint8_t )tag_value;
+    protected_tool_common_set_uint16_without_offset(&payload_buffer[*offset],(uint16_t )max_key_length);
+    *offset = *offset + LENGTH_SIZE;
+    // Check if padding is needed
+    if (user_key_length < max_key_length)
+    {
+        *offset = (*offset) + (max_key_length - user_key_length);
+    }
+    memcpy(&payload_buffer[*offset],key_buffer,user_key_length);
+    *offset = *offset + user_key_length;
+}
+
+_STATIC_H int32_t protected_update_form_payload_for_ecc(manifest_t * manifest_data)
+{
+    int32_t status = -1;
+
+    uint32_t offset = 0;
+    uint32_t total_payload_size = 0;
+    uint8_t  * ecc_key;
+    uint8_t  ecc_key_x_y_component[ECC_P_521_PUBLIC_KEY_SIZE];
+    ecc_key_t ecc_key_info;
+
+    do
+    {
+        // Get the max total payload size and individual max key length size
+        if (0 != protected_update_get_key_size(manifest_data,&ecc_key_info,&total_payload_size))
+        {
+            break;
+        }
+
+        ecc_key = (uint8_t  *)pal_os_calloc(1,total_payload_size);
+        if (NULL == ecc_key)
+        {
+            break;
+        }
+        // Reset the memory to 0x00
+        memset(&ecc_key_x_y_component[offset],0,(ecc_key_info.X_length + ecc_key_info.Y_length));
+
+        // Private key TLV formation
+        protected_update_form_key_payload_tlv_format(ecc_key,
+                                                     manifest_data->p_key_payload->key_params.ecc_key.D,
+                                                     &offset,
+                                                     ECC_PRIVATE_KEY_TAG,
+                                                     manifest_data->p_key_payload->key_params.ecc_key.D_length,
+                                                     ecc_key_info.D_length);
+        // if public key is available
+        if ((NULL != manifest_data->p_key_payload->key_params.ecc_key.X) &&
+            (NULL != manifest_data->p_key_payload->key_params.ecc_key.Y))
+        {
+            // Copy Public key X and Y components into buffer
+            memcpy(&ecc_key_x_y_component[ecc_key_info.X_length - manifest_data->p_key_payload->key_params.ecc_key.X_length],
+                   manifest_data->p_key_payload->key_params.ecc_key.X,
+                   manifest_data->p_key_payload->key_params.ecc_key.X_length);
+            
+            memcpy(&ecc_key_x_y_component[ecc_key_info.X_length + ecc_key_info.Y_length - manifest_data->p_key_payload->key_params.ecc_key.Y_length],
+                   manifest_data->p_key_payload->key_params.ecc_key.Y,
+                   manifest_data->p_key_payload->key_params.ecc_key.Y_length);
+            
+            // Public key TLV formation
+            protected_update_form_key_payload_tlv_format(ecc_key,
+                                                         &ecc_key_x_y_component[0],
+                                                         &offset,
+                                                         ECC_PUBLIC_KEY_TAG,
+                                                         (ecc_key_info.X_length + ecc_key_info.Y_length),
+                                                         (ecc_key_info.X_length + ecc_key_info.Y_length));
+        }
+        // Copy the payload formed
+        manifest_data->payload = ecc_key;
+        manifest_data->payload_length = total_payload_size;
+
+        status = 0;
+    } while(0);
+
+    return status;
+}
+
+_STATIC_H int32_t protected_update_form_payload_for_rsa(manifest_t * manifest_data)
+{
+    int32_t status = -1;
+
+    uint32_t offset = 0;
+    uint32_t total_payload_size = 0;
+    uint8_t  * rsa_key;
+    rsa_key_t rsa_key_info;
+
+    do
+    {
+        // Get the max total payload size and individual max key length size
+        if (0 != protected_update_get_key_size(manifest_data,&rsa_key_info,&total_payload_size))
+        {
+            break;
+        }
+        rsa_key = (uint8_t  *)pal_os_calloc(1,total_payload_size);
+        if (NULL == rsa_key)
+        {
+            break;
+        }
+        // Private exponent TLV formation
+        protected_update_form_key_payload_tlv_format(rsa_key,
+                                                     manifest_data->p_key_payload->key_params.rsa_key.D,
+                                                     &offset,
+                                                     RSA_PRIVATE_EXPONENT_TAG,
+                                                     manifest_data->p_key_payload->key_params.rsa_key.D_length,
+                                                     rsa_key_info.D_length);
+
+        // Modulus TLV formation
+        protected_update_form_key_payload_tlv_format(rsa_key,
+                                                     manifest_data->p_key_payload->key_params.rsa_key.N,
+                                                     &offset,
+                                                     RSA_MODULUS_TAG,
+                                                     manifest_data->p_key_payload->key_params.rsa_key.N_length,
+                                                     rsa_key_info.N_length);
+
+        // Public exponent TLV formation
+        protected_update_form_key_payload_tlv_format(rsa_key,
+                                                     manifest_data->p_key_payload->key_params.rsa_key.E,
+                                                     &offset,
+                                                     RSA_PUBLIC_EXPONENT_TAG,
+                                                     manifest_data->p_key_payload->key_params.rsa_key.E_length,
+                                                     rsa_key_info.E_length);
+        // Copy the payload formed
+        manifest_data->payload = rsa_key;
+        manifest_data->payload_length = total_payload_size;
+        status = 0;
+    } while(0);
+
+    return status;
+}
+
+_STATIC_H int32_t protected_update_form_payload_for_aes(manifest_t * manifest_data)
+{
+    int32_t status = -1;
+
+    uint32_t offset = 0;
+    uint32_t total_payload_size = 0;
+    uint8_t  * aes_key;
+    aes_key_t aes_key_info;
+    
+    do
+    {
+        // Get the max total payload size and individual max key length size
+        if (0 != protected_update_get_key_size(manifest_data,&aes_key_info,&total_payload_size))
+        {
+            break;
+        }
+
+        aes_key = (uint8_t  *)pal_os_calloc(1,total_payload_size);
+        if (NULL == aes_key)
+        {
+            break;
+        }
+        // Symmetric key TLV formation
+        protected_update_form_key_payload_tlv_format(aes_key,
+                                                     manifest_data->p_key_payload->key_params.aes_key.key,
+                                                     &offset,
+                                                     AES_128_KEY_TAG,
+                                                     manifest_data->p_key_payload->key_params.aes_key.key_length,
+                                                     aes_key_info.key_length);
+        // Copy the payload formed
+        manifest_data->payload = aes_key;
+        manifest_data->payload_length = total_payload_size;
+
+        status = 0;
+    } while(0);
+
+    return status;
+}
+
+_STATIC_H int32_t protected_update_form_key_payload(manifest_t * manifest_data)
+{
+    int32_t status = 0;
+
+    // Form the payload for ECC key
+    if (eECC == manifest_data->p_key_payload->key_type)
+    {
+        status = protected_update_form_payload_for_ecc(manifest_data);
+    }
+    // Form the payload for RSA key
+    else if (eRSA == manifest_data->p_key_payload->key_type)
+    {
+        status = protected_update_form_payload_for_rsa(manifest_data);
+    }
+    // Form the payload for AES key
+    else if (eAES == manifest_data->p_key_payload->key_type)
+    {
+        status = protected_update_form_payload_for_aes(manifest_data);
+    }
+    else
+    {
+        pal_logger_print_message("Error : Invalid key type\n");
+        status = -1;
+    }
+
+    return status;
+}
+
+_STATIC_H int32_t protected_update_form_payload(manifest_t * manifest_data)
+{
+    int32_t status = 0;
+
+    if(NULL != manifest_data->p_data_payload)
+    {
+        // Do nothing but just copy the data to payload
+        manifest_data->payload = manifest_data->p_data_payload->data;
+        manifest_data->payload_length = manifest_data->p_data_payload->data_length;
+        manifest_data->payload_type = ePAYLOAD_DATA;
+    }
+    else if(NULL != manifest_data->p_key_payload)
+    {
+        status = protected_update_form_key_payload(manifest_data);
+        manifest_data->payload_type = ePAYLOAD_KEY;
+    }
+    else if(NULL != manifest_data->p_metadata_payload)
+    {
+        manifest_data->payload = manifest_data->p_metadata_payload->metadata;
+        manifest_data->payload_length = manifest_data->p_metadata_payload->metadata_length;
+        manifest_data->payload_type = ePAYLOAD_METADATA;
+    }
+    else
+    {
+        pal_logger_print_message("Error : Invalid payload type\n");
+        status = -1;
+    }
+
+
+    return status;
+}
+
+_STATIC_H void protected_update_prepare_associated_data(manifest_t * manifest_data,
+                                                     uint8_t  * associated_buffer,
+                                                     uint32_t current_fragment_offset)
+{
+    uint16_t  offset = 0;
+    //Payload version
+    protected_tool_common_set_uint16(&associated_buffer[offset], &offset, manifest_data->payload_version);
+
+    //Fragment offset
+    protected_tool_common_set_uint24(&associated_buffer[offset], &offset, current_fragment_offset);
+
+    //Payload length
+    protected_tool_common_set_uint24(&associated_buffer[offset], &offset, manifest_data->payload_length);
+}
+
+_STATIC_H int32_t protected_update_encrypt_fragment(   manifest_t * manifest_data,
+                                                uint8_t  * p_current_fragment,
+                                                uint16_t  fragment_length,
+                                                uint32_t current_fragment_offset,
+                                                uint16_t  fragment_number)
+{
+    int32_t status = -1;
+    uint8_t associated_data[ASSOCIATED_DATA_LENGTH];
+    uint8_t nonce[NONCE_LENGTH + FRAGMENT_NUMBER_LENGTH];
+    do
+    {
+        if ((NONCE_LENGTH != manifest_data->p_confidentiality->enc_params.nonce_length) || (SESSION_KEY_LENGTH != (manifest_data->p_confidentiality->enc_params.session_key_length)))
+        {
+            break;
+        }
+        memcpy(nonce,manifest_data->p_confidentiality->enc_params.nonce_data,manifest_data->p_confidentiality->enc_params.nonce_length);        
+        protected_tool_common_set_uint16_without_offset(&nonce[manifest_data->p_confidentiality->enc_params.nonce_length],fragment_number);
+        protected_update_prepare_associated_data(manifest_data, associated_data, current_fragment_offset);
+        if (0 != (pal_crypt_encrypt_aes128_ccm(NULL,
+                                                p_current_fragment,
+                                               fragment_length,
+                                               (const uint8_t  *)manifest_data->p_confidentiality->enc_params.session_key,
+                                               (const uint8_t  *)nonce,
+                                               NONCE_LENGTH + FRAGMENT_NUMBER_LENGTH,
+                                               associated_data,
+                                               sizeof(associated_data),
+                                               MAC_SIZE,
+                                               p_current_fragment)))
+        {
+            break;
+        }
+
+        status = 0;
+    } while(0);
+    return status;
+}
+
+_STATIC_H uint16_t  protected_update_get_fragment_size(manifest_t * manifest_data)
+{
+
+    if(NULL != (manifest_data->p_confidentiality))
+        return ((MAX_PAYLOAD_FRAGMENT_SIZE - manifest_data->p_confidentiality->enc_params.mac_size));
+    else
+        return (MAX_PAYLOAD_FRAGMENT_SIZE);
+
+}
+
+//lint --e{534, 818} suppress "return value of cbor functions is not considered"
+int32_t protected_update_create_manifest(   manifest_t * manifest_data,
+                                        protected_update_data_set_d * p_cbor_manifest)
+{
+    int32_t status = -1;
+    uint8_t  digest[FRAGMENT_DIGEST_LENGTH];
+
+    uint8_t signature[256];
+    uint16_t signature_length;
+
+    uint8_t data_to_sign[300];
+    uint16_t data_to_sign_length;
+
+    uint8_t extracted_signature[256];
+    uint16_t payload_length_for_digest;
+
+    uint16_t sign_algo_length;
+    uint8_t * sign_header_ptr = NULL;
+    uint16_t sign_header_length = 0;
+    uint16_t offset = 0;
+    uint16_t length_marker = 0;
+    uint16_t byte_string_len_marker = 0;
+
+    do
+    {
+
+        cbor_set_array_of_data(signature_header, 4, &sign_header_length);
+        cbor_set_byte_string(signature_header, strlen(signature_string), &sign_header_length);
+        memcpy(signature_header+sign_header_length, signature_string, strlen(signature_string));
+        sign_header_length = sign_header_length + (uint16_t )strlen(signature_string);
+
+        sign_header_length++;
+        sign_algo_length = sign_header_length;
+        cbor_set_map_tag(signature_header, 0x01, &sign_header_length);
+        cbor_set_map_signed_type(signature_header, 0x01, (int32_t )manifest_data->signature_algo, &sign_header_length);
+        sign_algo_length = (sign_header_length - sign_algo_length);
+        sign_header_length = (sign_header_length - sign_algo_length) - 1;
+        cbor_set_byte_string(signature_header, sign_algo_length, &sign_header_length);
+        sign_header_length = sign_header_length + sign_algo_length;
+        cbor_set_byte_string(signature_header, 0x00, &sign_header_length);
+        sign_header_ptr = (uint8_t  *)signature_header;
+
+
+        // 1.COSE
+        cbor_set_array_of_data(local_manifest_buffer, 4, &offset);
+
+        // 2.protected signed header trust
+        cbor_set_byte_string(local_manifest_buffer, (sign_algo_length), &offset);
+        cbor_set_map_tag(local_manifest_buffer, 0x01, &offset);
+        cbor_set_map_signed_type(local_manifest_buffer, 0x01, (int32_t) manifest_data->signature_algo, &offset);
+        // 3.unprotected -signed header Trust
+        cbor_set_map_tag(local_manifest_buffer, 0x01, &offset);
+        cbor_set_map_byte_string_type(local_manifest_buffer, 0x04, (uint8_t  *)&manifest_data->trust_anchor_oid, 0x02, &offset);
+
+
+        // 4.Payload
+        length_marker = (uint8_t )offset;
+        //  Dummy length added to be improved
+        cbor_set_byte_string(local_manifest_buffer, 0xa5, &offset);
+
+        // 4.1 Trust_manifest
+        cbor_set_array_of_data(local_manifest_buffer, 0x06, &offset);
+
+        // manifestVersion
+        cbor_set_unsigned_integer(local_manifest_buffer, PROTECT_UPDATE_MANIFEST_VERSION, &offset);
+        cbor_set_null(local_manifest_buffer, &offset);
+        cbor_set_null(local_manifest_buffer, &offset);
+        cbor_set_array_of_data(local_manifest_buffer, 4, &offset);
+
+        // Trust_resource
+        // Trust_PayloadType
+        cbor_set_signed_integer(local_manifest_buffer, (int32_t)(manifest_data->payload_type), &offset);
+
+        if (0 != cbor_set_unsigned_integer(local_manifest_buffer, manifest_data->payload_length, &offset))
+        {
+            pal_logger_print_message(" Error : Assignment in cbor for payload_length\n");
+            break;
+        }
+        // Trust_PayloadVersion
+        if (0 != cbor_set_unsigned_integer(local_manifest_buffer, manifest_data->payload_version, &offset))
+        {
+            pal_logger_print_message(" Error : Assignment in cbor for payload_version\n");
+            break;
+        }
+
+        cbor_set_array_of_data(local_manifest_buffer, 2, &offset);
+        // AdditionalInfo
+        // Trust_AddInfo_Data
+        if(ePAYLOAD_DATA == manifest_data->payload_type)
+        {
+            // Trust_AddInfo_Data : offset
+            if (0 != cbor_set_unsigned_integer(local_manifest_buffer, manifest_data->p_data_payload->offset_in_oid, &offset))
+            {
+                pal_logger_print_message(" Error : Assignment in cbor for offset_in_oid\n");
+                break;
+            }
+            // Trust_AddInfo_Data : Trust_AddInfo_WriteType
+            cbor_set_unsigned_integer(local_manifest_buffer, (uint8_t )manifest_data->p_data_payload->write_type, &offset);
+        }
+        // Trust_AddInfo_Key
+        else if(ePAYLOAD_KEY == manifest_data->payload_type) 
+        {
+            // Trust_AddInfo_Key.key_algo
+            cbor_set_unsigned_integer(local_manifest_buffer, (uint8_t )manifest_data->p_key_payload->key_algorithm, &offset);
+            // Trust_AddInfo_Key.key_usage
+            cbor_set_unsigned_integer(local_manifest_buffer, (uint8_t )manifest_data->p_key_payload->key_usage, &offset);
+        }
+        // Trust_AddInfo_Metadata
+        else if(ePAYLOAD_METADATA == manifest_data->payload_type)
+        {
+            // Trust_AddInfo_Metadata.content_reset
+            cbor_set_unsigned_integer(local_manifest_buffer, (uint8_t )manifest_data->p_metadata_payload->content_reset, &offset);
+            // Trust_AddInfo_Metadata.additional_flag
+            cbor_set_unsigned_integer(local_manifest_buffer, (uint8_t )manifest_data->p_metadata_payload->additional_flag, &offset);
+        }
+        else
+        {
+            pal_logger_print_message(" Error : Payload type mismatch for additional data\n");
+            break;
+        }
+        // Trust_processors
+        cbor_set_array_of_data(local_manifest_buffer, 2, &offset);
+        cbor_set_array_of_data(local_manifest_buffer, 2, &offset);
+
+        // Trust_processors.ProcessingStep_integrity.process
+        cbor_set_signed_integer(local_manifest_buffer, -1, &offset);
+        cbor_set_byte_string(local_manifest_buffer, FRAGMENT_DIGEST_LENGTH + 5, &offset);
+
+        //Trust_processors.ProcessingStep_integrity.digestAlgorithm : DigestAlgorithms
+        cbor_set_array_of_data(local_manifest_buffer, 2, &offset);
+        cbor_set_unsigned_integer(local_manifest_buffer, (uint32_t)manifest_data->digest_algo, &offset);
+
+        //creating digest
+        payload_length_for_digest = (p_cbor_manifest->fragments_length > MAX_PAYLOAD_SIZE) ? MAX_PAYLOAD_SIZE : p_cbor_manifest->fragments_length;
+        if (0 != pal_crypt_hash(    NULL,
+                                    (uint8_t)eSHA_256,
+                                    (uint8_t *)p_cbor_manifest->fragments,
+                                    (uint16_t)payload_length_for_digest,
+                                    (uint8_t * )digest))
+        {
+            pal_logger_print_message(" Error : Failed in pal_crypt_hash");
+            break;
+        }
+
+        cbor_set_byte_string(local_manifest_buffer, sizeof(digest), &offset);
+        //Trust_processors.ProcessingStep_integrity.digest: IFX_DigestSize  
+        memcpy((local_manifest_buffer+offset), digest, sizeof(digest));
+        offset += sizeof(digest);
+
+        // Trust_processors.ProcessingStep2 : ProcessingStep_decrypt
+        if(NULL != manifest_data->p_confidentiality)
+        {
+            cbor_set_array_of_data(local_manifest_buffer, 2, &offset);
+
+            // Trust_processors.ProcessingStep_decrypt.process
+            cbor_set_unsigned_integer(local_manifest_buffer, 0x01, &offset);
+
+            // Trust_processors.ProcessingStep_decrypt.COSE_Encrypt_Trust
+            cbor_set_array_of_data(local_manifest_buffer, 3, &offset);
+
+            // Trust_processors.ProcessingStep_decrypt.protected: bstr .cbor protected-encrypt-header-Trust
+            byte_string_len_marker = offset;
+            // Dummy length of less than 0x17
+            cbor_set_byte_string(local_manifest_buffer, 0x03, &offset);
+
+            cbor_set_map_tag(local_manifest_buffer, 0x01, &offset);
+            cbor_set_map_unsigned_type(local_manifest_buffer, 0x01, (uint32_t)manifest_data->p_confidentiality->enc_params.encrypt_algo, &offset);
+            // Write the actual protected-encrypt-header-Trust length
+            cbor_set_byte_string(local_manifest_buffer, ((offset - byte_string_len_marker) - 1 ), &byte_string_len_marker);
+
+            // Trust_processors.ProcessingStep_decrypt.recipients
+            cbor_set_array_of_data(local_manifest_buffer, 1, &offset);
+
+            // Trust_processors.ProcessingStep_decrypt.COSE_Recipient_Trust
+            cbor_set_array_of_data(local_manifest_buffer, 2, &offset);
+
+            // protected-recipient-header-Trust length dummy value(make sure add dummy value greater tan 0x17)
+            byte_string_len_marker = offset;
+            cbor_set_byte_string(local_manifest_buffer, 0x53, &offset);
+
+            cbor_set_map_tag(local_manifest_buffer, 0x03, &offset);
+            cbor_set_map_byte_string_type(local_manifest_buffer, 0x04, (uint8_t  *)&manifest_data->p_confidentiality->kdf_data.shared_secret_oid, 0x02, &offset);
+
+            cbor_set_map_signed_type(local_manifest_buffer, 0x01, (int32_t)manifest_data->p_confidentiality->kdf_data.key_derivation_algo, &offset);
+
+            // Key(05)
+            cbor_set_unsigned_integer(local_manifest_buffer, 0x05, &offset);
+
+            // Trust_Key_derivation_IV
+            cbor_set_array_of_data(local_manifest_buffer, 2, &offset);
+            // label
+            if((manifest_data->p_confidentiality->kdf_data.label_length > 0) && (manifest_data->p_confidentiality->kdf_data.label_length <= 32))
+            {
+                cbor_set_byte_string(local_manifest_buffer, manifest_data->p_confidentiality->kdf_data.label_length, &offset);
+                memcpy((local_manifest_buffer+offset), manifest_data->p_confidentiality->kdf_data.label, manifest_data->p_confidentiality->kdf_data.label_length);
+                offset += manifest_data->p_confidentiality->kdf_data.label_length;
+            }
+            else
+            {
+                pal_logger_print_message(" Error : Label length is not in range");
+                break;
+            }
+
+            if(manifest_data->p_confidentiality->kdf_data.seed_length >= 16 && manifest_data->p_confidentiality->kdf_data.seed_length <= 64)
+            {
+                cbor_set_byte_string(local_manifest_buffer, manifest_data->p_confidentiality->kdf_data.seed_length, &offset);
+                memcpy((local_manifest_buffer+offset), manifest_data->p_confidentiality->kdf_data.seed, manifest_data->p_confidentiality->kdf_data.seed_length);
+                offset += manifest_data->p_confidentiality->kdf_data.seed_length;
+            }
+            else
+            {
+                pal_logger_print_message(" Error : Seed length is not in range");
+                break;
+            }
+            // Write the actual protected-recipient-header-Trust length
+            cbor_set_byte_string(local_manifest_buffer, (uint32_t)((offset - byte_string_len_marker) - 2 ), &byte_string_len_marker);
+
+            // Nil
+            cbor_set_null(local_manifest_buffer, &offset);
+            // Nil
+            cbor_set_null(local_manifest_buffer, &offset);
+
+        }
+        else
+        {
+            // Trust_processors.ProcessingStep2 : NULL
+            cbor_set_null(local_manifest_buffer, &offset);
+        }
+
+        // Component identifier
+        cbor_set_array_of_data(local_manifest_buffer, 2, &offset);
+        if(NULL != manifest_data->couid)
+        {
+            cbor_set_byte_string(local_manifest_buffer, strlen((const int8_t*)manifest_data->couid), &offset);
+            memcpy((local_manifest_buffer+offset), manifest_data->couid, strlen((const int8_t*)manifest_data->couid));
+            offset += (uint16_t )strlen((const int8_t*)manifest_data->couid);
+        }
+        else
+        {
+            cbor_set_byte_string(local_manifest_buffer, 0, &offset);
+        }
+        //target oid
+        cbor_set_byte_string(local_manifest_buffer, 2, &offset);
+        protected_tool_common_set_uint16(&local_manifest_buffer[offset], &offset, manifest_data->target_oid);
+
+        //Updating length filed of payload
+        data_to_sign_length = ((offset - length_marker) - 1);
+        local_manifest_buffer[length_marker + 1] = (uint8_t )(data_to_sign_length - 1);
+
+        //Generate signature
+        memcpy(data_to_sign, sign_header_ptr, sign_header_length);
+        data_to_sign_length += 1;
+        memcpy(data_to_sign + sign_header_length, local_manifest_buffer + length_marker, data_to_sign_length);
+        data_to_sign_length += sign_header_length;
+
+        signature_length = sizeof(signature);
+        if(0 != pal_crypt_sign( NULL,
+                                (uint8_t * )data_to_sign,
+                                (uint16_t)data_to_sign_length,
+                                (uint8_t * )signature,
+                                (uint16_t * )&signature_length,
+                                (const uint8_t *)manifest_data->private_key,
+                                0))
+        {
+            pal_logger_print_message(" Error : Failed in pal_crypt_calculate_signature");
+            break;
+        }
+
+        // do only for EC_256
+        if ((int16_t)eES_SHA == (int16_t)manifest_data->signature_algo)
+        {
+            status = pal_crypt_get_signature_length((uint8_t  *)manifest_data->private_key,&signature_length, eES_SHA);
+            if (0 != status)
+            {
+                pal_logger_print_message(" Error : Getting signature length");
+                break;
+            }
+            // Remove encoding
+            memset(extracted_signature, 0, sizeof(extracted_signature));
+            status = protected_update_decode_ecc_signature((const uint8_t  *)signature, extracted_signature, signature_length);
+            if (0 != status)
+            {
+                pal_logger_print_message(" Error : Decode ecc signature");
+                break;
+            }
+            cbor_set_byte_string(local_manifest_buffer, signature_length, &offset);
+            memcpy(&local_manifest_buffer[offset], extracted_signature, signature_length);
+        }
+        else if ((int16_t)eRSA_SSA_PKCS1_V1_5_SHA_256 == (int16_t)manifest_data->signature_algo)
+        {
+            status = pal_crypt_get_signature_length((uint8_t  *)manifest_data->private_key,&signature_length, eRSA_SSA_PKCS1_V1_5_SHA_256);
+            if (0 != status)
+            {
+                pal_logger_print_message(" Error : Getting signature length\n");
+                break;
+            }
+            cbor_set_byte_string(local_manifest_buffer, signature_length, &offset);
+            memcpy(&local_manifest_buffer[offset], signature, signature_length);
+        }
+
+        offset += signature_length;
+        p_cbor_manifest->data_length = offset;
+        p_cbor_manifest->data = (uint8_t  * )pal_os_malloc(offset);
+        memcpy(p_cbor_manifest->data, local_manifest_buffer, offset);
+
+        status = 0;
+    } while (0);
+    return status;
+
+}
+
+int32_t protected_update_create_fragments(manifest_t * manifest_data,
+                                      protected_update_data_set_d * p_cbor_manifest)
+{
+    int32_t status = -1;
+    uint8_t digest[FRAGMENT_DIGEST_LENGTH];
+    uint16_t remaining_payload_length = 0;
+    uint16_t max_memory_required;
+    uint8_t * fragments = NULL;
+    uint8_t count_of_fragments = 0, index_for_hashing = 0;
+    uint8_t * p_current_fragment = NULL;
+    uint16_t length_to_digest;
+    uint16_t payload_len_to_copy = 0;
+    uint16_t max_payload_fragment_size = 0;
+
+    do
+    {
+
+        // Form payload
+        if(0 != protected_update_form_payload(manifest_data))
+        {
+            pal_logger_print_message(" Error : Failed in protected_update_form_payload");
+            break;
+        }
+        remaining_payload_length = (uint16_t )manifest_data->payload_length;
+        max_payload_fragment_size = protected_update_get_fragment_size(manifest_data);
+        max_memory_required = (uint16_t )((remaining_payload_length / max_payload_fragment_size) * MAX_PAYLOAD_SIZE);
+        max_memory_required += (uint16_t )(remaining_payload_length % max_payload_fragment_size);
+
+        if(NULL != manifest_data->p_confidentiality)
+            max_memory_required += manifest_data->p_confidentiality->enc_params.mac_size;
+
+        fragments = (uint8_t  *)pal_os_calloc(max_memory_required, sizeof(uint8_t ));
+        if(NULL == fragments)
+        {
+            pal_logger_print_message("Error : Create fragment memory allocation");
+            break;
+        }
+        // Copy all the user data into fragment payloads
+        do
+        {
+            p_current_fragment = fragments + (count_of_fragments * MAX_PAYLOAD_SIZE);
+
+            //payload_len_to_copy = (remaining_payload_length > (MAX_PAYLOAD_SIZE - ((NULL != manifest_data->p_confidentiality) ? manifest_data->p_confidentiality->enc_params.mac_size : 0))) ? max_payload_fragment_size : remaining_payload_length;
+            payload_len_to_copy = (remaining_payload_length > max_payload_fragment_size) ? max_payload_fragment_size : remaining_payload_length;
+            memcpy(p_current_fragment, manifest_data->payload + (max_payload_fragment_size * count_of_fragments), payload_len_to_copy);
+
+            if (NULL != manifest_data->p_confidentiality)
+            {
+                if (0 != protected_update_encrypt_fragment(manifest_data,
+                                                           p_current_fragment,
+                                                           payload_len_to_copy,
+                                                           (count_of_fragments * max_payload_fragment_size),
+                                                           count_of_fragments + 1))
+                {
+                    pal_logger_print_message("Error : Encrypt fragment ");
+                    break;
+                }
+            }
+            count_of_fragments++;
+
+            remaining_payload_length -= payload_len_to_copy;
+            if (NULL != manifest_data->p_confidentiality)
+            {
+                payload_len_to_copy += manifest_data->p_confidentiality->enc_params.mac_size;
+            }
+
+            p_cbor_manifest->fragments_length += payload_len_to_copy;
+
+        } while (remaining_payload_length != 0);
+
+        // Index to start hashing last fragment
+        index_for_hashing = count_of_fragments-1;
+
+        // Start adding hash to fragment
+        do
+        {
+            if (0 != index_for_hashing)
+            {
+                p_current_fragment = fragments + (index_for_hashing * MAX_PAYLOAD_SIZE);
+
+                length_to_digest = ((count_of_fragments - index_for_hashing) == 1) ? payload_len_to_copy  : MAX_PAYLOAD_SIZE;
+
+                // Calculate hash on the current fragment and add to previous fragment
+                pal_crypt_hash( NULL,
+                                (uint8_t)eSHA_256,
+                                (const uint8_t  *)p_current_fragment,
+                                (uint32_t)length_to_digest,
+                                digest);
+                memcpy( p_current_fragment - FRAGMENT_DIGEST_LENGTH,
+                        digest,
+                        sizeof(digest));
+
+                p_cbor_manifest->fragments_length += sizeof(digest);
+
+                index_for_hashing--;
+            }
+
+        } while (index_for_hashing != 0);
+
+        p_cbor_manifest->fragments = fragments;
+        // Below variable can be deleted
+        p_cbor_manifest->actual_memory_allocated = max_memory_required;
+        status = 0;
+    } while (0);
+    return status;
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/user_input_parser.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/user_input_parser.c
new file mode 100644
index 000000000..26ed6c53a
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/src/user_input_parser.c
@@ -0,0 +1,929 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file user_input_parser.c
+*
+* \brief   This file gets the user input and convert them to types and data structures used for protected update data set creation.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "protected_update_data_set.h"
+#include "pal\pal_file_system.h"
+#include "pal\pal_logger.h"
+#include "user_input_parser.h"
+#include "pal\pal_crypt.h"
+#include "pal\pal_os_memory.h"
+
+#define TOOL_DISPLAY_FORMAT_INTEGER         "\t%-20s : %-8X \n"
+#define TOOL_DISPLAY_FORMAT_STRING          "\t%-20s : %-8s \n"
+
+#define TOOL_ASSIGN                             ""
+/* Default values and shortname*/
+// MANIFEST
+#define DESC_PAYLOAD_VERSION                "Payload version"
+#define SHORT_NAME_PAYLOAD_VERSION          "payload_version"TOOL_ASSIGN
+#define DEFAULT_PAYLOAD_VERSION             "0"
+
+#define DESC_TRUST_ANCHOR_OID               "Trust anchor oid"
+#define SHORT_NAME_TRUST_ANCHOR_OID         "trust_anchor_oid"TOOL_ASSIGN
+#define DEFAULT_TRUST_ANCHOR_OID            "E0E8"
+
+#define DESC_TARGET_OID                     "Target oid"
+#define SHORT_NAME_TARGET_OID               "target_oid"TOOL_ASSIGN
+#define DEFAULT_TARGET_OID                  "E0E2"
+
+#define DESC_COUID                          "Co-Processor OID"
+#define SHORT_NAME_COUID                    "couid"TOOL_ASSIGN
+#define DEFAULT_COUID                       NULL
+
+#define DESC_SIGN_ALGO                      "Signature Algorithm"
+#define SHORT_NAME_SIGN_ALGO                "sign_algo"TOOL_ASSIGN
+#define DEFAULT_SIGN_ALGO                   "ES_256"
+
+#define DESC_PRIV_KEY                       "Private key"
+#define SHORT_NAME_PRIV_KEY                 "priv_key"TOOL_ASSIGN
+#define DEFAULT_PRIV_KEY                    NULL
+
+#define DESC_DIGEST_ALGO                    "Digest algorithm"
+#define SHORT_NAME_DIGEST_ALGO              "digest_algo"TOOL_ASSIGN
+#define DEFAULT_DIGEST_ALGO                 "SHA256"
+
+#define DESC_PAYLOAD_TYPE                   "Type of Payload"
+#define SHORT_NAME_PAYLOAD_TYPE             "payload_type"TOOL_ASSIGN
+#define DEFAULT_PAYLOAD_TYPE                "data"
+
+//CONFIDENTIALITY
+#define DESC_SHARED_SECRET                  "Shared secret"
+#define SHORT_NAME_SHARED_SECRET            "secret"TOOL_ASSIGN
+#define DEFAULT_SHARED_SECRET               NULL
+
+#define DESC_SHARED_SECRET_OID              "Shared secret OID"
+#define SHORT_NAME_SHARED_SECRET_OID        "secret_oid"TOOL_ASSIGN
+#define DEFAULT_SHARED_SECRET_OID           "F1D0"
+
+#define DESC_LABEL                          "Label"
+#define SHORT_NAME_LABEL                    "label"TOOL_ASSIGN
+#define DEFAULT_LABEL                       "Confidentiality"
+
+#define DESC_SEED_LENGTH                     "Length of seed"
+#define SHORT_NAME_SEED_LENGTH               "seed_length"TOOL_ASSIGN
+#define DEFAULT_SEED_LENGTH                  "64"
+
+#define DESC_KDF                            "Key Derivation Function"
+#define SHORT_NAME_KDF                      "kdf"TOOL_ASSIGN
+#define DEFAULT_KDF                         "IFX_KDF-TLS12_PRF_SHA256"
+
+#define DESC_ENCRYPT_ALGO                   "Encryption algorithm"
+#define SHORT_NAME_ENCRYPT_ALGO             "enc_algo"TOOL_ASSIGN
+#define DEFAULT_ENCRYPT_ALGO                "AES-CCM-16-64-128"
+
+// PAYLOAD : DATA
+#define DESC_OFFSET_IN_OID                  "Offset in OID"
+#define SHORT_NAME_OFFSET_IN_OID            "offset"TOOL_ASSIGN
+#define DEFAULT_OFFSET_IN_OID               "0"
+
+#define DESC_WRITE_TYPE                     "Type of Write"
+#define SHORT_NAME_WRITE_TYPE               "write_type"TOOL_ASSIGN
+#define DEFAULT_WRITE_TYPE                  "2"
+
+#define DESC_PAYLOAD_DATA                   "OID data"
+#define SHORT_NAME_PAYLOAD_DATA             "data"TOOL_ASSIGN
+#define DEFAULT_PAYLOAD_DATA                NULL
+
+#define DESC_INPUT_DATA_FORMAT               "Input data format"
+#define SHORT_NAME_INPUT_DATA_FORMAT         "in_data_format"TOOL_ASSIGN
+#define DEFAULT_INPUT_DATA_FORMAT            "hex"
+
+// PAYLOAD : KEY
+#define DESC_PAYLOAD_KEY                    "Key Data"
+#define SHORT_NAME_PAYLOAD_KEY              "key_data"TOOL_ASSIGN
+#define DEFAULT_PAYLOAD_KEY                 NULL
+
+#define DESC_KEY_ALGO                       "Key algorithm"
+#define SHORT_NAME_KEY_ALGO                 "key_algo"TOOL_ASSIGN
+#define DEFAULT_KEY_ALGO                    ""
+
+#define DESC_KEY_USAGE                      "Key Usage"
+#define SHORT_NAME_KEY_USAGE                "key_usage"TOOL_ASSIGN
+#define DEFAULT_KEY_USAGE                   "02"
+
+// PAYLOAD : METADATA
+#define DESC_PAYLOAD_METADATA               "Meta Data"
+#define SHORT_NAME_PAYLOAD_METADATA         "metadata"TOOL_ASSIGN
+#define DEFAULT_PAYLOAD_METADATA            NULL
+
+#define DESC_CONTENT_RESET                  "Content Reset"
+#define SHORT_NAME_CONTENT_RESET            "content_reset"TOOL_ASSIGN
+#define DEFAULT_CONTENT_RESET               "0"
+
+#define DEFAULT_ADDITIONAL_FLAG             "0"
+
+// Dataset output to file
+#define DESC_DATASET_OUTPUT_FILE            "Dataset output to file"
+#define SHORT_NAME_DATASET_OUTPUT_FILE      "dataset_to_file"TOOL_ASSIGN
+#define DEFAULT_DATASET_OUTPUT_FILE         NULL
+
+// Details
+#define DETAIL_MANIFEST                     "(1) : To create manifest , provide the following details"
+#define DETAIL_CONFIDENTIALITY              "(2) : To enable confidentiality,\"secret\" must be provided (All other options are ignored if there is no confidentiality)"
+#define DETAIL_DATA_OBJ                     "(3.1) : To update data object, \"payload_type\" should be \"data\" and provide the following details:"
+#define DETAIL_KEY_OBJ                      "(3.2) : To update key object, \"payload_type\" should be \"key\" and provide the following details:"
+#define DETAIL_METADATA_OBJ                 "(3.3) : To update metadata object, \"payload_type\" should be \"metadata\" and provide the following details:"
+#define DETAIL_DATASET_TO_FILE              "(4) : To write dataset to file, \"dataset_to_file\" should be the file path "
+
+#define _NEXT_		"\n\t\t\t\t      :  "
+
+/* Short name*/
+static struct options
+{
+    // MANIFEST
+    uint8_t * payload_version;
+    uint8_t * trust_anchor_oid;
+    uint8_t * target_oid;
+    uint8_t * couid;
+    uint8_t * signature_algo;
+    uint8_t * private_key;
+    uint8_t * digest_algo;
+    uint8_t * payload_type;
+
+    // CONFIDENTIALITY
+    uint8_t * shared_secret;
+    uint8_t * shared_secret_oid;
+    uint8_t * label;
+    uint8_t * encrypt_algo;
+    uint8_t * kdf;
+    uint8_t * seed_length;
+    
+    // PAYLOAD :  DATA
+    uint8_t * offset_in_oid;
+    uint8_t * write_type;
+    uint8_t * data;
+    uint8_t * input_data_format;
+
+    // PAYLOAD : KEY
+    uint8_t * key_data;
+    uint8_t * key_usage;
+    uint8_t * key_algo;
+
+    // PAYLOAD :  METADATA
+    uint8_t * content_reset;
+    uint8_t * metadata;
+
+    // FILEPATH NAME
+    uint8_t *dataset_to_file_path;
+} opt;
+
+typedef struct option_property
+{
+    const int8_t * description;
+    const int8_t * short_name;
+    uint8_t ** opt_val;
+    uint8_t * default_val;
+    uint8_t modified;
+    const int8_t * option_details;
+    const int8_t * note_details;
+}opt_prop_t;
+
+//lint --e{64, 786} suppress "Type mismatch "
+opt_prop_t option_table[] = 
+{
+    // MANIFEST
+    { "Details", DETAIL_MANIFEST, NULL, "", 0, "", "" },
+    { DESC_PAYLOAD_VERSION ,SHORT_NAME_PAYLOAD_VERSION, &opt.payload_version, DEFAULT_PAYLOAD_VERSION, 0, "","Input is a decimal string.E.g. 10" },
+    { DESC_TRUST_ANCHOR_OID, SHORT_NAME_TRUST_ANCHOR_OID, &opt.trust_anchor_oid, DEFAULT_TRUST_ANCHOR_OID, 0, "", "Input is a hexadecimal string.E.g. E0E8" },
+    { DESC_TARGET_OID, SHORT_NAME_TARGET_OID, &opt.target_oid, DEFAULT_TARGET_OID, 0, "", "Input is a hexadecimal string.E.g. E0E2" },
+    { DESC_COUID, SHORT_NAME_COUID, &opt.couid, DEFAULT_COUID, 0, "", "Unicast gets enabled if \"couid\" is provided otherwise it is broadcast."_NEXT_"Input is a hexadecimal string.E.g. A1DE34" },
+    { DESC_SIGN_ALGO, SHORT_NAME_SIGN_ALGO, &opt.signature_algo, DEFAULT_SIGN_ALGO, 0, "ES_256 , RSA-SSA-PKCS1-V1_5-SHA-256","" },
+    { DESC_PRIV_KEY, SHORT_NAME_PRIV_KEY, &opt.private_key, DEFAULT_PRIV_KEY, 0, "private key file (pem format)", "Refer : samples/integrity/sample_ec_256_priv.pem" },
+    { DESC_DIGEST_ALGO, SHORT_NAME_DIGEST_ALGO, &opt.digest_algo, DEFAULT_DIGEST_ALGO, 0, "SHA256", "" },
+    { DESC_PAYLOAD_TYPE, SHORT_NAME_PAYLOAD_TYPE, &opt.payload_type, DEFAULT_PAYLOAD_TYPE, 0, "data , key , metadata", "" },
+    
+    // CONFIDENTIALITY
+    { "Details", DETAIL_CONFIDENTIALITY, NULL, "", 0, "", "" },
+    { DESC_SHARED_SECRET, SHORT_NAME_SHARED_SECRET, &opt.shared_secret, DEFAULT_SHARED_SECRET, 0, "Text file containing shared secret as hexadecimal string", "Refer : samples/confidentiality/secret.txt" },
+    { DESC_SHARED_SECRET_OID, SHORT_NAME_SHARED_SECRET_OID, &opt.shared_secret_oid, DEFAULT_SHARED_SECRET_OID, 0, "", "Input is a hexadecimal string.E.g. F1D0" },
+    { DESC_LABEL, SHORT_NAME_LABEL, &opt.label, DEFAULT_LABEL, 0, "", "Input is a string.E.g. "DEFAULT_LABEL },
+    { DESC_ENCRYPT_ALGO, SHORT_NAME_ENCRYPT_ALGO, &opt.encrypt_algo, DEFAULT_ENCRYPT_ALGO, 0, "AES-CCM-16-64-128", "" },
+    { DESC_KDF, SHORT_NAME_KDF, &opt.kdf, DEFAULT_KDF, 0, "IFX_KDF-TLS12_PRF_SHA256", "" },
+    { DESC_SEED_LENGTH, SHORT_NAME_SEED_LENGTH, &opt.seed_length, DEFAULT_SEED_LENGTH, 0, "", "Input is a decimal string.E.g. 64" },
+    
+    // PAYLOAD : DATA
+    { "Details", DETAIL_DATA_OBJ, NULL, "", 0, "", "" },
+    { DESC_OFFSET_IN_OID,SHORT_NAME_OFFSET_IN_OID, &opt.offset_in_oid, DEFAULT_OFFSET_IN_OID, 0, "","" },
+    { DESC_WRITE_TYPE, SHORT_NAME_WRITE_TYPE, &opt.write_type, DEFAULT_WRITE_TYPE, 0, "Write (1), EraseAndWrite (2)", "" },
+    { DESC_PAYLOAD_DATA, SHORT_NAME_PAYLOAD_DATA, &opt.data, DEFAULT_PAYLOAD_DATA, 0, "","Input is a text file with hexadecimal or ascii string content" },
+    { DESC_INPUT_DATA_FORMAT, SHORT_NAME_INPUT_DATA_FORMAT, &opt.input_data_format, DEFAULT_INPUT_DATA_FORMAT, 0, "hex , ascii", "Refer : samples/payload/data/ascii_data.txt for input_data_format=ascii"_NEXT_"Refer : samples/payload/data/hex_data.txt for input_data_format=hex"},
+    
+    // PAYLOAD : KEYS
+    { "Details", DETAIL_KEY_OBJ, NULL, "", 0, "", "" },
+    { DESC_KEY_USAGE, SHORT_NAME_KEY_USAGE, &opt.key_usage, DEFAULT_KEY_USAGE, 0, "AUTH (0x01) , ENC (0x02) , SIGN (0x10) , KEY_AGREE (0x20)", "Input is a hexadecimal string.E.g. E3"_NEXT_"The values in \"options\" can be bitwise ORED and provided ( Refer SRM )" },
+    { DESC_KEY_ALGO, SHORT_NAME_KEY_ALGO, &opt.key_algo, DEFAULT_KEY_ALGO, 0, "ECC-NIST-P-256 (3) , ECC-NIST-P-384 (4), ECC-NIST-P-521 (5), ECC-BRAINPOOL-P-256-R1 (19) , ECC-BRAINPOOL-P-384-R1 (21), ECC-BRAINPOOL-P-512-R1 (22), RSA-1024-Exp (65) , RSA-2048-Exp (66), AES-128 (129), AES-192 (129), AES-256 (131)", "Input is a decimal string.E.g. 129" },
+    { DESC_PAYLOAD_KEY, SHORT_NAME_PAYLOAD_KEY, &opt.key_data, DEFAULT_PAYLOAD_KEY, 0, "ECC / RSA key in .pem format or AES key in txt file as hexadecimal string", "Refer : samples/payload/key/sample_ec_256_priv.pem for ECC or RSA key"_NEXT_"Refer : samples/payload/key/aes_key.txt for AES key" },
+    
+    // PAYLOAD : METADATA
+    { "Details", DETAIL_METADATA_OBJ, NULL, "", 0, "", "" },
+    { DESC_CONTENT_RESET,SHORT_NAME_CONTENT_RESET, &opt.content_reset, DEFAULT_CONTENT_RESET, 0, "As per metadata identifier flag (0), Zeroes (1), Random (2)","" },
+    { DESC_PAYLOAD_METADATA, SHORT_NAME_PAYLOAD_METADATA, &opt.metadata, DEFAULT_PAYLOAD_METADATA, 0, "", "Input is a txt file as hexadecimal string" },
+
+    // Dataset to output file
+    { "Details", DETAIL_DATASET_TO_FILE, NULL, "", 0, "", "" },
+    { DESC_DATASET_OUTPUT_FILE, SHORT_NAME_DATASET_OUTPUT_FILE, &opt.dataset_to_file_path, DEFAULT_DATASET_OUTPUT_FILE, 0, "Provide the filename for output dataset to be stored", ""},
+};
+
+extern uint8_t * dataset_file_path;
+
+static int8_t buffer[200];
+
+void _tool_show_usage( void)
+{
+    uint8_t index;
+    uint8_t count = sizeof(option_table) / sizeof(opt_prop_t);
+
+    sprintf(buffer, "Usage : <.exe> input1=<value> input2=<value> ..\n");
+    pal_logger_print_message(buffer);
+
+    for (index = 0; index < count; index++)
+    {
+        if (strcmp("Details", option_table[index].description) == 0)
+        {
+            sprintf(buffer,"\n\t%-20s\n", option_table[index].short_name);
+            pal_logger_print_message(buffer);
+        }
+        else
+        {
+            sprintf(buffer, "\t%-20s %-8s :  %-8s \n", option_table[index].short_name, "default", option_table[index].default_val);
+            pal_logger_print_message(buffer);
+            if (strcmp("", option_table[index].option_details) != 0)
+            {
+                sprintf(buffer, "\t%-20s %-8s :  %-8s \n", "","options", option_table[index].option_details);
+                pal_logger_print_message(buffer);
+            }
+            if (strcmp("", option_table[index].note_details) != 0)
+            {
+                sprintf(buffer, "\t%-20s %-8s :  %-8s \n", "", "note",option_table[index].note_details);
+                pal_logger_print_message(buffer);
+            }
+        }
+    }
+}
+
+_STATIC_H int32_t set_str_to_long(const int8_t * src, uint32_t * dest)
+{
+    int32_t status = -1;
+    int64_t val = atoi(src);
+    // Destination is unsigned value of 32 bits, hence compared with 0x80000000
+    if (0x80000000 >= val)
+    {
+        *dest = (uint32_t)val;
+        status = 0;
+    }
+    return status;
+}
+
+_STATIC_H int32_t set_str_to_short(const int8_t * src, uint16_t * dest)
+{
+    int32_t status = -1;
+    int32_t val = atoi(src);
+    // Destination is unsigned value of 16 bits, hence compared with 0x8000
+    if (0x8000 > val)
+    {
+        *dest = (uint16_t)val;
+        status = 0;
+    }
+    return status;
+}
+
+_STATIC_H int32_t set_str_to_byte(const int8_t * src, uint8_t * dest)
+{
+    int32_t status = -1;
+    int32_t val = atoi(src);
+    // Destination is unsigned value of 8 bits, hence compared with 0x80
+    if (0x80 > val)
+    {
+        *dest = (uint8_t)val;
+        status = 0;
+    }
+    return status;
+}
+
+_STATIC_H int32_t set_str_to_byte_signed(const int8_t * src, int8_t * dest)
+{
+    int32_t status = -1;
+    int32_t val = atoi(src);
+    if (0xFF >= val)
+    {
+        *dest = (int8_t)val;
+        status = 0;
+    }
+    return status;
+}
+
+_STATIC_H int32_t set_str_to_hex_one_byte(const int8_t * src, uint8_t * dest)
+{
+    int32_t status = -1;
+    int64_t val = strtol(src, NULL, 16);
+    if (0x80 > (uint8_t)val)
+    {
+        *dest = (uint8_t)val;
+        status = 0;
+    }
+    return status;
+}
+
+_STATIC_H int32_t set_str_to_hex(const int8_t * src, uint16_t * dest)
+{
+    int32_t status = -1;
+    int64_t val = strtol(src, NULL, 16);
+    if (0xffff > val)
+    {
+        *dest = (uint16_t)val;
+        status = 0;
+    }
+    return status;
+}
+
+_STATIC_H void _tool_show_user_inputs( void)
+{
+    uint8_t index;
+    uint8_t count = sizeof(option_table) / sizeof(opt_prop_t);
+
+    pal_logger_print_message("Info : User provided inputs\n");
+    for (index = 0; index < count; index++)
+    {
+        if (1 == option_table[index].modified)
+        {
+            sprintf(buffer, "\t%-20s : %-8s \n", option_table[index].description, *(option_table[index].opt_val));
+            pal_logger_print_message(buffer);
+        }
+    }
+    pal_logger_print_message("\n");
+}
+
+_STATIC_H void _tool_set_default_value( void)
+{
+    uint8_t index;
+    uint8_t count = sizeof(option_table) / sizeof(opt_prop_t);
+    for (index = 0; index < count; index++)
+    {
+        if (NULL != option_table[index].opt_val)
+        {
+            *(option_table[index].opt_val) = option_table[index].default_val;
+        }
+    }
+    pal_logger_print_message("Info : Default values are set\n");
+}
+
+_STATIC_H int32_t _tool_set_option(int8_t * p_option, int8_t * p_user_value)
+{
+    int32_t status = -1;
+    uint8_t index;
+    uint8_t count = sizeof(option_table) / sizeof(opt_prop_t);
+    
+    for (index = 0; index < count; index++)
+    {
+        if (strcmp(p_option, option_table[index].short_name) == 0)
+        {
+            *(option_table[index].opt_val) = p_user_value;
+            option_table[index].modified = 1;
+            status = 0;
+            break;
+        }
+    }
+    if (-1 == status)
+    {
+        sprintf(buffer, "Error :  User provided option %s cannot be found", p_option);
+        pal_logger_print_message(buffer);
+    }
+    return status;
+}
+
+_STATIC_H int32_t _tool_set_manifest_info(manifest_t* p_manifest_data)
+{
+    int32_t status = -1;
+
+    do
+    {
+        //MANIFEST
+        if (0 != set_str_to_short(opt.payload_version, &(p_manifest_data->payload_version)))
+        {
+            pal_logger_print_message("Error : Invalid input payload version provided\n");
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_PAYLOAD_VERSION, p_manifest_data->payload_version);
+        pal_logger_print_message(buffer);
+
+        p_manifest_data->trust_anchor_oid = (uint16_t)strtol(opt.trust_anchor_oid, NULL, 16);
+        if (0 != set_str_to_hex(opt.trust_anchor_oid, &(p_manifest_data->trust_anchor_oid)))
+        {
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_TRUST_ANCHOR_OID, p_manifest_data->trust_anchor_oid);
+        pal_logger_print_message(buffer);
+    
+        if (0 != set_str_to_hex(opt.target_oid, &(p_manifest_data->target_oid)))
+        {
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_TARGET_OID, p_manifest_data->target_oid);
+        pal_logger_print_message(buffer);
+
+        p_manifest_data->private_key = opt.private_key;
+        if (strcmp("SHA256", opt.digest_algo) == 0)
+        {
+            p_manifest_data->digest_algo = eSHA_256;
+        }
+        else
+        {
+            pal_logger_print_message("Error : Invalid input provided for digest algorithm\n");
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_DIGEST_ALGO, p_manifest_data->digest_algo);
+        pal_logger_print_message(buffer);
+
+        p_manifest_data->couid = NULL;
+        if (NULL != opt.couid)
+        {
+            p_manifest_data->couid = opt.couid;
+            sprintf(buffer, TOOL_DISPLAY_FORMAT_STRING, DESC_COUID, p_manifest_data->couid);
+            pal_logger_print_message(buffer);
+        }
+        if (strcmp("ES_256", opt.signature_algo) == 0)
+        {
+            p_manifest_data->signature_algo = eES_SHA;
+        }
+        else if (strcmp("RSA-SSA-PKCS1-V1_5-SHA-256", opt.signature_algo) == 0)
+        {
+            p_manifest_data->signature_algo = eRSA_SSA_PKCS1_V1_5_SHA_256;
+        }
+        else
+        {
+            pal_logger_print_message("Error : Invalid input provided for signature algorithm\n");
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_SIGN_ALGO, p_manifest_data->signature_algo);
+        pal_logger_print_message(buffer);
+
+        if (0 == strcmp("data", opt.payload_type))
+        {
+            p_manifest_data->payload_type = ePAYLOAD_DATA;
+        }
+        else if (0 == strcmp("key", opt.payload_type))
+        {
+            p_manifest_data->payload_type = ePAYLOAD_KEY;
+        }
+        else if (0 == strcmp("metadata", opt.payload_type))
+        {
+            p_manifest_data->payload_type = ePAYLOAD_METADATA;
+        }
+        else
+        {
+            pal_logger_print_message("Error : Invalid input provided for payload type\n");
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_PAYLOAD_TYPE, p_manifest_data->payload_type);
+        pal_logger_print_message(buffer);
+        status = 0;
+    } while (0);
+    return status;
+}
+
+_STATIC_H int32_t _tool_set_confidentiality_info(confidentiality_t * p_confidentiality)
+{
+    int32_t status = 1;
+    uint8_t default_seed_length;
+    do
+    {
+        //shared secret
+        status = pal_file_system_read_file_to_array_in_hex((const int8_t *)opt.shared_secret,
+            &p_confidentiality->kdf_data.shared_secret,
+            &(p_confidentiality->kdf_data.shared_secret_length));
+        if (0 != status)
+        {
+            pal_logger_print_message("Error : Unable to read shared secret length\n");
+            break;
+        }
+        status = -1;
+
+        if (0 != set_str_to_byte(opt.seed_length, &(p_confidentiality->kdf_data.seed_length)))
+        {
+            break;
+        }
+        (void)set_str_to_byte(DEFAULT_SEED_LENGTH, &default_seed_length);
+        if ( default_seed_length < p_confidentiality->kdf_data.seed_length)
+        {
+            pal_logger_print_message("Error : Seed length not supported\n");
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_SEED_LENGTH, p_confidentiality->kdf_data.seed_length);
+        pal_logger_print_message(buffer);
+
+        // Generate seed 
+        p_confidentiality->kdf_data.seed = (uint8_t *)pal_os_malloc(sizeof(uint8_t) * p_confidentiality->kdf_data.seed_length);
+
+        if (0 != pal_crypt_set_seed(NULL,
+            p_confidentiality->kdf_data.seed, (uint16_t)p_confidentiality->kdf_data.seed_length))
+        {
+            pal_logger_print_message(" Error : Failed in pal_crypt_set_seed\n");
+            break;
+        }
+
+        //Label
+        p_confidentiality->kdf_data.label = opt.label;
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_STRING, DESC_LABEL, p_confidentiality->kdf_data.label);
+        pal_logger_print_message(buffer);
+
+        p_confidentiality->kdf_data.label_length = (uint16_t)strlen((const int8_t *)opt.label);
+
+        // Derive the key
+        if (0 != pal_crypt_tls_prf_sha256(    NULL,
+                                            p_confidentiality->kdf_data.shared_secret,
+                                            p_confidentiality->kdf_data.shared_secret_length, 
+                                            p_confidentiality->kdf_data.label,
+                                            p_confidentiality->kdf_data.label_length,
+                                            p_confidentiality->kdf_data.seed,
+                                            p_confidentiality->kdf_data.seed_length,
+                                            p_confidentiality->enc_params.session_key,
+                                            sizeof(p_confidentiality->enc_params.session_key)))
+        {
+            pal_logger_print_message(" Error : Failed in pal_crypt_tls_prf_sha256\n");
+            break;
+        }
+
+        // Fetch the nonce and key
+        p_confidentiality->enc_params.session_key_length = sizeof(p_confidentiality->enc_params.session_key);
+        
+        memcpy(p_confidentiality->enc_params.nonce_data, p_confidentiality->enc_params.session_key + (p_confidentiality->enc_params.session_key_length - NONCE_LENGTH), NONCE_LENGTH);
+        p_confidentiality->enc_params.nonce_length = NONCE_LENGTH;
+
+        // shared secret oid
+        p_confidentiality->kdf_data.shared_secret_oid = (uint16_t)strtol(opt.shared_secret_oid, NULL, 16);
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_SHARED_SECRET_OID, p_confidentiality->kdf_data.shared_secret_oid);
+        pal_logger_print_message(buffer);
+
+        // shared secret 
+        sprintf(buffer, "\t%-20s : \n\t", DESC_SHARED_SECRET);
+        pal_logger_print_hex_data (p_confidentiality->kdf_data.shared_secret, p_confidentiality->kdf_data.shared_secret_length);
+
+        // Encryption algorithm
+        if (strcmp("AES-CCM-16-64-128", opt.encrypt_algo) == 0)
+        {
+            // set enum below
+            p_confidentiality->enc_params.encrypt_algo = eAES_CCM_16_64_128;
+            p_confidentiality->enc_params.mac_size = MAC_SIZE;
+        }
+        else
+        {
+            pal_logger_print_message("Error : Invalid input provided for encryption algorithm\n");
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_ENCRYPT_ALGO, p_confidentiality->enc_params.encrypt_algo);
+        pal_logger_print_message(buffer);
+
+        // KDF
+        if (strcmp("IFX_KDF-TLS12_PRF_SHA256", opt.kdf) == 0)
+        {
+            p_confidentiality->kdf_data.key_derivation_algo = eIFX_KDF_TLS12_PRF_SHA256;
+        }
+        else
+        {
+            pal_logger_print_message("Error : Invalid input provided for KDF\n");
+            break;
+        }
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_KDF, p_confidentiality->kdf_data.key_derivation_algo);
+        pal_logger_print_message(buffer);
+
+
+        status = 0;
+    } while (0);
+    return status;
+}
+
+_STATIC_H int32_t _tool_set_object_data_info(data_payload_t * p_data_payload)
+{
+    int32_t status = 1;
+
+    do
+    {
+        if(0 != set_str_to_long((const int8_t *)opt.offset_in_oid, &p_data_payload->offset_in_oid))
+		{
+			pal_logger_print_message("Error : Invalid offset in oid provided\n");
+			break;
+		}
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_OFFSET_IN_OID, p_data_payload->offset_in_oid);
+        pal_logger_print_message(buffer);
+		 
+        if(0 != set_str_to_byte((const int8_t *)opt.write_type, &p_data_payload->write_type))
+		{
+			pal_logger_print_message("Error : Invalid write type provided\n");
+			break;
+		}
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_WRITE_TYPE, p_data_payload->write_type);
+        pal_logger_print_message(buffer);
+
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_STRING, DESC_INPUT_DATA_FORMAT, opt.input_data_format);
+        pal_logger_print_message(buffer);
+        if(!strcmp("ascii", (const int8_t *)opt.input_data_format))
+        {
+            status = pal_file_system_read_file_to_array((const int8_t *)opt.data, &(p_data_payload->data), &(p_data_payload->data_length));
+        }
+        else if(!strcmp("hex", (const int8_t *)opt.input_data_format))
+        {
+            status = pal_file_system_read_file_to_array_in_hex((const int8_t *)opt.data, &(p_data_payload->data), &(p_data_payload->data_length));
+        }
+        else
+        {
+            pal_logger_print_message("Error : Invalid input data format provided\n");
+			status = 1;
+			break;
+        }
+        if (0 != status)
+        {
+            pal_logger_print_message("Error : Unable to read data to be written to OID\n");
+            break;
+        }
+        status = 0;
+    } while (0);
+    return status;
+}
+
+_STATIC_H int32_t _tool_set_key_data_info(key_payload_t * p_key_payload)
+{
+    int32_t status = 1;
+    int8_t * test_file = ".txt";
+    uint8_t key_type = (uint8_t)eAES;
+    do
+    {
+        if (NULL == strstr(opt.key_data,test_file))
+        {
+            key_type = (uint8_t)(pal_crypt_get_key_type(opt.key_data));
+        }
+        
+        switch (key_type)
+        {
+        case eRSA:
+#define RSA_KEY            (p_key_payload->key_params.rsa_key)
+
+            status = pal_crypt_parse_rsa_key(
+                                             opt.key_data, &(RSA_KEY.N), &(RSA_KEY.N_length),
+                                             &(RSA_KEY.E), &(RSA_KEY.E_length),
+                                             &(RSA_KEY.D), &(RSA_KEY.D_length));
+            if (0 != status)
+            {
+                pal_logger_print_message("Error : Unable to parse RSA key\n");
+                break;
+            }
+            p_key_payload->key_type = eRSA;
+
+#undef RSA_KEY
+            break;
+
+        case eECC:
+#define ECC_KEY            (p_key_payload->key_params.ecc_key)
+
+            status = pal_crypt_parse_ecc_key(
+                                             opt.key_data,
+                                             &(ECC_KEY.D), &(ECC_KEY.D_length),
+                                             &(ECC_KEY.X), &(ECC_KEY.X_length),
+                                             &(ECC_KEY.Y), &(ECC_KEY.Y_length));
+            if (0 != status)
+            {
+                pal_logger_print_message("Error : Unable to parse ECC key\n");
+                break;
+            }
+            p_key_payload->key_type = eECC;
+
+#undef ECC_KEY
+            break;
+
+        case eAES:
+            status = pal_file_system_read_file_to_array_in_hex(opt.key_data, &(p_key_payload->key_params.aes_key.key), &(p_key_payload->key_params.aes_key.key_length));
+            if (0 != status)
+            {
+                pal_logger_print_message("Error : Unable to read AES key\n");
+                break;
+            }
+            if(((p_key_payload->key_params.aes_key.key_length) % 2) != 0)
+            {
+                pal_logger_print_message("Error : Key length is not correct\n");
+                break;
+            }
+
+            p_key_payload->key_type = eAES;
+            break;
+
+        default:
+            break;
+        }
+        p_key_payload->key_data_file_path = opt.key_data;
+    } while (0);
+    return status;
+}
+
+_STATIC_H int32_t _tool_set_meta_data_info(metadata_payload_t * p_metadata_payload)
+{
+    int32_t status = 1;
+    do
+    {
+        (void)set_str_to_byte((const int8_t *)opt.content_reset, (uint8_t *)&p_metadata_payload->content_reset);
+        sprintf(buffer, TOOL_DISPLAY_FORMAT_INTEGER, DESC_CONTENT_RESET, (uint8_t)p_metadata_payload->content_reset);
+        pal_logger_print_message(buffer);
+
+        (void)set_str_to_byte((const int8_t *)DEFAULT_ADDITIONAL_FLAG, &p_metadata_payload->additional_flag);
+
+        status = pal_file_system_read_file_to_array_in_hex((const int8_t *)opt.metadata, &(p_metadata_payload->metadata), &(p_metadata_payload->metadata_length));
+        if (0 != status)
+        {
+            pal_logger_print_message("Error : Unable to read meta data to be written to OID\n");
+            break;
+        }
+        status = 0;
+    } while (0);
+    return status;
+}
+
+int32_t tool_get_user_inputs(int32_t argc, int8_t *argv[])
+{
+    int32_t status = 0;
+    int32_t i;
+    int8_t *p, *q;
+
+    _tool_set_default_value();
+    do
+    {
+        for (i = 1; i < argc; i++)
+        {
+            p = argv[i];
+            if ((q = strchr(p, '=')) == NULL)
+            {
+                status = -1;
+                break;
+            }
+            *q++ = '\0';
+            status = _tool_set_option(p, q);    
+            if (0 != status)
+            {
+                break;
+            }
+        }
+    } while (0);
+
+    if (0 == status)
+    {
+        _tool_show_user_inputs();
+    }
+    else
+    {
+        _tool_show_usage();
+    }
+    return status;
+}
+
+int32_t tool_set_user_inputs(manifest_t* p_manifest_data)
+{
+
+    int32_t status = -1;
+    pal_logger_print_message("Info : Setting value for data formatter\n");
+    // set all structure pointer to NULL.
+
+    p_manifest_data->p_confidentiality = NULL;
+    // precedence is data, key and metadata
+    p_manifest_data->p_data_payload = NULL;
+    p_manifest_data->p_key_payload = NULL;
+    p_manifest_data->p_metadata_payload = NULL;
+    do
+    {
+        if (0 != _tool_set_manifest_info(p_manifest_data))
+        {
+            break;
+        }
+
+        //CONFIDENTIALITY
+        // set your pointer for shared secret structure to NULL
+        if (NULL != opt.shared_secret)
+        {
+            // create structure and assign to your pointer
+            p_manifest_data->p_confidentiality = (confidentiality_t *)pal_os_malloc(sizeof(confidentiality_t));
+            if (0 != _tool_set_confidentiality_info(p_manifest_data->p_confidentiality))
+            {
+                break;
+            }
+        }
+            
+        //PAYLOAD : Data
+        if (NULL != opt.data)
+        {
+            p_manifest_data->p_data_payload = (data_payload_t *)pal_os_malloc(sizeof(data_payload_t));
+            if (0 != _tool_set_object_data_info(p_manifest_data->p_data_payload))
+            {
+                break;
+            }
+        }
+        //PAYLOAD : Key
+        else if (NULL != opt.key_data)
+        {
+            p_manifest_data->p_key_payload = (key_payload_t *)pal_os_malloc(sizeof(key_payload_t));
+            if (0 != _tool_set_key_data_info(p_manifest_data->p_key_payload))
+            {
+                break;
+            }
+
+            if( 0 != set_str_to_hex_one_byte((const int8_t *)opt.key_usage, (uint8_t *)&p_manifest_data->p_key_payload->key_usage))
+            {
+                pal_logger_print_message("Error : Invalid input key usage provided \n");
+                break;
+            }
+            (void)set_str_to_byte_signed((const int8_t *)opt.key_algo, (uint8_t *)&p_manifest_data->p_key_payload->key_algorithm);
+        }
+        //PAYLOAD : Metadata
+        else if (NULL != opt.metadata)
+        {
+            p_manifest_data->p_metadata_payload = (metadata_payload_t *)pal_os_malloc(sizeof(metadata_payload_t));
+            if (0 != _tool_set_meta_data_info(p_manifest_data->p_metadata_payload))
+            {
+                break;
+            }
+
+        }
+        else
+        {
+            pal_logger_print_message("Error : No data available for payload\n");
+            break;
+        }
+
+        if(NULL != opt.dataset_to_file_path)
+        {
+              dataset_file_path = opt.dataset_to_file_path;
+        }
+        status = 0;
+    } while (0);
+
+    if (0 != status)
+    {
+        _tool_show_usage();
+        (void)tool_clear_inputs(p_manifest_data);
+    }
+
+    return status;
+}
+
+int32_t tool_clear_inputs(manifest_t* p_manifest_data)
+{
+    int32_t status = -1;
+
+    if (NULL != p_manifest_data->p_confidentiality)
+    {
+        if (NULL != p_manifest_data->p_confidentiality->kdf_data.label)
+        {
+            pal_os_free(p_manifest_data->p_confidentiality);
+        }
+    }
+    if (NULL != p_manifest_data->p_data_payload)
+    {
+        pal_os_free(p_manifest_data->p_data_payload);
+    }
+    if (NULL != p_manifest_data->p_key_payload)
+    {
+        pal_os_free(p_manifest_data->p_key_payload);
+    }
+    if (NULL != p_manifest_data->p_metadata_payload)
+    {
+        pal_os_free(p_manifest_data->p_metadata_payload);
+    }
+    return status;
+}
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/main.c b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/main.c
new file mode 100644
index 000000000..b3b992b2a
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/main.c
@@ -0,0 +1,113 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file main.c
+*
+* \brief   This file is the main file.
+*
+* \ingroup  grProtectedUpdateTool
+*
+* @{
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "pal\pal_logger.h"
+#include "protected_update_data_set.h"
+#include "protected_update_data_set_version.h"
+#include "user_input_parser.h"
+#include "pal\pal_os_memory.h"
+
+int32_t main(int32_t argc, int8_t *argv[])
+{
+    int32_t exit_status = 1;
+    manifest_t * p_manifest = NULL;
+    int8_t buffer[100];
+    protected_update_data_set_d cbor_manifest = { 0 };
+    cbor_manifest.data = NULL;
+    cbor_manifest.fragments = NULL;
+
+    do
+    {
+        p_manifest = (manifest_t *)pal_os_calloc(1, sizeof(manifest_t));
+        if (NULL == p_manifest)
+        {
+            break;
+        }
+
+        sprintf(buffer, "Tool Version : %s\n", PROTECTED_UPDATE_VERSION );
+        pal_logger_print_message(buffer);
+
+        if (0 != tool_get_user_inputs(argc, argv))
+        {
+            break;
+        }
+        if( 0 != tool_set_user_inputs(p_manifest))
+        {
+            break;
+        }
+
+        // Generate fragements
+        if (0 != protected_update_create_fragments(p_manifest, &cbor_manifest))
+        {
+            pal_logger_print_message("Error while creating fragments\n");
+            break;
+        }
+        
+        // Generate Manifest
+        if (0 != protected_update_create_manifest(p_manifest, &cbor_manifest))
+        {
+            pal_logger_print_message("Error while creating manifest\n");
+            break;
+        }
+        // Print the output dataset 
+        protected_update_print_output_dataset(&cbor_manifest);
+
+        exit_status = 0;
+    } while (0);
+    //free memory
+    if (NULL != cbor_manifest.data)
+    {
+        pal_os_free(cbor_manifest.data);
+    }
+    if (NULL != cbor_manifest.fragments)
+    {
+        pal_os_free(cbor_manifest.fragments);
+    }
+    if (NULL != p_manifest)
+    {
+        pal_os_free(p_manifest);
+    }
+
+    return exit_status;
+}
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.sln b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.sln
new file mode 100644
index 000000000..adf4a8cd0
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.sln
@@ -0,0 +1,20 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual Studio 2010
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "protected_update_data_set", "protected_update_data_set.vcxproj", "{54690D97-3F9D-4348-A9EE-E4879B35DBE4}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{54690D97-3F9D-4348-A9EE-E4879B35DBE4}.Debug|Win32.ActiveCfg = Debug|Win32
+		{54690D97-3F9D-4348-A9EE-E4879B35DBE4}.Debug|Win32.Build.0 = Debug|Win32
+		{54690D97-3F9D-4348-A9EE-E4879B35DBE4}.Release|Win32.ActiveCfg = Release|Win32
+		{54690D97-3F9D-4348-A9EE-E4879B35DBE4}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.vcxproj b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.vcxproj
new file mode 100644
index 000000000..683d20261
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.vcxproj
@@ -0,0 +1,186 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="10.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{54690D97-3F9D-4348-A9EE-E4879B35DBE4}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>protected_update_data_set</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v100</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v100</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;MBEDTLS_FS_IO;MBEDTLS_PEM_PARSE_C;MBEDTLS_BASE64_C;MBEDTLS_ECDSA_DETERMINISTIC;MBEDTLS_HMAC_DRBG_C;MBEDTLS_ECDSA_DETERMINISTIC_DEBUG;MBEDTLS_RSA_C;MBEDTLS_PKCS1_V15;MBEDTLS_PK_RSA_ALT_SUPPORT;MBEDTLS_TIMING_C;MBEDTLS_ENTROPY_C;MBEDTLS_CTR_DRBG_C;MBEDTLS_ECDSA_C;MBEDTLS_ASN1_WRITE_C;MBEDTLS_ECP_DP_SECP384R1_ENABLED;MBEDTLS_ECP_DP_SECP521R1_ENABLED;MBEDTLS_ECP_DP_BP256R1_ENABLED;MBEDTLS_ECP_DP_BP384R1_ENABLED;MBEDTLS_ECP_DP_BP512R1_ENABLED;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>..\include\pal;..\include;..\..\..\..\externals\mbedtls\include</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;MBEDTLS_FS_IO;MBEDTLS_PEM_PARSE_C;MBEDTLS_BASE64_C;MBEDTLS_ECDSA_DETERMINISTIC;MBEDTLS_HMAC_DRBG_C;MBEDTLS_ECDSA_DETERMINISTIC_DEBUG;MBEDTLS_RSA_C;MBEDTLS_PKCS1_V15;MBEDTLS_PK_RSA_ALT_SUPPORT;MBEDTLS_TIMING_C;MBEDTLS_ENTROPY_C;MBEDTLS_CTR_DRBG_C;MBEDTLS_ECDSA_C;MBEDTLS_ASN1_WRITE_C;MBEDTLS_ECP_DP_SECP384R1_ENABLED;MBEDTLS_ECP_DP_SECP521R1_ENABLED;MBEDTLS_ECP_DP_BP256R1_ENABLED;MBEDTLS_ECP_DP_BP384R1_ENABLED;MBEDTLS_ECP_DP_BP512R1_ENABLED;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>..\include\pal;..\include;..\..\..\..\externals\mbedtls\include</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\aes.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\aesni.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\arc4.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\aria.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\asn1parse.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\asn1write.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\base64.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\bignum.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\blowfish.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\camellia.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ccm.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\certs.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\chacha20.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\chachapoly.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\cipher.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\cipher_wrap.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\cmac.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ctr_drbg.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\debug.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\des.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\dhm.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecdh.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecdsa.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecjpake.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecp.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecp_curves.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\entropy.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\entropy_poll.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\error.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\gcm.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\havege.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\hkdf.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\hmac_drbg.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md2.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md4.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md5.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md_wrap.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\memory_buffer_alloc.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\net_sockets.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\nist_kw.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\oid.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\padlock.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pem.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pk.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkcs11.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkcs12.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkcs5.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkparse.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkwrite.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pk_wrap.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\platform.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\platform_util.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\poly1305.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ripemd160.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\rsa.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\rsa_internal.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\sha1.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\sha256.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\sha512.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_cache.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_ciphersuites.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_cli.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_cookie.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_srv.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_ticket.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_tls.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\threading.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\timing.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\version.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\version_features.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509write_crt.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509write_csr.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509_create.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509_crl.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509_crt.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509_csr.c" />
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\xtea.c" />
+    <ClCompile Include="..\pal\pal_crypt_mbedtls.c" />
+    <ClCompile Include="..\pal\pal_file_system.c" />
+    <ClCompile Include="..\pal\pal_logger.c" />
+    <ClCompile Include="..\pal\pal_os_memory.c" />
+    <ClCompile Include="..\src\cbor.c" />
+    <ClCompile Include="..\src\common_utilities.c" />
+    <ClCompile Include="..\src\protected_update_data_set.c" />
+    <ClCompile Include="..\src\user_input_parser.c" />
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\include\cbor.h" />
+    <ClInclude Include="..\include\common_utilites.h" />
+    <ClInclude Include="..\include\pal\pal_crypt.h" />
+    <ClInclude Include="..\include\pal\pal_file_system.h" />
+    <ClInclude Include="..\include\pal\pal_logger.h" />
+    <ClInclude Include="..\include\pal\pal_os_memory.h" />
+    <ClInclude Include="..\include\protected_update_data_set.h" />
+    <ClInclude Include="..\include\protected_update_data_set_version.h" />
+    <ClInclude Include="..\include\user_input_parser.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.vcxproj.filters b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.vcxproj.filters
new file mode 100644
index 000000000..02688fd04
--- /dev/null
+++ b/3rdparty/experimental/optiga/examples/tools/protected_update_data_set/visual_studio/protected_update_data_set.vcxproj.filters
@@ -0,0 +1,315 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="src">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="header">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="mbedtls">
+      <UniqueIdentifier>{91cb329c-ed2f-4a99-82da-13c7e7a71f28}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\aes.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\aesni.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\arc4.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\asn1parse.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\asn1write.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\base64.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\bignum.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\blowfish.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\camellia.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ccm.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\certs.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\cipher.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\cipher_wrap.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\cmac.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ctr_drbg.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\debug.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\des.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\dhm.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecdh.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecdsa.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecjpake.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecp.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ecp_curves.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\entropy.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\entropy_poll.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\error.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\gcm.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\havege.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\hmac_drbg.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md_wrap.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md2.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md4.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\md5.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\memory_buffer_alloc.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\net_sockets.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\oid.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\padlock.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pem.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pk.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pk_wrap.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkcs5.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkcs11.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkcs12.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkparse.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\pkwrite.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\platform.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ripemd160.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\rsa.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\rsa_internal.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\sha1.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\sha256.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\sha512.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_cache.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_ciphersuites.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_cli.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_cookie.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_srv.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_ticket.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\ssl_tls.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\threading.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\timing.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\version.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\version_features.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509_create.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509_crl.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509_crt.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509_csr.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509write_crt.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\x509write_csr.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\xtea.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\cbor.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\protected_update_data_set.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\pal\pal_crypt_mbedtls.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\pal\pal_file_system.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\pal\pal_logger.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="main.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\aria.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\chacha20.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\chachapoly.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\hkdf.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\nist_kw.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\platform_util.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\externals\mbedtls\library\poly1305.c">
+      <Filter>mbedtls</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\user_input_parser.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\pal\pal_os_memory.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\common_utilities.c">
+      <Filter>src</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\include\cbor.h">
+      <Filter>header</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\protected_update_data_set.h">
+      <Filter>header</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\protected_update_data_set_version.h">
+      <Filter>header</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\pal\pal_crypt.h">
+      <Filter>header</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\pal\pal_file_system.h">
+      <Filter>header</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\pal\pal_logger.h">
+      <Filter>header</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\user_input_parser.h">
+      <Filter>header</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\pal\pal_os_memory.h">
+      <Filter>header</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\common_utilites.h">
+      <Filter>header</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/externals/alios/LICENSE b/3rdparty/experimental/optiga/externals/alios/LICENSE
new file mode 100644
index 000000000..8dada3eda
--- /dev/null
+++ b/3rdparty/experimental/optiga/externals/alios/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/chip_config.h b/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/chip_config.h
new file mode 100644
index 000000000..903873f60
--- /dev/null
+++ b/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/chip_config.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015-2018 Alibaba Group Holding Limited
+ */
+
+
+#ifndef __CONFIG_H__
+#define __CONFIG_H__
+
+
+////////////////////////////////////////////////////////////////////////////////
+#ifdef WIN32
+#define snprintf                        _snprintf
+#endif
+////////////////////////////////////////////////////////////////////////////////
+
+#define CHIP_DEBUG                          0
+
+////////////////////////////////////////////////////////////////////////////////
+
+#define CHIP_TYPE_SECURE_MCU                1
+#define CHIP_TYPE_SE_STD_CMD                2
+#define CHIP_TYPE_SE_MTK_CMD                3
+#define CHIP_TYPE_SE_OPTIGA_CMD             4
+
+#define CHIP_CRYPTO_TYPE_3DES               1
+#define CHIP_CRYPTO_TYPE_AES                2
+#define CHIP_CRYPTO_TYPE_RSA                3
+
+////////////////////////////////////////////////////////////////////////////////
+
+#define CHIP_APDU_CMD_ADAPTER               1
+#define CHIP_SEND_SELECT_COMMAND            1
+#define CHIP_CONST_TEST_KEY                 1
+
+////////////////////////////////////////////////////////////////////////////////
+
+#define CHIP_TYPE_CONFIG                    CHIP_TYPE_SE_OPTIGA_CMD
+#define CHIP_CRYPTO_TYPE_CONFIG             CHIP_CRYPTO_TYPE_AES
+
+////////////////////////////////////////////////////////////////////////////////
+
+#if ((CHIP_TYPE_CONFIG != CHIP_TYPE_SECURE_MCU) && (CHIP_TYPE_CONFIG != CHIP_TYPE_SE_STD_CMD) && (CHIP_TYPE_CONFIG != CHIP_TYPE_SE_MTK_CMD) && (CHIP_TYPE_CONFIG != CHIP_TYPE_SE_OPTIGA_CMD))
+#error("CHIP_TYPE_CONFIG error.");
+#endif
+
+#if ((CHIP_CRYPTO_TYPE_CONFIG != CHIP_CRYPTO_TYPE_3DES) && (CHIP_CRYPTO_TYPE_CONFIG != CHIP_CRYPTO_TYPE_AES) && (CHIP_CRYPTO_TYPE_CONFIG!= CHIP_CRYPTO_TYPE_RSA))
+#error("CHIP_CRYPTO_TYPE_CONFIG error.");
+#endif
+
+#endif
+
diff --git a/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/error_code.h b/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/error_code.h
new file mode 100644
index 000000000..85fbe27ca
--- /dev/null
+++ b/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/error_code.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015-2017 Alibaba Group Holding Limited
+ */
+
+#ifndef __ERROR_CODE_H__
+#define __ERROR_CODE_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    IROT_SUCCESS                 = 0,  ///< The operation was successful.
+    IROT_ERROR_GENERIC           = -1, ///< Non-specific casuse.
+    IROT_ERROR_BAD_PARAMETERS    = -2, ///< Input parameters were invlid.
+    IROT_ERROR_SHORT_BUFFER      = -3, ///< The supplied buffer is too short for the output.
+    IROT_ERROR_EXCESS_DATA       = -4, ///< Too much data for the requested operation was passed.
+    IROT_ERROR_OUT_OF_MEMORY     = -5, ///< System out of memory resources.
+    IROT_ERROR_COMMUNICATION     = -7, ///< Communication error
+    IROT_ERROR_NOT_SUPPORTED     = -8, ///< The request operation is valid but is not supported in this implementation.
+    IROT_ERROR_NOT_IMPLEMENTED   = -9, ///< The requested operation should exist but is not yet implementation.
+    IROT_ERROR_TIMEOUT           = -10,///< Communication Timeout
+    IROT_ERROR_ITEM_NOT_FOUND    = -11,///< Id2 is not exist
+} irot_result_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/irot_hal.h b/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/irot_hal.h
new file mode 100644
index 000000000..df4c9db1d
--- /dev/null
+++ b/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/irot_hal.h
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2015-2017 Alibaba Group Holding Limited
+ */
+
+#ifndef __IROT_HAL_H__
+#define __IROT_HAL_H__
+
+#include <stdint.h>
+#include "error_code.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define KEY_ID_ID2              0x00   ///< Key is used by ID2.(3DES, AES or RSA)
+
+typedef enum {
+    CIPHER_TYPE_INVALID         = 0x00,
+    CIPHER_TYPE_AES             = 0x01,
+    CIPHER_TYPE_3DES            = 0x03,
+    CIPHER_TYPE_SM4             = 0x04,
+} cipher_t;
+
+typedef enum {
+    BLOCK_MODE_ECB              = 0x00,
+    BLOCK_MODE_CBC              = 0x01,
+    BLOCK_MODE_CTR              = 0x02,
+} block_mode_t;
+
+typedef enum {
+    SYM_PADDING_NOPADDING       = 0x00,
+    SYM_PADDING_PKCS5           = 0x02,
+    SYM_PADDING_PKCS7           = 0x03,
+} irot_sym_padding_t;
+
+typedef enum {
+    ASYM_PADDING_NOPADDING      = 0x00,
+    ASYM_PADDING_PKCS1          = 0x01,
+} irot_asym_padding_t;
+
+typedef enum {
+    MODE_DECRYPT                = 0x00,
+    MODE_ENCRYPT                = 0x01,
+} crypto_mode_t;
+
+typedef enum {
+    ASYM_TYPE_RSA_MD5_PKCS1     = 0x00,
+    ASYM_TYPE_RSA_SHA1_PKCS1    = 0x01,
+    ASYM_TYPE_RSA_SHA256_PKCS1  = 0x02,
+    ASYM_TYPE_RSA_SHA384_PKCS1  = 0x03,
+    ASYM_TYPE_RSA_SHA512_PKCS1  = 0x04,
+    ASYM_TYPE_SM3_SM2           = 0x05,
+    ASYM_TYPE_ECDSA             = 0x06,
+} asym_sign_verify_t;
+
+typedef enum {
+    HASH_TYPE_SHA1              = 0x00,
+    HASH_TYPE_SHA224            = 0x01,
+    HASH_TYPE_SHA256            = 0x02,
+    HASH_TYPE_SHA384            = 0x03,
+    HASH_TYPE_SHA512            = 0x04,
+    HASH_TYPE_SM3               = 0x05,
+} hash_t;
+
+typedef struct _sym_crypto_param_t {
+    block_mode_t block_mode;    ///< block mode
+    irot_sym_padding_t padding_type; ///< padding type
+    crypto_mode_t mode;                ///< mode(encrypt or decrypt)
+} sym_crypto_param_t;
+
+enum {
+    KEY_TYPE_3DES            = 0x01,
+    KEY_TYPE_AES             = 0x02,
+    KEY_TYPE_SM4             = 0x03,
+
+    KEY_TYPE_RSA_PUBLIC      = 0x04,
+    KEY_TYPE_RSA_PRIVATE     = 0x05,
+    KEY_TYPE_RSA_CRT_PRIVATE = 0x06,
+};
+
+enum {
+    LENGTH_DES3_2KEY    =   16,
+    LENGTH_DES3_3KEY    =   24,
+};
+
+enum {
+    LENGTH_AES_128      =   16,
+    LENGTH_AES_192      =   24,
+    LENGTH_AES_256      =   32,
+};
+
+enum {
+    LENGTH_RSA_1024     =   128,
+};
+
+
+// key object
+typedef struct {
+    struct {
+        uint8_t key_object_type; ///< the key object type
+    } head;
+    struct {
+        uint8_t buf[0x04];      ///< placeholder for key
+    } body;
+} key_object;
+
+typedef struct {
+    struct {
+        uint8_t key_object_type;
+    } head;
+    struct {
+        uint8_t *key_value; ///< the key value
+        uint32_t key_len;   ///< the key length(bytes)
+    } body;
+} key_object_sym;
+
+typedef struct {
+    struct {
+        uint8_t key_object_type;
+    } head;
+    struct {
+        uint8_t *e;         ///< public exponent
+        uint32_t e_len;     ///< public exponent length(bytes)
+        uint8_t *n;         ///< public modulus
+        uint32_t n_len;     ///< public modulus length(bytes)
+    } body;
+} key_object_rsa_public;
+
+typedef struct {
+    struct {
+        uint8_t key_object_type;
+    } head;
+    struct {
+        uint8_t *d;         ///< private exponent
+        uint32_t d_len;     ///< private exponent length(bytes)
+        uint8_t *n;         ///< private modulus
+        uint32_t n_len;     ///< private modulus length(bytes)
+    } body;
+} key_object_rsa_private;
+
+typedef struct {
+    struct {
+        uint8_t key_object_type;
+    } head;
+    struct {
+        uint8_t *p;         ///< 1st prime factor
+        uint8_t *q;         ///< 2st prime factor
+        uint8_t *dp;        ///< d % (p - 1)
+        uint8_t *dq;        ///< d % (q - 1)
+        uint8_t *qinv;      ///< (1/q) % p
+        uint32_t len;       ///< the length for the 5 parameters must with the same length(bytes)
+    } body;
+} key_object_rsa_crt_private;
+
+
+irot_result_t irot_hal_init(void);
+
+/**
+ * @brief get the ID2 value, the length is 12 bytes with hex format.
+ *
+ * @param id2 output buffer.
+ * @param len input with the id2 buffer size, ouput the real id2 length.
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t irot_hal_get_id2(uint8_t *id2, uint32_t *len);
+
+/**
+ * @brief encrypt or decrypt the data with symmetric algorithms.
+ *
+ * @param key_obj if this key object is not null, then use this parameter as the key, else use the internal key identified by the key id parameter.
+ * @param key_id identify the internal key.
+ * @param in input data
+ * @param in_len input data length.
+ * @param out output buffer.
+ * @param out_len input with the output buffer size, ouput the real data length.
+ * @param crypto_param @see sym_crypto_param_t
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t irot_hal_sym_crypto(key_object *key_obj, uint8_t key_id,
+                                  const uint8_t *iv, uint32_t iv_len,
+                                  const uint8_t *in, uint32_t in_len,
+                                  uint8_t *out, uint32_t *out_len,
+                                  sym_crypto_param_t *crypto_param
+                                 );
+/**
+ * @brief compute the signature result with the asymmetric algorithms.
+ *
+ * @param key_obj if this key object is not null, then use this parameter as the key, else use the internal key identified by the key id parameter.
+ * @param key_id identify the internal key.
+ * @param in input data
+ * @param in_len input data length.
+ * @param out output buffer.
+ * @param out_len input with the output buffer size, ouput the real data length.
+ * @param type @see asym_sign_verify_t
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t irot_hal_asym_priv_sign(key_object *key_obj, uint8_t key_id,
+                                      const uint8_t *in, uint32_t in_len,
+                                      uint8_t *out, uint32_t *out_len,
+                                      asym_sign_verify_t type);
+
+/**
+ * @brief decrypt the data with the asymmetric algorithms.
+ *
+ * @param key_obj if this key object is not null, then use this parameter as the key, else use the internal key identified by the key id parameter.
+ * @param key_id identify the internal key.
+ * @param in input data
+ * @param in_len input data length.
+ * @param out output buffer.
+ * @param out_len input with the output buffer size, ouput the real data length.
+ * @param padding @see asym_padding_t
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t irot_hal_asym_priv_decrypt(key_object *key_obj, uint8_t key_id,
+                                         const uint8_t *in, uint32_t in_len,
+                                         uint8_t *out, uint32_t *out_len,
+                                         irot_asym_padding_t padding);
+
+/**
+ * @brief compute the hash result with the hash algorithms.
+ *
+ * @param in input data.
+ * @param in_len input data length.
+ * @param out output data buffer.
+ * @param out_len input with the output buffer size, ouput the real hash data length.
+ * @param type @see hast_t
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t irot_hal_hash_sum(const uint8_t *in, uint32_t in_len, uint8_t *out, uint32_t *out_len, hash_t type);
+
+/**
+ * @brief generate random number with the given length.
+ *
+ * @param buf output buffer.
+ * @param len the output length to be generated with random bytes.
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t irot_hal_get_random(uint8_t *buf, uint32_t len);
+
+
+/*
+ * @brief irot_hal release.
+ * @param handle.
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t irot_hal_cleanup(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/se_driver.h b/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/se_driver.h
new file mode 100644
index 000000000..59f801d53
--- /dev/null
+++ b/3rdparty/experimental/optiga/externals/alios/security/irot/se/chipset/chip_template/include/se_driver.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015-2017 Alibaba Group Holding Limited
+ */
+
+#ifndef __SE_DRIVER_H__
+#define __SE_DRIVER_H__
+
+#include <stdint.h>
+#include "error_code.h"
+
+#ifdef __cplusplus
+extern "C"
+#endif
+
+/**
+ * @brief open session and connect to SE.
+ *
+ * @param handle
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t se_open_session(void **handle);
+
+/**
+ * @brief transmit APDU to SE.
+ *
+ * @param handle
+ * @param cmd_apdu Command APDU(ISO7816-4).
+ * @param cmd_len  Command APDU length
+ * @param rsp_buf  response APDU buffer.
+ * @param rsp_len  input with response APDU buffer length, output with real response APDU length (SW in last two bytes).
+ *
+ * @return
+ */
+irot_result_t se_transmit(void *handle, const uint8_t *cmd_apdu, uint32_t cmd_len, uint8_t *rsp_buf, uint32_t *rsp_len);
+
+/**
+ * @brief close session and disconnect to SE.
+ *
+ * @param handle
+ *
+ * @return @see irot_result_t
+ */
+irot_result_t se_close_session(void *handle);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/3rdparty/experimental/optiga/externals/alios/security/irot/se/src/core/km_to_irot.c b/3rdparty/experimental/optiga/externals/alios/security/irot/se/src/core/km_to_irot.c
new file mode 100644
index 000000000..ffdc59f4b
--- /dev/null
+++ b/3rdparty/experimental/optiga/externals/alios/security/irot/se/src/core/km_to_irot.c
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2015-2018 Alibaba Group Holding Limited
+ */
+
+
+#include <string.h>
+#include "chip_config.h"
+#include "km.h"
+#include "irot_hal.h"
+#include "log/chiplog.h"
+
+#define ID2_LEN                     24
+#define ID2_KEY_NAME                "id2_key"
+#define ID2_KEY_NAME_LEN            (sizeof(ID2_KEY_NAME) - 1)
+
+static void dump_chip_conf_info()
+{
+    switch (CHIP_TYPE_CONFIG) {
+        case CHIP_TYPE_SECURE_MCU: {
+            chip_log_debug("CHIP_TYPE_CONFIG           : %s\n", "CHIP_TYPE_SECURE_MCU");
+        }
+        break;
+        case CHIP_TYPE_SE_STD_CMD: {
+            chip_log_debug("CHIP_TYPE_CONFIG           : %s\n", "CHIP_TYPE_SE_STD_CMD");
+        }
+        break;
+        case CHIP_TYPE_SE_MTK_CMD: {
+            chip_log_debug("CHIP_TYPE_CONFIG           : %s\n", "CHIP_TYPE_SE_MTK_CMD");
+        }
+        case CHIP_TYPE_SE_OPTIGA_CMD: {
+            chip_log_debug("CHIP_TYPE_CONFIG           : %s\n", "CHIP_TYPE_SE_OPTIGA_CMD");
+        }
+        break;
+        default: {
+        } break;
+    }
+    switch (CHIP_CRYPTO_TYPE_CONFIG) {
+        case CHIP_CRYPTO_TYPE_3DES: {
+            chip_log_debug("CHIP_CRYPTO_TYPE_CONFIG    : %s\n", "CHIP_CRYPTO_TYPE_3DES");
+        }
+        break;
+        case CHIP_CRYPTO_TYPE_AES: {
+            chip_log_debug("CHIP_CRYPTO_TYPE_CONFIG    : %s\n", "CHIP_CRYPTO_TYPE_AES");
+        }
+        break;
+        case CHIP_CRYPTO_TYPE_RSA: {
+            chip_log_debug("CHIP_CRYPTO_TYPE_CONFIG    : %s\n", "CHIP_CRYPTO_TYPE_RSA");
+        }
+        break;
+        default: {
+        } break;
+    }
+    chip_log_debug("========================================\n");
+}
+
+uint32_t km_init()
+{
+    irot_result_t ret;
+    dump_chip_conf_info();
+    ret = irot_hal_init();
+    if (ret == IROT_SUCCESS) {
+        return KM_SUCCESS;
+    } else {
+        return KM_ERR_GENERIC;
+    }
+}
+
+void km_cleanup()
+{
+    irot_hal_cleanup();
+}
+
+uint32_t km_get_id2(uint8_t *id2, uint32_t *len)
+{
+    irot_result_t ret;
+    ret = irot_hal_get_id2(id2, len);
+    if (ret == IROT_ERROR_ITEM_NOT_FOUND) {
+        return KM_ERR_ITEM_NOT_FOUND;
+    } else if (ret != IROT_SUCCESS) {
+        return KM_ERR_GENERIC;
+    } else {
+        return KM_SUCCESS;
+    }
+}
+
+
+static uint32_t check_km_key_name(const char *name, const uint32_t name_len)
+{
+    if ((name == NULL) || (name_len != ID2_KEY_NAME_LEN)) {
+        return KM_ERR_BAD_PARAMS;
+    }
+    if (memcmp(ID2_KEY_NAME, name, ID2_KEY_NAME_LEN) != 0) {
+        return KM_ERR_BAD_PARAMS;
+    }
+    return KM_SUCCESS;
+}
+
+#if (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_3DES || CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES)
+uint32_t km_cipher(const char *name, const uint32_t name_len, km_sym_param *cipher_params, const uint8_t *iv,
+                   const uint32_t iv_len, uint8_t *src, size_t src_len, uint8_t *dest, size_t *dest_len)
+{
+    km_block_mode_type block_mode = cipher_params->cipher_param.block_mode;
+    km_padding_type padding_type = cipher_params->cipher_param.padding_type;
+    km_purpose_type purpose_type = cipher_params->cipher_param.purpose_type;
+    sym_crypto_param_t sym_crypto_param;
+    uint32_t out_len;
+    irot_result_t ret;
+    uint32_t kmret;
+
+    kmret = check_km_key_name(name, name_len);
+    if (kmret != KM_SUCCESS) {
+        return kmret;
+    }
+
+    if ((block_mode != KM_ECB) || (padding_type != KM_NO_PADDING)) {
+        return KM_ERR_BAD_PARAMS;
+    }
+
+    sym_crypto_param.block_mode = BLOCK_MODE_ECB;
+    sym_crypto_param.padding_type = SYM_PADDING_NOPADDING;
+
+    if (purpose_type == KM_PURPOSE_ENCRYPT) {
+        sym_crypto_param.mode = MODE_ENCRYPT;
+    } else if (purpose_type == KM_PURPOSE_DECRYPT) {
+        sym_crypto_param.mode = MODE_DECRYPT;
+    } else {
+        return KM_ERR_BAD_PARAMS;
+    }
+
+    out_len = *dest_len;
+    ret = irot_hal_sym_crypto(NULL, KEY_ID_ID2, NULL, 0, src, src_len, dest, &out_len, &sym_crypto_param);
+    if (ret != IROT_SUCCESS) {
+        return KM_ERR_GENERIC;
+    }
+    *dest_len = out_len;
+    return KM_SUCCESS;
+}
+#endif
+
+#if (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_RSA)
+uint32_t km_sign(const char *name, const uint32_t name_len, void *sign_params, const uint8_t *data,
+                 const size_t data_len, uint8_t *out, size_t *out_len)
+{
+    km_sign_param *kmsign_params = (km_sign_param *)sign_params;
+    uint32_t output_len;
+    asym_sign_verify_t asym_sign_verify_type;
+    irot_result_t ret;
+    uint32_t kmret;
+
+    kmret = check_km_key_name(name, name_len);
+    if (kmret != KM_SUCCESS) {
+        return kmret;
+    }
+
+    if (kmsign_params->padding_type != KM_PKCS1) {
+        return KM_ERR_BAD_PARAMS;
+    }
+
+    if (kmsign_params->digest_type == KM_SHA1) {
+        asym_sign_verify_type = ASYM_TYPE_RSA_SHA1_PKCS1;
+    } else if (kmsign_params->digest_type == KM_SHA256) {
+        asym_sign_verify_type = ASYM_TYPE_RSA_SHA256_PKCS1;
+    } else {
+        return KM_ERR_BAD_PARAMS;
+    }
+
+    output_len = *out_len;
+    ret = irot_hal_asym_priv_sign(NULL, 0, data, data_len, out, &output_len, asym_sign_verify_type);
+    if (ret != IROT_SUCCESS) {
+        return KM_ERR_GENERIC;
+    }
+    *out_len = output_len;
+    return KM_SUCCESS;
+}
+
+uint32_t km_asym_decrypt(const char *name, const uint32_t name_len, void *enc_params, const uint8_t *src,
+                         const size_t src_len, uint8_t *dest, size_t *dest_len)
+{
+    km_enc_param *kmenc_params = enc_params;
+    uint32_t out_len;
+    irot_result_t ret;
+    uint32_t kmret;
+
+    kmret = check_km_key_name(name, name_len);
+    if (kmret != KM_SUCCESS) {
+        return kmret;
+    }
+
+    if (kmenc_params->padding_type != KM_PKCS1) {
+        return KM_ERR_BAD_PARAMS;
+    }
+
+    out_len = *dest_len;
+    ret = irot_hal_asym_priv_decrypt(NULL, 0, src, src_len, dest, &out_len, ASYM_PADDING_PKCS1);
+    if (ret != IROT_SUCCESS) {
+        return KM_ERR_GENERIC;
+    }
+    *dest_len = out_len;
+    return KM_SUCCESS;
+}
+
+#endif
+
+
+uint32_t km_set_id2(uint8_t *id2, uint32_t len)
+{
+    return KM_ERR_NOT_SUPPORTED;
+}
+
+uint32_t km_import_key(const char *name, const uint32_t name_len, km_format_t format, const km_key_data_t *key_data,
+                       const uint32_t key_data_len)
+{
+    return KM_ERR_NOT_SUPPORTED;
+}
+
+uint32_t km_get_attestation(uint8_t *id, uint32_t *id_len)
+{
+    return KM_ERR_NOT_SUPPORTED;
+}
+
diff --git a/3rdparty/experimental/optiga/externals/alios/security/irot/se/src/core/optiga_se_adapter.c b/3rdparty/experimental/optiga/externals/alios/security/irot/se/src/core/optiga_se_adapter.c
new file mode 100644
index 000000000..802bea84f
--- /dev/null
+++ b/3rdparty/experimental/optiga/externals/alios/security/irot/se/src/core/optiga_se_adapter.c
@@ -0,0 +1,702 @@
+/*
+ * Copyright (C) 2015-2018 Alibaba Group Holding Limited
+ */
+
+#include <stdio.h>
+//lint --e{766} suppress "string.h inclusion as its part of template"
+#include <string.h>
+#include "chip_config.h"
+#include "irot_hal.h"
+
+#if (CHIP_APDU_CMD_ADAPTER && (CHIP_TYPE_CONFIG == CHIP_TYPE_SE_OPTIGA_CMD))
+#include "optiga/optiga_util.h"
+#include "optiga/optiga_crypt.h"
+#include "optiga/pal/pal_os_timer.h"
+
+/* Macro to enable the OPTIGA chip to power off when irot_cleanup is invoked. By default, this MACRO is disabled.
+ * If the macro is enabled, the HOST waits until the security event counter on OPTIGA reaches 0 and then 
+ * closes the application on OPTIGA.
+ */
+//#define OPTIGA_SE_ENABLE_POWER_DOWN
+// Device id to store ID of the Ali ID2 device
+#define OPTIGA_SE_DEVICE_ID_OID         (0xF1D0)
+
+// Length of the Ali ID2 device id      
+#define OPTIGA_SE_DEVICE_ID_LEN         (12U)
+
+#if (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES)
+// Symmetric key object OID
+#define IROT_HAL_OPTIGA_KEY_OID         ((optiga_key_id_t)0xE200)
+#elif (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_RSA)
+// Asymmetric RSA key object OID
+#define IROT_HAL_OPTIGA_KEY_OID         ((optiga_key_id_t)0xE0FC)
+#else                                   
+#define IROT_HAL_OPTIGA_KEY_OID         ((optiga_key_id_t)0x0000)
+#endif
+
+// Mask for comms error
+#define OPTIGA_SE_LIB_ERROR_LAYER_MASK  (0xFF00)
+// Comms layer error code
+#define OPTIGA_SE_COMMS_LAYER_ERROR     (0x0100)
+// Maximum size of uint16_t
+#define OPTIGA_SE_MAX_OUTPUT_LENGTH     (0x0000FFFF)
+
+// static variable to store util instance
+_STATIC_H optiga_util_t * p_irot_hal_util_instance = NULL;
+// static variable to store crypt instance
+_STATIC_H optiga_crypt_t * p_irot_hal_crypt_instance = NULL;
+
+_STATIC_H volatile optiga_lib_status_t irot_hal_util_status;
+_STATIC_H volatile optiga_lib_status_t irot_hal_crypt_status;
+
+// IROT HAL initialization status
+_STATIC_H bool_t irot_hal_init_status = FALSE;
+
+//lint --e{818} suppress "argument "context" is not used in this usecase"
+_STATIC_H void irot_hal_util_callback(void * context, optiga_lib_status_t return_status)
+{
+    irot_hal_util_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+//lint --e{818} suppress "argument "context" is not used in this usecase"
+_STATIC_H void irot_hal_crypt_callback(void * context, optiga_lib_status_t return_status)
+{
+    irot_hal_crypt_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+irot_result_t irot_hal_init(void)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+
+    do
+    {
+        // If instances are already created, return success
+        if((NULL != p_irot_hal_util_instance) && (NULL != p_irot_hal_crypt_instance))
+        {
+            return_status = IROT_SUCCESS;
+            irot_hal_init_status = TRUE;
+            break;
+        }
+
+        // Create util instance
+        p_irot_hal_util_instance = optiga_util_create(0, irot_hal_util_callback, NULL);
+        if (NULL == p_irot_hal_util_instance)
+        {
+            break;
+        }
+
+        // Create crypt instance
+        p_irot_hal_crypt_instance = optiga_crypt_create(0, irot_hal_crypt_callback, NULL);
+        if (NULL == p_irot_hal_crypt_instance)
+        {
+            break;
+        }
+
+        // Power On OPTIGA and send Open Application command
+        irot_hal_util_status = OPTIGA_LIB_BUSY;
+
+        if (OPTIGA_LIB_SUCCESS != optiga_util_open_application(p_irot_hal_util_instance, 0))
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == irot_hal_util_status)
+        {
+            //Wait until the optiga_util_open_application is completed
+        }
+        //optiga util open application failed
+        if (OPTIGA_LIB_SUCCESS != irot_hal_util_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_util_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            break;
+        }
+        return_status = IROT_SUCCESS;
+        irot_hal_init_status = TRUE;
+    } while (FALSE);
+
+    if ((IROT_SUCCESS != return_status) && (NULL != p_irot_hal_crypt_instance))
+    {
+        (void)optiga_crypt_destroy(p_irot_hal_crypt_instance);
+        p_irot_hal_crypt_instance = NULL;
+    }
+
+    if ((IROT_SUCCESS != return_status) && (NULL != p_irot_hal_util_instance))
+    {
+        (void)optiga_util_destroy(p_irot_hal_util_instance);
+        p_irot_hal_util_instance = NULL;
+    }
+    return (return_status);
+}
+
+irot_result_t irot_hal_cleanup(void)
+{
+    irot_result_t return_status;
+    
+#ifdef OPTIGA_SE_ENABLE_POWER_DOWN
+    uint16_t bytes_to_read = 1;
+    uint8_t security_event_counter = 0;
+
+    do
+    {
+        // If instances are already destroyed, return success
+        if(FALSE == irot_hal_init_status)
+        {
+            return_status = IROT_SUCCESS;
+            break;
+        }
+        /**
+        * Before performing power down, SEC value should be 0
+        */
+        do
+        {
+            irot_hal_util_status = OPTIGA_LIB_BUSY;
+            return_status = IROT_ERROR_GENERIC;
+            if (OPTIGA_LIB_SUCCESS != optiga_util_read_data(p_irot_hal_util_instance,
+                                                    0xE0C5,
+                                                    0x0000,
+                                                    &security_event_counter,
+                                                    &bytes_to_read))
+            {
+                break;
+            }
+
+            while (OPTIGA_LIB_BUSY == irot_hal_util_status)
+            {
+                //Wait until the optiga_util_read_data operation is completed
+            }
+            //Reading the data object failed.
+            if (OPTIGA_LIB_SUCCESS != irot_hal_util_status)
+            {
+                break;
+            }
+
+            // Provide delay of 500ms in case SEC value is not equal to 0
+            if (0 != security_event_counter)
+            {
+                pal_os_timer_delay_in_milliseconds(500);
+            }
+        } while (0 != security_event_counter);
+
+        // Send Close Application command and Power Off OPTIGA
+        irot_hal_util_status = OPTIGA_LIB_BUSY;
+        return_status = IROT_ERROR_GENERIC;
+        if (OPTIGA_LIB_SUCCESS != optiga_util_close_application(p_irot_hal_util_instance, 0))
+        {
+            break;
+        }
+
+        while (irot_hal_util_status == OPTIGA_LIB_BUSY)
+        {
+        //Wait until the optiga_util_close_application is completed
+        }
+
+        //optiga util close application failed
+        if (OPTIGA_LIB_SUCCESS != irot_hal_util_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_util_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+
+    if ((NULL != p_irot_hal_crypt_instance) && OPTIGA_LIB_SUCCESS != optiga_crypt_destroy(p_irot_hal_crypt_instance))
+    {
+        if (IROT_SUCCESS == return_status)
+        {
+            return_status = IROT_ERROR_GENERIC;
+        }
+    }
+    p_irot_hal_crypt_instance = NULL;
+
+    if ((NULL != p_irot_hal_util_instance) && OPTIGA_LIB_SUCCESS != optiga_util_destroy(p_irot_hal_util_instance))
+    {
+        if (IROT_SUCCESS == return_status)
+        {
+            return_status = IROT_ERROR_GENERIC;
+        }
+    }
+    p_irot_hal_util_instance = NULL;
+#else
+    return_status = IROT_SUCCESS;
+#endif
+    irot_hal_init_status = FALSE;
+    return (return_status);
+}
+
+irot_result_t irot_hal_get_id2(uint8_t * id2, uint32_t * len)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+    
+    do
+    {
+        if (FALSE == irot_hal_init_status)
+        {
+            break;
+        }
+
+        // Check if the 'len' value passed is lesser than the minimum value Device ID length
+        if (OPTIGA_SE_DEVICE_ID_LEN > *len)
+        {
+            return_status = IROT_ERROR_SHORT_BUFFER;
+            break;
+        }
+        
+        // Check if the 'len' value passed is greater than the max length accepted by optiga_util_read_data
+        if (OPTIGA_SE_MAX_OUTPUT_LENGTH < *len)
+        {
+            *len = OPTIGA_SE_MAX_OUTPUT_LENGTH;
+        }
+        
+        irot_hal_util_status = OPTIGA_LIB_BUSY;
+        // Read device ID from the OID configured in OPTIGA_SE_DEVICE_ID_OID
+        if (OPTIGA_LIB_SUCCESS != optiga_util_read_data(p_irot_hal_util_instance,
+                                                        OPTIGA_SE_DEVICE_ID_OID,
+                                                        0x0000,
+                                                        id2,
+                                                        ((uint16_t * )(void * )len)))
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == irot_hal_util_status)
+        {
+            //Wait until the optiga_util_read_data operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_util_status)
+        {
+            do
+            {
+                if (OPTIGA_DEVICE_ERROR == (irot_hal_util_status & OPTIGA_DEVICE_ERROR))
+                {
+                    //Reading the device ID failed.
+                    return_status = IROT_ERROR_ITEM_NOT_FOUND;
+                    break;
+                }
+
+                if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_util_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+                {
+                    //Error from OPTIGA Comms.
+                    return_status = IROT_ERROR_COMMUNICATION;
+                    break;
+                }
+            } while (FALSE);
+            break;
+        }
+        // Check if the device ID received matches the expected length
+        if (OPTIGA_SE_DEVICE_ID_LEN != *len)
+        {
+            return_status = IROT_ERROR_ITEM_NOT_FOUND;
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+
+    if (IROT_SUCCESS != return_status)
+    {
+        *len = 0;
+    }
+
+    return (return_status);
+}
+
+#if ((CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES) || (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_3DES))
+//lint --e{715} suppress "argument "key_id", "iv" and "iv_len" is not used"
+irot_result_t irot_hal_sym_crypto(key_object * key_obj,
+                                  uint8_t key_id,
+                                  const uint8_t * iv,
+                                  uint32_t iv_len,
+                                  const uint8_t * in,
+                                  uint32_t in_len,
+                                  uint8_t * out,
+                                  uint32_t * out_len,
+                                  sym_crypto_param_t * crypto_param)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+  
+    do
+    {
+        // Check for crypt instance NULL 
+        if (FALSE == irot_hal_init_status)
+        {
+            break;
+        }
+
+        // Check for key object NULL
+        if (NULL != key_obj)
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+            break;
+        }
+        
+        // Check the mode for encrypt or decrypt
+        if ((MODE_DECRYPT != crypto_param->mode) && (MODE_ENCRYPT != crypto_param->mode))
+        {
+            return_status = IROT_ERROR_BAD_PARAMETERS;
+            break;
+        }
+        
+        // Check the mode of operation as ECB and no padding
+        if ((BLOCK_MODE_ECB != crypto_param->block_mode) || (SYM_PADDING_NOPADDING != crypto_param->padding_type))
+        {
+            return_status = IROT_ERROR_NOT_IMPLEMENTED;
+            break;
+        }
+                                                        
+        // Check for out buffer length
+        if (*out_len < in_len)
+        {
+            return_status = IROT_ERROR_SHORT_BUFFER;
+            break;
+        }
+        
+        /*
+          Check if request is for decryption or encryption
+        */
+        irot_hal_crypt_status = OPTIGA_LIB_BUSY;
+        if (MODE_DECRYPT == crypto_param->mode)
+        {
+            // Decrypt input data based on symmetric key stored in IROT_HAL_OPTIGA_SYMMETRIC_KEY_OID
+            if (OPTIGA_LIB_SUCCESS != optiga_crypt_symmetric_decrypt_ecb(p_irot_hal_crypt_instance,
+                                                                         IROT_HAL_OPTIGA_KEY_OID,
+                                                                         in,
+                                                                         in_len,
+                                                                         out,
+                                                                         out_len))
+            {
+                break;
+            }
+        }
+        else 
+        {
+            // Encrypt input data based on symmetric key stored in IROT_HAL_OPTIGA_SYMMETRIC_KEY_OID
+            if (OPTIGA_LIB_SUCCESS != optiga_crypt_symmetric_encrypt_ecb(p_irot_hal_crypt_instance,
+                                                                         IROT_HAL_OPTIGA_KEY_OID,
+                                                                         in,
+                                                                         in_len,
+                                                                         out,
+                                                                         out_len))
+            {
+                break;
+            }
+        }
+
+
+
+        while (OPTIGA_LIB_BUSY == irot_hal_crypt_status)
+        {
+            //Wait until the encrypt/decrypt operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_crypt_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_crypt_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+    
+    if (IROT_SUCCESS != return_status)
+    {
+        *out_len = 0;
+    }
+    return (return_status);
+}
+#endif // ((CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES) || (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_3DES))
+
+irot_result_t irot_hal_get_random(uint8_t *buf, uint32_t len)
+{
+    // chip_log function is not implemented
+    
+    // API returns IROT_ERROR_NOT_IMPLEMENTED as it's not implemented
+    return IROT_ERROR_NOT_IMPLEMENTED;
+
+}
+
+irot_result_t irot_hal_hash_sum(const uint8_t *in, uint32_t in_len, uint8_t *out, uint32_t *out_len, hash_t type)
+{
+    // chip_log function is not implemented
+    
+    // API returns IROT_ERROR_NOT_IMPLEMENTED as it's not implemented
+    return IROT_ERROR_NOT_IMPLEMENTED;
+
+}
+
+#if (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_RSA)
+static irot_result_t irot_hal_generate_hash(const uint8_t *in_data, 
+                                            uint32_t *in_data_len, 
+                                            uint8_t *out_data, 
+                                            uint16_t *out_data_len, 
+                                            optiga_rsa_signature_scheme_t type)
+{
+
+#define OPTIGA_SE_SHA_256_HASH_OUT_LENGTH  (0x20)  
+#define OPTIGA_SE_SHA_384_HASH_OUT_LENGTH  (0x30)  
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+    hash_data_from_host_t hash_data_host;
+    optiga_hash_type_t hash_type;
+
+    do
+    {
+        if (OPTIGA_RSASSA_PKCS1_V15_SHA256 == type)
+        {
+            *out_data_len = OPTIGA_SE_SHA_256_HASH_OUT_LENGTH;
+            hash_type = OPTIGA_HASH_TYPE_SHA_256;
+        }  
+        else if (OPTIGA_RSASSA_PKCS1_V15_SHA384 == type)
+        {
+            return_status = IROT_ERROR_NOT_IMPLEMENTED;
+            break;
+        }
+        hash_data_host.buffer = in_data;
+        hash_data_host.length = *in_data_len;
+        irot_hal_crypt_status = OPTIGA_LIB_BUSY;  
+        if (OPTIGA_LIB_SUCCESS != optiga_crypt_hash(p_irot_hal_crypt_instance, 
+                                                    hash_type, 
+                                                    OPTIGA_CRYPT_HOST_DATA, 
+                                                    &hash_data_host, 
+                                                    out_data))
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == irot_hal_crypt_status)
+        {
+            //Wait until the optiga_crypt_hash operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_crypt_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_crypt_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            break;
+        }
+
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+#undef OPTIGA_SE_SHA_256_HASH_OUT_LENGTH 
+#undef OPTIGA_SE_SHA_384_HASH_OUT_LENGTH
+    return (return_status);
+}
+static irot_result_t irot_hal_get_signature_scheme(asym_sign_verify_t type, 
+                                                   optiga_rsa_signature_scheme_t *signature_scheme)
+{
+    irot_result_t return_status = IROT_SUCCESS;
+    switch(type)
+    {
+        case ASYM_TYPE_RSA_SHA256_PKCS1: 
+        {
+            *signature_scheme = OPTIGA_RSASSA_PKCS1_V15_SHA256;
+        }
+        break;
+        case ASYM_TYPE_RSA_SHA384_PKCS1: 
+        {
+            *signature_scheme = OPTIGA_RSASSA_PKCS1_V15_SHA384;
+        }
+        break;
+        default :
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+        }
+        break;
+    }
+    return (return_status);
+}
+
+irot_result_t irot_hal_asym_priv_sign(key_object *key_obj, 
+                                      uint8_t key_id, 
+                                      const uint8_t *in, 
+                                      uint32_t in_len,
+                                      uint8_t *out, 
+                                      uint32_t *out_len, 
+                                      asym_sign_verify_t type)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+    optiga_rsa_signature_scheme_t signature_scheme;
+    uint16_t digest_len;
+#define OPTIGA_SE_DIGEST_LENGTH (0x30)
+
+    uint8_t digest[OPTIGA_SE_DIGEST_LENGTH];
+    do
+    {   
+        // Check for crypt instance NULL 
+        if (FALSE == irot_hal_init_status)
+        {
+            break;
+        }
+
+        // Check for key object NULL
+        if (NULL != key_obj)
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+            break;
+        }
+
+        // Check supported scheme
+        if (IROT_SUCCESS != irot_hal_get_signature_scheme(type,
+                                                          &signature_scheme))
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+            break;
+        }
+        
+        //Generate hash of input data
+        return_status = irot_hal_generate_hash(in, 
+                                               &in_len, 
+                                               digest, 
+                                               &digest_len,
+                                               signature_scheme);
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+        return_status = IROT_ERROR_GENERIC;
+        
+        // Out put boundary check
+        *out_len = (*out_len > OPTIGA_SE_MAX_OUTPUT_LENGTH) ? (OPTIGA_SE_MAX_OUTPUT_LENGTH) : (*out_len);
+        
+        irot_hal_crypt_status = OPTIGA_LIB_BUSY;        
+        // Generate signature of input data based on asymmetric RSA key stored in IROT_HAL_OPTIGA_KEY_OID
+        if (OPTIGA_LIB_SUCCESS != optiga_crypt_rsa_sign(p_irot_hal_crypt_instance,
+                                                        signature_scheme,
+                                                        digest,
+                                                        (uint8_t)digest_len,
+                                                        IROT_HAL_OPTIGA_KEY_OID,
+                                                        out,
+                                                        (uint16_t *)out_len,
+                                                        0x0000))
+        {
+            break;
+        }
+        while (OPTIGA_LIB_BUSY == irot_hal_crypt_status)
+        {
+            //Wait until the rsa sign operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_crypt_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_crypt_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            else if (OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT & irot_hal_crypt_status)
+            {
+                return_status = IROT_ERROR_SHORT_BUFFER;
+            }
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+    
+    if (IROT_SUCCESS != return_status)
+    {
+        *out_len = 0;
+    }    
+#undef OPTIGA_SE_DIGEST_LENGTH
+    return (return_status);
+}
+
+irot_result_t irot_hal_asym_priv_decrypt(key_object *key_obj,
+                                         uint8_t key_id, 
+                                         const uint8_t *in,
+                                         uint32_t in_len,
+                                         uint8_t *out, 
+                                         uint32_t *out_len, 
+                                         irot_asym_padding_t padding)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+  
+    do
+    {
+        // Check for crypt instance NULL 
+        if (FALSE == irot_hal_init_status)
+        {
+            break;
+        }
+
+        // Check for key object NULL, padding and in_len size
+        if ((NULL != key_obj) || (ASYM_PADDING_PKCS1 != padding) || (in_len != LENGTH_RSA_1024))
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+            break;
+        }
+
+        *out_len = (*out_len > OPTIGA_SE_MAX_OUTPUT_LENGTH) ? (OPTIGA_SE_MAX_OUTPUT_LENGTH) : (*out_len);
+        
+        /*
+        * Decrypt input data based on asymmetric key stored in IROT_HAL_OPTIGA_KEY_OID
+        */
+        irot_hal_crypt_status = OPTIGA_LIB_BUSY;
+        // RSA decryption
+        if (OPTIGA_LIB_SUCCESS != optiga_crypt_rsa_decrypt_and_export(p_irot_hal_crypt_instance,
+                                                                      OPTIGA_RSAES_PKCS1_V15,
+                                                                      in,
+                                                                      in_len,
+                                                                      NULL,
+                                                                      0,
+                                                                      IROT_HAL_OPTIGA_KEY_OID,
+                                                                      out,
+                                                                      (uint16_t *)out_len))
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == irot_hal_crypt_status)
+        {
+            //Wait until the decrypt operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_crypt_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_crypt_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            else if (OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT == (OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT & irot_hal_crypt_status))
+            {
+                return_status = IROT_ERROR_SHORT_BUFFER;
+            }
+                
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+    
+    if (IROT_SUCCESS != return_status)
+    {
+        *out_len = 0;
+    }
+    
+    return (return_status);
+}
+#endif
+
+#endif
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/cmd/optiga_cmd.c b/3rdparty/experimental/optiga/optiga/cmd/optiga_cmd.c
new file mode 100644
index 000000000..1abcfcd87
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/cmd/optiga_cmd.c
@@ -0,0 +1,4468 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_cmd.c
+*
+* \brief   This file implements cmd modules which covers OPTIGA command formation, locking mechanism, session
+*          acquisition and asynchronous data handling
+*
+* \ingroup  grOptigaCmd
+*
+* @{
+*/
+
+
+#include "optiga/cmd/optiga_cmd.h"
+#include "optiga/common/optiga_lib_common_internal.h"
+#include "optiga/common/optiga_lib_logger.h"
+#include "optiga/comms/optiga_comms.h"
+#include "optiga/pal/pal_os_event.h"
+#include "optiga/pal/pal_os_lock.h"
+#include "optiga/pal/pal_os_timer.h"
+#include "optiga/pal/pal_os_memory.h"
+#include "optiga/pal/pal_ifx_i2c_config.h"
+
+//cmd byte for clearing last error code
+#define OPTIGA_CMD_CLEAR_LAST_ERROR                      (0x80)
+//cmd byte for OpenApplication command
+#define OPTIGA_CMD_OPEN_APPLICATION                      (0x70 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for CloseApplication command
+#define OPTIGA_CMD_CLOSE_APPLICATION                     (0x71 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for GetDataObject command
+#define OPTIGA_CMD_GET_DATA_OBJECT                       (0x01 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for SetDataObject command
+#define OPTIGA_CMD_SET_DATA_OBJECT                       (0x02 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for GetRandom command
+#define OPTIGA_CMD_GET_RANDOM                            (0x0C | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for CalcHash command
+#define OPTIGA_CMD_CALC_HASH                             (0x30 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for CalcSign command
+#define OPTIGA_CMD_CALC_SIGN                             (0x31 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for VerifySign command
+#define OPTIGA_CMD_VERIFY_SIGN                           (0x32 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for CalcSsec command
+#define OPTIGA_CMD_CALC_SSEC                             (0x33 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for DeriveKey command
+#define OPTIGA_CMD_DERIVE_KEY                            (0x34 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for GenKeyPair command
+#define OPTIGA_CMD_GEN_KEYPAIR                           (0x38 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for EncryptAsym command
+#define OPTIGA_CMD_ENCRYPT_ASYM                          (0x1E | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for DecryptAsym command
+#define OPTIGA_CMD_DECRYPT_ASYM                          (0x1F | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for SetObjectProtected command
+#define OPTIGA_CMD_SET_OBJECT_PROTECTED                  (0x03 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for EncryptSym command
+#define OPTIGA_CMD_ENCRYPT_SYM                           (0x14 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for DecryptSym command
+#define OPTIGA_CMD_DECRYPT_SYM                           (0x15 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+//cmd byte for GenSymKey command
+#define OPTIGA_CMD_GEN_SYM_KEY                           (0x39 | OPTIGA_CMD_CLEAR_LAST_ERROR)
+
+
+#define OPTIGA_CMD_MAX_NUMBER_OF_SESSIONS                (0x04)
+#define OPTIGA_CMD_START_SESSION_OID                     (0xE100)
+
+// Considering the size w.r.t maximum APDU size + shielded connection if enabled.
+#define OPTIGA_CMD_TOTAL_COMMS_BUFFER_SIZE               (OPTIGA_MAX_COMMS_BUFFER_SIZE + OPTIGA_COMMS_PRL_OVERHEAD)
+
+#define OPTIGA_CMD_APDU_HEADER_SIZE                      (0x04)
+
+#define OPTIGA_CMD_LAST_ERROR_CODE                       (0xF1C2)
+
+#define OPTIGA_CMD_APDU_INDATA_OFFSET                    (OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_COMMS_DATA_OFFSET)
+// Hash header size(hash_input_header_size + context_header_size)
+#define OPTIGA_CMD_HASH_HEADER_SIZE                      (0x06)
+// Intermediate context header size
+#define OPTIGA_CMD_INTERMEDIATE_CONTEXT_HEADER           (0x03)
+// Zero length or value
+#define OPTIGA_CMD_ZERO_LENGTH_OR_VALUE                  (0x0000)
+// One length or value
+#define OPTIGA_CMD_ONE_LENGTH_OR_VALUE                   (0x0001)
+// OID data length
+#define OPTIGA_CMD_OID_DATA_LENGTH                       (0x0006)
+// Number of bits in a byte
+#define OPTIGA_CMD_NO_OF_BITS_IN_BYTE                    (0x0008)
+
+//Number of bytes in tag
+#define OPTIGA_CMD_NO_OF_BYTES_IN_TAG                    (0x01)
+
+//Number of bytes in OFFSET
+#define OPTIGA_CMD_UINT16_SIZE_IN_BYTES                  (0x02)
+
+#define OPTIGA_CMD_APDU_SUCCESS                          (0x00)
+#define OPTIGA_CMD_APDU_FAILURE                          (0xFF)
+
+#define OPTIGA_CMD_WRITE_ONLY                                   (0x00)
+#define OPTIGA_CMD_READ_DATA                                    (0x00)
+#define OPTIGA_CMD_GET_DATA_OBJECT_NO_ERROR_CLEAR               (0x01)
+
+//Calc sign tag values
+#define OPTIGA_CMD_SIGN_DIGEST_TAG                              (0x01)
+#define OPTIGA_CMD_SIGN_OID_TAG                                 (0x03)
+#define OPTIGA_CMD_SIGN_OID_LEN                                 (0x0002)
+
+//Calc SSec tag values
+#define OPTIGA_CMD_SSEC_PRIVATE_KEY_TAG                         (0x01)
+#define OPTIGA_CMD_SSEC_PRIVATE_KEY_LEN                         (0x0002)
+#define OPTIGA_CMD_SSEC_ALG_ID_TAG                              (0x05)
+#define OPTIGA_CMD_SSEC_ALG_ID_LEN                              (0x01)
+#define OPTIGA_CMD_SSEC_PUB_KEY_TAG                             (0x06)
+#define OPTIGA_CMD_SSEC_EXPORT_TAG                              (0x07)
+#define OPTIGA_CMD_SSEC_EXPORT_LEN                              (0x0000)
+#define OPTIGA_CMD_SSEC_STORE_SESSION_TAG                       (0x08)
+#define OPTIGA_CMD_SSEC_STORE_SESSION_LEN                       (0x0002)
+
+//Verify sign tag values
+#define OPTIGA_CMD_VERIFY_SIGN_DIGEST_TAG                       (0x01)
+#define OPTIGA_CMD_VERIFY_SIGN_SIGNATURE_TAG                    (0x02)
+#define OPTIGA_CMD_VERIFY_SIGN_PUB_KEY_CERT_OID_TAG             (0x04)
+#define OPTIGA_CMD_VERIFY_SIGN_PUB_KEY_CERT_OID_LENGTH          (0x0002)
+#define OPTIGA_CMD_VERIFY_ALGO_ID_TAG                           (0x05)
+#define OPTIGA_CMD_VERIFY_ALGO_ID_LENGTH                        (0x0001)
+#define OPTIGA_CMD_VERIFY_PUBLIC_KEY_TAG                        (0x06)
+
+//Generate key pair tag and length value
+#define OPTIGA_CMD_GEN_KEY_PAIR_PRIVATE_KEY_OID_TAG             (0x01)
+#define OPTIGA_CMD_GEN_KEY_PAIR_PRIVATE_KEY_OID_LENGTH          (0x0002)
+#define OPTIGA_CMD_GEN_KEY_PAIR_KEY_USAGE_TAG                   (0x02)
+#define OPTIGA_CMD_GEN_KEY_PAIR_KEY_USAGE_LENGTH                (0x0001)
+#define OPTIGA_CMD_GEN_KEY_PAIR_EXPORT_KEY_TAG                  (0x07)
+#define OPTIGA_CMD_GEN_KEY_PAIR_EXPORT_KEY_LENGTH               (0x0000)
+#define OPTIGA_CMD_GEN_KEY_PAIR_PUBLIC_KEY_TAG                  (0x02)
+#define OPTIGA_CMD_GEN_KEY_PAIR_PRIVATE_KEY_TAG                 (0x01)
+
+//Derive key tag value
+#define OPTIGA_CMD_DERIVE_KEY_SEC_OID_TAG                       (0x01)
+#define OPTIGA_CMD_DERIVE_KEY_SEC_OID_TAG_LENGTH                (0x0002)
+#define OPTIGA_CMD_DERIVE_KEY_DERIVATION_DATA_TAG               (0x02)
+#define OPTIGA_CMD_DERIVE_KEY_KEY_LEN_TAG_LENGTH                (0x0002)
+#define OPTIGA_CMD_DERIVE_KEY_KEY_LEN_TAG                       (0x03)
+#define OPTIGA_CMD_DERIVE_KEY_EXPORT_TAG                        (0x07)
+#define OPTIGA_CMD_DERIVE_KEY_STORE_TAG                         (0x08)
+#define OPTIGA_CMD_DERIVE_KEY_STORE_TAG_LENGTH                  (0x0002)
+#define OPTIGA_CMD_DERIVE_KEY_DERIVE_KEY_LEN_MIN                (0x10)
+#define OPTIGA_CMD_DERIVE_KEY_INFO_TAG                          (0x04)
+
+//Encrypt asym tag values
+#define OPTIGA_CMD_ENCRYPT_ASYM_SESSION_OID_TAG                 (0x02)
+#define OPTIGA_CMD_ENCRYPT_ASYM_SESSION_OID_LENGTH              (0x0002)
+#define OPTIGA_CMD_ENCRYPT_ASYM_MESSAGE_TAG                     (0x61)
+#define OPTIGA_CMD_ENCRYPT_ASYM_PUB_KEY_CERT_OID_TAG            (0x04)
+#define OPTIGA_CMD_ENCRYPT_ASYM_PUB_KEY_CERT_OID_LENGTH         (0x0002)
+#define OPTIGA_CMD_ENCRYPT_ASYM_ALGO_ID_TAG                     (0x05)
+#define OPTIGA_CMD_ENCRYPT_ASYM_ALGO_ID_LENGTH                  (0x0001)
+#define OPTIGA_CMD_ENCRYPT_ASYM_PUBLIC_KEY_TAG                  (0x06)
+
+//Decrypt asym key tag value
+#define OPTIGA_CMD_DECRYPT_ASYM_ENCRYPT_MESSAGE_TAG             (0x61)
+#define OPTIGA_CMD_DECRYPT_ASYM_DECRYPT_KEY_TAG                 (0x03)
+#define OPTIGA_CMD_DECRYPT_ASYM_DECRYPT_KEY_LENGTH              (0x0002)
+#define OPTIGA_CMD_DECRYPT_ASYM_SESSION_OID_TAG                 (0x02)
+#define OPTIGA_CMD_DECRYPT_ASYM_SESSION_OID_LENGTH              (0x0002)
+
+#define OPTIGA_PROTECTION_LEVEL_MASK                            (0x03)
+        
+#define OPTIGA_CMD_ERROR_CODE_PREPARE                           (0x01)
+#define OPTIGA_CMD_ERROR_CODE_TX                                (0x02)
+#define OPTIGA_CMD_ERROR_CODE_RX                                (0x03)
+#define OPTIGA_CMD_ERROR_CODE_STATE_MASK                        (0x03)
+#define OPTIGA_CMD_ENTER_HANDLER_CALL_MASK                      (0x80)
+#define OPTIGA_CMD_ENTER_HANDLER_CALL                           (0x80)
+#define OPTIGA_CMD_EXIT_HANDLER_CALL                            (0x00)
+#define OPTIGA_CMD_OUT_OF_BOUNDARY_ERROR                        (0x08)
+
+///Symmetric encrypt decrypt hmac tag value
+#define OPTIGA_CMD_ENC_DEC_SYM_ASSOCIATED_DATA_TAG              (0x40)
+#define OPTIGA_CMD_ENC_DEC_SYM_IV_TAG                           (0x41)
+#define OPTIGA_CMD_ENC_DEC_SYM_TOTAL_DATA_LENGTH_TAG            (0x42)
+#define OPTIGA_CMD_ENC_DEC_SYM_VERIFICATION_DATA_TAG            (0x43)
+#define OPTIGA_CMD_ENC_DEC_SYM_OUT_DATA_TAG                     (0x61)
+
+#define OPTIGA_CMD_RESET_SEQUENCE                               (0xFF)
+#define OPTIGA_CMD_SYM_MAX_INDATA_LENGTH                        (640U)
+
+//RSA pre master optional data tag and length value
+#define OPTIGA_CMD_RSA_PRE_MASTER_OPTIONAL_DATA_TAG             (0x41)
+
+/// Param type for optiga pre master secret
+#define OPTIGA_CMD_RANDOM_PARAM_TYPE_PRE_MASTER_SECRET          (0x04)
+
+/// Set object protected tag
+#define OPTIGA_CMD_SET_OBJECT_PROTECTED_TAG                     (0x30)
+
+#define OPTIGA_CMD_TAG_LENGTH_SIZE                              (0x03)
+#define OPTIGA_CMD_PARAM_INITIALIZE_APP_CONTEXT                 (0x00)
+
+//Generate symmetric key tag and length value
+#define OPTIGA_CMD_GEN_SYM_KEY_OID_TAG                          (0x01)
+#define OPTIGA_CMD_GEN_SYM_KEY_OID_LENGTH                       (0x0002)
+#define OPTIGA_CMD_GEN_SYM_KEY_USAGE_TAG                        (0x02)
+#define OPTIGA_CMD_GEN_SYM_KEY_USAGE_LENGTH                     (0x0001)
+#define OPTIGA_CMD_GEN_SYM_KEY_EXPORT_TAG                       (0x07)
+#define OPTIGA_CMD_GEN_SYM_KEY_EXPORT_LENGTH                    (0x0000)
+#define OPTIGA_CMD_GEN_SYM_KEY_TAG                              (0x01)
+
+// Session OID length in case of HMAC verify
+#define OPTIGA_CMD_DECRYPT_SYM_SESSION_OID_LENGTH               (0x0002)
+
+// Symmetric encrypt mode
+#define OPTIGA_CMD_OPERATION_MODE_SYMMETRIC_ENCRYPTION          (0x01)
+// Symmetric decrypt mode
+#define OPTIGA_CMD_OPERATION_MODE_SYMMETRIC_DECRYPTION          (0x00)
+// HMAC mode
+#define OPTIGA_CMD_OPERATION_MODE_HMAC                          (0x02)
+// Auto clear state 
+#define OPTIGA_CMD_OPERATION_MODE_CLEAR_AUTO_STATE              (0x03)
+// Function to set given bits
+#define SET_DEV_ERROR_HANDLER_STATE(state){\
+                                   (me->device_error_status) &= ~OPTIGA_CMD_ERROR_CODE_STATE_MASK;\
+                                   (me->device_error_status) |= state & OPTIGA_CMD_ERROR_CODE_STATE_MASK;}
+
+#define SET_DEV_ERROR_NOTIFICATION(bits_value){\
+                                  (me->device_error_status) &= ~OPTIGA_CMD_ENTER_HANDLER_CALL_MASK;\
+                                  (me->device_error_status) |= bits_value & OPTIGA_CMD_ENTER_HANDLER_CALL_MASK;}
+
+
+#define EXIT_STATE_WITH_ERROR(ctx, exit_machine){\
+                                  ctx->cmd_next_execution_state = OPTIGA_CMD_EXEC_ERROR_HANDLER;\
+                                  ctx->exit_status = OPTIGA_CMD_ERROR;\
+                                  exit_machine = FALSE;}
+
+#if defined (OPTIGA_LIB_ENABLE_LOGGING) && defined (OPTIGA_LIB_ENABLE_CMD_LOGGING)
+
+// Logs the message provided from Command layer
+#define OPTIGA_CMD_LOG_MESSAGE(msg) \
+{\
+    optiga_lib_print_message(msg,OPTIGA_COMMAND_LAYER,OPTIGA_COMMAND_LAYER_COLOR);\
+}
+
+// Logs the byte array buffer provided from Command layer in hexadecimal format
+//lint --e{750} suppress "The unused OPTIGA_CMD_LOG_HEX_DATA macro is kept for future enhancements"
+#define OPTIGA_CMD_LOG_HEX_DATA(array,array_len) \
+{\
+    optiga_lib_print_array_hex_format(array,array_len,OPTIGA_UNPROTECTED_DATA_COLOR);\
+}
+
+// Logs the status info provided from Command layer
+//lint --e{750} suppress "The unused OPTIGA_CMD_LOG_STATUS macro is kept for future enhancements"
+#define OPTIGA_CMD_LOG_STATUS(return_value) \
+{ \
+    if (OPTIGA_LIB_SUCCESS != return_value) \
+    { \
+        optiga_lib_print_status(OPTIGA_COMMAND_LAYER,OPTIGA_ERROR_COLOR,return_value); \
+    } \
+    else\
+    { \
+        optiga_lib_print_status(OPTIGA_COMMAND_LAYER,OPTIGA_COMMAND_LAYER_COLOR,return_value); \
+    } \
+}
+#else
+
+#define OPTIGA_CMD_LOG_MESSAGE(msg) {}
+//lint --e{750} suppress "The unused OPTIGA_CMD_LOG_HEX_DATA macro is kept for future enhancements"
+#define OPTIGA_CMD_LOG_HEX_DATA(array, array_len) {}
+//lint --e{750} suppress "The unused OPTIGA_CMD_LOG_STATUS macro is kept for future enhancements"
+#define OPTIGA_CMD_LOG_STATUS(return_value) {}
+
+#endif // (OPTIGA_LIB_ENABLE_LOGGING) && (OPTIGA_LIB_ENABLE_CMD_LOGGING)
+
+// Set data for apdu_data
+#define OPTIGA_CMD_SET_APDU_DATA(apdu_cmd, apdu_info) ((apdu_info << OPTIGA_CMD_NO_OF_BITS_IN_BYTE) | apdu_cmd)
+
+// Get APDU cmd value from apdu_data
+#define OPTIGA_CMD_GET_APDU_CMD(apdu_data)  ((uint8_t)apdu_data)
+
+// Get APDU info value from apdu_data
+#define OPTIGA_CMD_GET_APDU_INFO(apdu_data) ((uint8_t)(apdu_data >> OPTIGA_CMD_NO_OF_BITS_IN_BYTE))
+
+// Check if mode is MAC based
+#define  OPTIGA_CMD_IS_MODE_MAC(mode)  \
+  (((OPTIGA_HMAC_SHA_256 == (optiga_hmac_type_t)(mode)) || \
+  (OPTIGA_HMAC_SHA_384 == (optiga_hmac_type_t)(mode)) || (OPTIGA_HMAC_SHA_512 == (optiga_hmac_type_t)(mode)) || \
+  (OPTIGA_SYMMETRIC_CMAC == (optiga_symmetric_encryption_mode_t)(mode)) || \
+  (OPTIGA_SYMMETRIC_CBC_MAC == (optiga_symmetric_encryption_mode_t)mode))? TRUE : FALSE)
+
+// Check if mode is HMAC based
+#define  OPTIGA_CMD_IS_MODE_HMAC(mode)  \
+  ((OPTIGA_HMAC_SHA_256 == (optiga_hmac_type_t)(mode)) || (OPTIGA_HMAC_SHA_384 == (optiga_hmac_type_t)(mode)) || \
+  (OPTIGA_HMAC_SHA_512 == (optiga_hmac_type_t)(mode)) ? TRUE : FALSE)
+
+// Scheduler definitions
+
+// Optiga execution slot states
+#define     OPTIGA_CMD_QUEUE_NOT_ASSIGNED           (0x00)
+#define     OPTIGA_CMD_QUEUE_ASSIGNED               (0x01)
+#define     OPTIGA_CMD_QUEUE_REQUEST                (0x02)
+#define     OPTIGA_CMD_QUEUE_PROCESSING             (0x04)
+#define     OPTIGA_CMD_QUEUE_RESUME                 (0x08)
+
+// Optiga session state
+#define     OPTIGA_CMD_SESSION_NOT_ASSIGNED         (0x00)
+#define     OPTIGA_CMD_SESSION_ASSIGNED             (0x10)
+//Session not assigned to optiga cmd instance
+#define     OPTIGA_CMD_NO_SESSION_OID               (0x0000)
+#define     OPTIGA_CMD_ALL_SESSION_ASSIGNED         (0x10101010)
+
+// Optiga slot request types
+#define     OPTIGA_CMD_QUEUE_REQUEST_LOCK           (0x21)
+#define     OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK    (0x23)
+#define     OPTIGA_CMD_QUEUE_REQUEST_SESSION        (0x22)
+#define     OPTIGA_CMD_QUEUE_NO_REQUEST             (0x00)
+
+// Type of slot, Do not change the values
+#define     OPTIGA_CMD_QUEUE_SLOT_STATE             (0x09)
+// Type of lock, Do not change the values
+#define     OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE         (0x08)
+// Frequency of scheduler polling when no asynchronous requests are pending
+#define     OPTIGA_CMD_SCHEDULER_IDLING_TIME_MS     (1000U)
+// Frequency of scheduler polling when asynchronous requests is being processed
+#define     OPTIGA_CMD_SCHEDULER_RUNNING_TIME_MS    (50U)
+
+/** \brief The enum represents diffrent main state of command handler */
+typedef enum optiga_cmd_state
+{
+    OPTIGA_CMD_EXEC_COMMS_OPEN = 0,
+    OPTIGA_CMD_EXEC_COMMS_CLOSE,
+    OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+    OPTIGA_CMD_EXEC_PROCESS_RESPONSE,
+    OPTIGA_CMD_EXEC_ERROR_HANDLER
+} optiga_cmd_state_t;
+
+/** \brief The enum represents diffrent sub state of command handler */
+typedef enum optiga_cmd_sub_state
+{
+    OPTIGA_CMD_EXEC_COMMS_OPEN_ACQUIRE_LOCK = 0,
+    OPTIGA_CMD_EXEC_COMMS_OPEN_START,
+    OPTIGA_CMD_EXEC_COMMS_OPEN_DONE,
+
+    OPTIGA_CMD_EXEC_COMMS_CLOSE_START,
+    OPTIGA_CMD_EXEC_COMMS_CLOSE_DONE,
+
+    OPTIGA_CMD_EXEC_REQUEST_SESSION,
+    OPTIGA_CMD_EXEC_REQUEST_LOCK,
+    OPTIGA_CMD_EXEC_RESET_STRICT_LOCK,
+    OPTIGA_CMD_EXEC_REQUEST_STRICT_LOCK,
+    OPTIGA_CMD_EXEC_PREPARE_APDU,
+
+    OPTIGA_CMD_EXEC_PROCESS_OPTIGA_RESPONSE,
+    OPTIGA_CMD_EXEC_GET_DEVICE_ERROR,
+    OPTIGA_CMD_EXEC_RELEASE_LOCK,
+    OPTIGA_CMD_EXEC_RELEASE_SESSION,
+    OPTIGA_CMD_STATE_EXIT
+
+} optiga_cmd_sub_state_t;
+
+typedef optiga_lib_status_t (*optiga_cmd_handler_t)(optiga_cmd_t * me);
+
+/** \brief The structure represents the slot in the execution queue */
+typedef struct optiga_cmd_queue_slot
+{
+    /// Registered context
+    void * registered_ctx;
+    /// Arrival time of the optiga cmd instance in the execution queue
+    uint32_t arrival_time;
+    /// Request for command lock or session
+    uint8_t request_type;
+    /// state of the slot
+    uint8_t state_of_entry;
+}optiga_cmd_queue_slot_t;
+
+
+/**
+* \brief OPTIGA Context which holds the communication buffer, comms instance and other required.
+*   This would be maintained and consumed by OPTIGA Cmd.
+*/
+struct optiga_context
+{
+    /// Context of OPTIGA Communication.
+    optiga_comms_t * p_optiga_comms;
+    /// comms tx size
+    uint16_t comms_tx_size;
+    /// comms rx size
+    uint16_t comms_rx_size;
+    /// Structure which maintains the session and contexts of requesters to acquire session.
+    uint8_t sessions[OPTIGA_CMD_MAX_NUMBER_OF_SESSIONS];
+    /// Indicates if instance is initialized
+    uint8_t instance_init_state;
+    /// Communication buffer to send/receive APDUs.
+    uint8_t optiga_comms_buffer[OPTIGA_CMD_TOTAL_COMMS_BUFFER_SIZE];
+    /// optiga execution queue
+    optiga_cmd_queue_slot_t optiga_cmd_execution_queue[OPTIGA_CMD_MAX_REGISTRATIONS];
+    /// pal os event instance/context
+    pal_os_event_t * p_pal_os_event_ctx;
+    /// Last processed cmd time stamp
+    uint32_t last_time_stamp;
+    /// optiga context handle buffer
+    uint8_t optiga_context_handle_buffer[APP_CONTEXT_SIZE];
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+    /// Protection level status flag
+    uint8_t protection_level_state;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+};
+
+// static instance of optiga
+_STATIC_H optiga_context_t g_optiga = {0};
+
+// List of optiga instances
+//lint --e{843} suppress "Not changing to const as this gets assigned to another context variable which is not const"
+_STATIC_H optiga_context_t * g_optiga_list[] = {&g_optiga};
+
+// hibernate data store for each instance of optiga
+//lint --e{843} suppress "Not changing to const as this is used for unit testing as well"
+_STATIC_H uint16_t g_hibernate_datastore_id_list[] = {OPTIGA_HIBERNATE_CONTEXT_ID};
+
+const uint8_t g_optiga_unique_application_identifier[] =
+{
+    0xD2, 0x76, 0x00, 0x00, 0x04, 0x47, 0x65, 0x6E, 0x41, 0x75, 0x74, 0x68, 0x41, 0x70, 0x70, 0x6C,
+};
+
+/**
+* \brief Command context
+*/
+struct optiga_cmd
+{
+    /// Pointer to OPTIGA context which holds the communication buffer, comms instance and other required.
+    optiga_context_t * p_optiga;
+    /// Internal handlers for prepare and process
+    optiga_cmd_handler_t cmd_hdlrs;
+    /// Command execution input parameters
+    void * p_input;
+
+    /// Caller context
+    void* caller_context;
+    /// Callback handler
+    callback_handler_t handler;
+    /// Holds a Session OID allotted to this instance.
+    uint16_t session_oid;
+    /// State of the command next execution state
+    optiga_cmd_state_t cmd_next_execution_state;
+    /// State of the command next execution state
+    optiga_cmd_sub_state_t cmd_sub_execution_state;
+    /// Chaining flag
+    uint8_t chaining_ongoing;
+    /// Param value for the respective command to be processed
+    uint8_t cmd_param;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+    /// To provide the encryption and decryption need for command and response
+    uint8_t protection_level;
+    /// To provide the presentation layer protocol version to be used
+    uint8_t protocol_version;
+    /// To provide the manage context options
+    uint8_t manage_context_operation;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+    /// To provide error state
+    uint8_t device_error_status;
+    /// Assigned slot from execution queue
+    uint8_t queue_id;
+    /// Exit status value
+    optiga_lib_status_t exit_status;
+    /// Datastore ID for optiga context
+    uint16_t optiga_context_datastore_id;
+    /// To Store APDU command information which is last processed
+    uint16_t apdu_data;
+};
+
+_STATIC_H optiga_lib_status_t optiga_cmd_get_error_code_handler(optiga_cmd_t * me);
+
+#if defined (OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || defined (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || \
+defined (OPTIGA_CRYPT_HMAC_ENABLED) || defined (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED)
+
+_STATIC_H uint16_t optiga_cmd_sym_get_block_size(const optiga_encrypt_sym_params_t * param)
+{
+
+#define OPTIGA_CMD_MIN_BLOCK_SIZE_VALUE         (0x01)
+#define OPTIGA_CMD_HMAC_CMAC_BLOCK_SIZE                         (0x01)
+#define OPTIGA_CMD_SYM_ENC_DEC_ECB_CBC_CMAC_BLOCK_SIZE          (0x10)
+    uint16_t block_size = OPTIGA_CMD_MIN_BLOCK_SIZE_VALUE;
+    switch(param->mode)
+    {
+        // ECB symmetric encryption mode
+        case OPTIGA_SYMMETRIC_ECB:
+        // CBC symmetric encryption mode
+        case OPTIGA_SYMMETRIC_CBC:
+        // CBC MAC symmetric encryption mode
+        case OPTIGA_SYMMETRIC_CBC_MAC:
+        // CMAC symmetric encryption mode
+        case OPTIGA_SYMMETRIC_CMAC:
+        {
+            block_size = OPTIGA_CMD_SYM_ENC_DEC_ECB_CBC_CMAC_BLOCK_SIZE;
+        }
+        break;
+        // HMAC-SHA256 based MAC
+        case OPTIGA_HMAC_SHA_256:
+        // HMAC-SHA384 based MAC
+        case OPTIGA_HMAC_SHA_384:
+        // HMAC-SHA512 based MAC
+        case OPTIGA_HMAC_SHA_512:
+        {
+            block_size = OPTIGA_CMD_HMAC_CMAC_BLOCK_SIZE;
+        }
+        break;
+        default:
+        break;
+    }
+
+#undef OPTIGA_CMD_MIN_BLOCK_SIZE_VALUE
+#undef OPTIGA_CMD_HMAC_CMAC_BLOCK_SIZE
+#undef OPTIGA_CMD_SYM_ENC_DEC_ECB_CBC_CMAC_BLOCK_SIZE
+
+    return (block_size);
+}
+
+_STATIC_H uint16_t optiga_cmd_sym_get_max_indata_header_length(const optiga_encrypt_sym_params_t * param)
+{
+    uint16_t in_data_length = 0;
+    uint16_t data_length;
+    uint16_t block_size;
+    /// Calculation optional data length
+    if(((OPTIGA_CRYPT_SYM_START_FINAL == param->original_sequence) || \
+        (OPTIGA_CRYPT_SYM_START == param->original_sequence)) &&
+        (OPTIGA_CMD_RESET_SEQUENCE == param->current_sequence))
+    {
+        in_data_length += ((NULL != param->iv) && (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != param->iv_length))?
+                                  (OPTIGA_CMD_TAG_LENGTH_SIZE + param->iv_length) : 0;
+
+        in_data_length += ((NULL != param->associated_data) && \
+                                 (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != param->associated_data_length))?
+                                 (OPTIGA_CMD_TAG_LENGTH_SIZE + param->associated_data_length) : 0;
+
+        in_data_length +=
+              (0 != param->total_input_data_length) ? (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES) : 0;
+
+        in_data_length += 
+            ((NULL != param->generated_hmac) && (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != param->generated_hmac_length))?
+            (OPTIGA_CMD_TAG_LENGTH_SIZE + (uint16_t)param->generated_hmac_length + OPTIGA_CMD_UINT16_SIZE_IN_BYTES) : 0;
+    }
+
+    block_size = optiga_cmd_sym_get_block_size(param);
+    data_length = (uint16_t)MIN((param->in_data_length - param->sent_data_length),block_size);
+    if ((OPTIGA_CMD_SYM_MAX_INDATA_LENGTH - (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES + data_length)) < \
+        in_data_length)
+    {
+        // Incase of invalid indata header length, set the value to 0
+        in_data_length = OPTIGA_CMD_ZERO_LENGTH_OR_VALUE;
+    }
+    else
+    {
+        // In data header length = input data TL length + secret OID value length
+        in_data_length += (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES);
+    }
+    return (in_data_length);
+}
+
+_STATIC_H uint16_t optiga_cmd_sym_get_max_packet_length(const optiga_encrypt_sym_params_t * param,
+                                                        uint16_t in_data_length)
+{
+    uint16_t number_of_packets;
+    uint16_t block_size;
+    uint16_t max_packet_length = OPTIGA_CMD_SYM_MAX_INDATA_LENGTH - in_data_length;
+
+    block_size = optiga_cmd_sym_get_block_size(param);
+    number_of_packets = max_packet_length / block_size;
+    if(0 < number_of_packets)
+    {
+    	max_packet_length = (uint16_t)(number_of_packets * block_size);
+    }
+    else
+    {
+    	max_packet_length = (uint16_t)(param->in_data_length - param->sent_data_length);
+    }
+    return (max_packet_length);
+}
+
+_STATIC_H uint8_t optiga_cmd_sym_get_current_enc_dec_sequence(optiga_encrypt_sym_params_t * param,
+                                                          uint16_t packet_length,
+                                                          uint16_t max_packet_length)
+{
+    switch(param->current_sequence)
+    {
+        case OPTIGA_CMD_RESET_SEQUENCE:
+        {
+            if (OPTIGA_CRYPT_SYM_START_FINAL == param->original_sequence)
+            {
+                /// In data can processed without chaining
+                if (param->in_data_length <= (uint32_t)(max_packet_length))
+                {
+                    param->current_sequence = OPTIGA_CRYPT_SYM_START_FINAL;
+                }
+                else
+                {
+                    param->current_sequence = OPTIGA_CRYPT_SYM_START;
+                }
+            }
+            else if ((uint8_t)OPTIGA_CRYPT_SYM_FINAL == param->original_sequence)
+            {
+                if ((0 == param->sent_data_length) && (param->in_data_length <= (uint32_t)(max_packet_length)))
+                {
+                    param->current_sequence = OPTIGA_CRYPT_SYM_FINAL;
+                    break;
+                }
+                else
+                {
+                    param->current_sequence = OPTIGA_CRYPT_SYM_CONTINUE;
+                    break;
+                }
+            }
+            else
+            {
+                param->current_sequence = param->original_sequence;
+            }
+        }
+        break;
+
+        case OPTIGA_CRYPT_SYM_START:
+        {
+            if ((OPTIGA_CRYPT_SYM_START_FINAL == param->original_sequence) &&
+                     (param->in_data_length == (param->sent_data_length + packet_length)))
+            {
+                param->current_sequence = OPTIGA_CRYPT_SYM_FINAL;
+            }
+            else
+            {
+                param->current_sequence = OPTIGA_CRYPT_SYM_CONTINUE;
+            }
+        }
+        break;
+
+        case OPTIGA_CRYPT_SYM_CONTINUE:
+        {
+            if (((OPTIGA_CRYPT_SYM_START_FINAL == param->original_sequence) ||
+                (OPTIGA_CRYPT_SYM_FINAL == param->original_sequence)) &&
+                (param->in_data_length == (param->sent_data_length + packet_length)))
+            {
+                param->current_sequence = OPTIGA_CRYPT_SYM_FINAL;
+            }
+        }
+        break;
+
+        default:
+        break;
+    }
+
+    return (param->current_sequence);
+}
+#endif //(OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || (OPTIGA_CRYPT_HMAC_ENABLED)
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+//lint --e{714} suppress "This function is defined here but referred from other modules"
+void optiga_cmd_set_shielded_connection_option(optiga_cmd_t * me,
+                                               uint8_t value,
+                                               uint8_t shielded_connection_option)
+{
+    switch (shielded_connection_option)
+    {
+        // Protection Level
+        case OPTIGA_SET_PROTECTION_LEVEL:
+        {
+            me->protection_level = value;
+        }
+        break;
+        // Protocol Version
+        case OPTIGA_SET_PROTECTION_VERSION:
+        {
+            me->protocol_version = value;
+        }
+        break;
+        // Manage Context
+        case OPTIGA_SET_MANAGE_CONTEXT:
+        {
+            me->manage_context_operation = value;
+        }
+        break;
+        default:
+        break;
+    }
+}
+
+#endif // OPTIGA_COMMS_SHIELDED_CONNECTION
+
+// Cmd execute handler
+_STATIC_H void optiga_cmd_execute(optiga_cmd_t * me,
+                                  uint8_t cmd_param,
+                                  optiga_cmd_handler_t cmd_hdlrs,
+                                  optiga_cmd_state_t start_state,
+                                  optiga_cmd_sub_state_t sub_state,
+                                  void * input,
+                                  uint16_t apdu_data);
+
+// Cmd State machine handler
+_STATIC_H void optiga_cmd_execute_handler(void * p_ctx,
+                                          optiga_lib_status_t event);
+
+//
+_STATIC_H void optiga_cmd_prepare_apdu_header(uint8_t cmd, uint8_t param,
+                                              uint16_t in_data_length,
+                                              uint8_t * p_apdu_buffer)
+{
+    p_apdu_buffer [0] = cmd;
+    p_apdu_buffer [1] = param;
+    p_apdu_buffer [2] = (uint8_t)((in_data_length & 0xFF00) >> 8);
+    p_apdu_buffer [3] = (uint8_t)(in_data_length & 0x00FF);
+}
+
+
+_STATIC_H void optiga_cmd_prepare_tag_header(uint8_t tag,
+                                             uint16_t tag_length,
+                                             uint8_t * buffer,
+                                             uint16_t * position)
+{
+    uint16_t start_position = *position;
+
+    buffer[start_position++] = tag;
+    buffer[start_position++] = (uint8_t )(tag_length >> 8);
+    buffer[start_position++] = (uint8_t )(tag_length);
+
+    *position = start_position;
+}
+
+
+_STATIC_H void optiga_cmd_event_trigger_execute(void * p_ctx)
+{
+    optiga_cmd_execute_handler(p_ctx, OPTIGA_LIB_SUCCESS);
+}
+
+_STATIC_H void optiga_cmd_execute(optiga_cmd_t * me,
+                                  uint8_t cmd_param,
+                                  optiga_cmd_handler_t cmd_hdlrs,
+                                  optiga_cmd_state_t start_state,
+                                  optiga_cmd_sub_state_t sub_state,
+                                  void * input,
+                                  uint16_t apdu_data)
+{
+    me->p_input = input;
+    me->cmd_next_execution_state = start_state;
+    me->cmd_sub_execution_state = sub_state;
+    me->cmd_hdlrs = cmd_hdlrs;
+    me->chaining_ongoing = FALSE;
+    me->cmd_param = cmd_param;
+    me->apdu_data = apdu_data;
+    optiga_cmd_execute_handler(me, OPTIGA_LIB_SUCCESS);
+}
+
+/*
+* Checks if optiga session is available or not
+* Returns TRUE, if slot is available
+* Returns FALSE, if slot is not available
+*/
+_STATIC_H bool_t optiga_cmd_session_available(const optiga_context_t * p_optiga)
+{
+    uint32_t status_check;
+    // Consider the array as uin32_t value and check against 0x10101010
+    // where 0x10 is value of OPTIGA_CMD_SESSION_ASSIGNED
+    status_check = optiga_common_get_uint32(p_optiga->sessions);
+    return ((status_check < OPTIGA_CMD_ALL_SESSION_ASSIGNED)? (TRUE):(FALSE));
+}
+
+/*
+* 1. If a optiga cmd instance does not have session, assigns an available session
+*/
+_STATIC_H void optiga_cmd_session_assign(optiga_cmd_t * me)
+{
+    uint8_t * p_optiga_sessions = me->p_optiga->sessions;
+    uint8_t count;
+    if (OPTIGA_CMD_NO_SESSION_OID == me->session_oid)
+    {
+        for (count = 0; count < OPTIGA_CMD_MAX_NUMBER_OF_SESSIONS; count++)
+        {
+            if (OPTIGA_CMD_SESSION_ASSIGNED != p_optiga_sessions[count])
+            {
+                me->session_oid = (OPTIGA_CMD_START_SESSION_OID | count);
+                p_optiga_sessions[count] = OPTIGA_CMD_SESSION_ASSIGNED;
+                break;
+            }
+        }
+    }
+}
+
+/*
+* Frees a session
+*/
+_STATIC_H void optiga_cmd_session_free(optiga_cmd_t * me)
+{
+    uint8_t * p_optiga_sessions = me->p_optiga->sessions;
+    uint8_t count;
+    if (OPTIGA_CMD_NO_SESSION_OID != me->session_oid)
+    {
+        count = me->session_oid & 0x0F;
+        me->session_oid = OPTIGA_CMD_NO_SESSION_OID;
+        p_optiga_sessions[count] = OPTIGA_CMD_SESSION_NOT_ASSIGNED;
+    }
+}
+
+/*
+*  Returns the requested info in the queue slot input cmd instance
+*/
+_STATIC_H  uint8_t optiga_cmd_queue_get_state_of(const optiga_cmd_t * me, uint8_t slot_member)
+{
+    uint8_t state = 0;
+    switch (slot_member)
+    {
+        case OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE:
+        {
+            state = me->p_optiga->optiga_cmd_execution_queue[me->queue_id].request_type;
+        }
+        break;
+        case OPTIGA_CMD_QUEUE_SLOT_STATE:
+        {
+            state = me->p_optiga->optiga_cmd_execution_queue[me->queue_id].state_of_entry;
+        }
+        break;
+        default:
+            break;
+    }
+    return (state);
+}
+
+/*
+* Returns the count of number of slots with requested state
+*/
+_STATIC_H  uint8_t optiga_cmd_queue_get_count_of(const optiga_context_t * p_optiga,
+                                                 uint8_t slot_member,
+                                                 uint8_t state_to_check)
+{
+    uint8_t index;
+    uint8_t count = 0;
+    uint8_t slot_value = 0;
+    for (index = 0; index < OPTIGA_CMD_MAX_REGISTRATIONS ; index++)
+    {
+        switch (slot_member)
+        {
+            case OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE:
+            {
+                slot_value = p_optiga->optiga_cmd_execution_queue[index].request_type;
+            }
+            break;
+            case OPTIGA_CMD_QUEUE_SLOT_STATE:
+            {
+                slot_value = p_optiga->optiga_cmd_execution_queue[index].state_of_entry;
+            }
+            break;
+            default:
+                break;
+        }
+        if (state_to_check == slot_value)
+        {
+            count++;
+        }
+    }
+    return (count);
+}
+
+/*
+* Assigns an available slot to a optiga cmd instance and marks the slot as not available for another optiga cmd instance
+*/
+_STATIC_H void optiga_cmd_queue_assign_slot(const optiga_cmd_t * me, uint8_t * queue_index_store)
+{
+    uint8_t index;
+    for (index = 0; index < OPTIGA_CMD_MAX_REGISTRATIONS ; index++)
+    {
+        if (OPTIGA_CMD_QUEUE_NOT_ASSIGNED == me->p_optiga->optiga_cmd_execution_queue[index].state_of_entry)
+        {
+            * queue_index_store =  index;
+            me->p_optiga->optiga_cmd_execution_queue[index].state_of_entry = OPTIGA_CMD_QUEUE_ASSIGNED;
+           break;
+        }
+    }
+}
+
+/*
+* De-assigns a slot from a optiga cmd instance and makes the slot available for next optiga cmd instance
+*/
+_STATIC_H void optiga_cmd_queue_deassign_slot(optiga_cmd_t * me)
+{
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].state_of_entry = OPTIGA_CMD_QUEUE_NOT_ASSIGNED;
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].request_type = OPTIGA_CMD_QUEUE_NO_REQUEST;
+    me->queue_id = 0;
+}
+
+/*
+* Select next optiga cmd instance from the execution queue based on a rule
+* 1. A slot with OPTIGA_CMD_QUEUE_RESUME state should exist
+* 2. Pick the slot which has acquired the strict slot
+* 3. If no slot with OPTIGA_CMD_QUEUE_RESUME exists, slot must be in OPTIGA_CMD_QUEUE_REQUEST state
+* 4. The arrival time must be the earliest provided
+*     a. The request type is lock
+*     b. If request type is session, either session is already assigned or atleast session is available for assignment
+*/
+_STATIC_H void optiga_cmd_queue_scheduler(void * p_optiga)
+{
+    uint32_t reference_time_stamp = 0xFFFFFFFF;
+    optiga_cmd_queue_slot_t * p_queue_entry;
+    uint8_t index;
+    uint8_t prefered_index = 0xFF;
+    uint8_t overflow_detected = FALSE;
+
+    optiga_context_t * p_optiga_ctx = (optiga_context_t * )p_optiga;
+
+    pal_os_event_t * my_os_event = p_optiga_ctx->p_pal_os_event_ctx;
+
+
+    if (((0 == optiga_cmd_queue_get_count_of(p_optiga_ctx, OPTIGA_CMD_QUEUE_SLOT_STATE, OPTIGA_CMD_QUEUE_REQUEST)) &&
+         (0 == optiga_cmd_queue_get_count_of(p_optiga_ctx, OPTIGA_CMD_QUEUE_SLOT_STATE, OPTIGA_CMD_QUEUE_RESUME))) ||
+         ((1 == optiga_cmd_queue_get_count_of(p_optiga_ctx, OPTIGA_CMD_QUEUE_SLOT_STATE , OPTIGA_CMD_QUEUE_PROCESSING)) &&
+         (0 < optiga_cmd_queue_get_count_of(p_optiga_ctx, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE, OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK))))
+    {
+        // call self
+        pal_os_event_register_callback_oneshot(my_os_event, optiga_cmd_queue_scheduler,
+                                               p_optiga_ctx,OPTIGA_CMD_SCHEDULER_IDLING_TIME_MS);
+    }
+    else
+    {
+        pal_os_event_stop(my_os_event);
+        // continue checking if no context selected and overflow detected
+        do
+        {
+            //reset overflow detected flag and the last_time stamp
+            if(overflow_detected == TRUE)
+            {
+                p_optiga_ctx->last_time_stamp = 0;
+                overflow_detected = FALSE;
+            }
+
+            // Select optiga command based on rule
+            for (index = 0; index < OPTIGA_CMD_MAX_REGISTRATIONS; index++)
+            {
+                p_queue_entry = &(p_optiga_ctx->optiga_cmd_execution_queue[index]);
+
+                // if any slot has acquired strict lock, highest priority is given to it
+                if (1 == optiga_cmd_queue_get_count_of(p_optiga_ctx, OPTIGA_CMD_QUEUE_SLOT_STATE , OPTIGA_CMD_QUEUE_RESUME))
+                {
+                    // Select the slot which has acquired strict lock
+                    if ((OPTIGA_CMD_QUEUE_RESUME == p_queue_entry->state_of_entry) &&
+                        (OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == p_queue_entry->request_type))
+                    {
+                        reference_time_stamp = p_queue_entry->arrival_time;
+                        prefered_index = index;
+                    }
+
+                }
+                else
+                {
+                    // pick only requested queue slot and earliest arrival time
+                    if (p_queue_entry->state_of_entry == OPTIGA_CMD_QUEUE_REQUEST)
+                    {
+                        // remember that overflow has occurred in one of the entry
+                        if (p_queue_entry->arrival_time < p_optiga_ctx->last_time_stamp)
+                        {
+                            overflow_detected = TRUE;
+                        }
+
+                        // if lock request or session request and session available(either already assigned or available)
+                        if (((p_queue_entry->arrival_time <= reference_time_stamp) && (p_queue_entry->arrival_time >= p_optiga_ctx->last_time_stamp)) &&
+                            (((OPTIGA_CMD_QUEUE_REQUEST_SESSION == p_queue_entry->request_type) && (TRUE == optiga_cmd_session_available(p_optiga_ctx))) ||
+                            ((OPTIGA_CMD_QUEUE_REQUEST_SESSION == p_queue_entry->request_type) && (OPTIGA_CMD_NO_SESSION_OID != ((optiga_cmd_t *)p_queue_entry->registered_ctx)->session_oid)) ||
+                            (OPTIGA_CMD_QUEUE_REQUEST_LOCK == p_queue_entry->request_type) ||
+                            (OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == p_queue_entry->request_type)))
+                        {
+                            reference_time_stamp = p_queue_entry->arrival_time;
+                            prefered_index = index;
+                        }
+                    }
+                }
+            }
+        } while((0xFF == prefered_index) && (TRUE == overflow_detected));
+
+        // Improve : check the index and max queue size check
+        // If slot is identified then go further
+        if (0xFF != prefered_index)
+        {
+            p_queue_entry = &(p_optiga_ctx->optiga_cmd_execution_queue[prefered_index]);
+            // assign session
+            if ((OPTIGA_CMD_QUEUE_REQUEST_SESSION == p_optiga_ctx->optiga_cmd_execution_queue[prefered_index].request_type) &&
+                (OPTIGA_CMD_NO_SESSION_OID == ((optiga_cmd_t *)p_queue_entry->registered_ctx)->session_oid))
+            {
+                optiga_cmd_session_assign((optiga_cmd_t *)(p_optiga_ctx->optiga_cmd_execution_queue[prefered_index].registered_ctx));
+                // Improve : Change the state of the type here. This will reduce 0x0000 check
+            }
+
+            // schedule with selected context
+            my_os_event = ((optiga_cmd_t *)(p_optiga_ctx->optiga_cmd_execution_queue[prefered_index].registered_ctx))->p_optiga->p_pal_os_event_ctx;
+            pal_os_event_register_callback_oneshot(my_os_event,
+                                                   optiga_cmd_event_trigger_execute,
+                                                   ((optiga_cmd_t *)(p_optiga_ctx->optiga_cmd_execution_queue[prefered_index].registered_ctx)),
+                                                   OPTIGA_CMD_SCHEDULER_RUNNING_TIME_MS);
+            p_optiga_ctx->optiga_cmd_execution_queue[prefered_index].state_of_entry = OPTIGA_CMD_QUEUE_PROCESSING;
+            p_optiga_ctx->last_time_stamp = reference_time_stamp;
+        }
+        else
+        {
+            pal_os_event_register_callback_oneshot( my_os_event, optiga_cmd_queue_scheduler,
+                                                    p_optiga_ctx,OPTIGA_CMD_SCHEDULER_IDLING_TIME_MS);
+        }
+    }
+}
+
+/*
+* Updates a execution queue slot
+*/
+_STATIC_H void optiga_cmd_queue_update_slot(optiga_cmd_t * me, uint8_t request_type)
+{
+    if ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK != me->p_optiga->optiga_cmd_execution_queue[me->queue_id].request_type) ||
+       ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == me->p_optiga->optiga_cmd_execution_queue[me->queue_id].request_type) &&
+       (OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK != request_type)))
+    {
+        //add time stamp
+        me->p_optiga->optiga_cmd_execution_queue[me->queue_id].arrival_time = pal_os_timer_get_time_in_microseconds();
+    }
+
+    //add optiga_cmd ctx
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].registered_ctx = (void * )me;
+    // set the state of slot to Requested state
+    if ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == me->p_optiga->optiga_cmd_execution_queue[me->queue_id].request_type) &&
+        (OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == request_type))
+    {
+        me->p_optiga->optiga_cmd_execution_queue[me->queue_id].state_of_entry = OPTIGA_CMD_QUEUE_RESUME;
+    }
+    else
+    {
+        me->p_optiga->optiga_cmd_execution_queue[me->queue_id].state_of_entry = OPTIGA_CMD_QUEUE_REQUEST;
+    }
+    //add request type
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].request_type = request_type;
+}
+
+/*
+* Resets a execution slot
+*/
+_STATIC_H void optiga_cmd_queue_reset_slot(const optiga_cmd_t * me)
+{
+    // Reset the arrival time
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].arrival_time = 0xFFFFFFFF;
+    //add optiga_cmd ctx
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].registered_ctx = NULL;
+    //add request type
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].request_type = 0;
+    // set the slot state to assigned
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].state_of_entry = OPTIGA_CMD_QUEUE_ASSIGNED;
+    // start the event scheduler
+    pal_os_event_start(me->p_optiga->p_pal_os_event_ctx, optiga_cmd_queue_scheduler, me->p_optiga);
+}
+
+
+/*
+* Release the strict lock associated with instance
+*/
+_STATIC_H void optiga_cmd_release_strict_lock(const optiga_cmd_t * me)
+{
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].state_of_entry = OPTIGA_CMD_QUEUE_ASSIGNED;
+    me->p_optiga->optiga_cmd_execution_queue[me->queue_id].request_type = OPTIGA_CMD_QUEUE_NO_REQUEST;
+}
+
+optiga_lib_status_t optiga_cmd_request_session(optiga_cmd_t * me)
+{
+    optiga_cmd_queue_update_slot(me , OPTIGA_CMD_QUEUE_REQUEST_SESSION);
+    return (OPTIGA_CMD_SUCCESS);
+}
+
+optiga_lib_status_t optiga_cmd_release_session(optiga_cmd_t * me)
+{
+    optiga_cmd_session_free(me);
+    return (OPTIGA_CMD_SUCCESS);
+}
+
+optiga_lib_status_t optiga_cmd_request_lock(optiga_cmd_t * me, uint8_t lock_type)
+{
+    optiga_cmd_queue_update_slot(me , lock_type);
+    return (OPTIGA_CMD_SUCCESS);
+}
+
+optiga_lib_status_t optiga_cmd_release_lock(const optiga_cmd_t * me)
+{
+    optiga_cmd_queue_reset_slot(me);
+    return (OPTIGA_CMD_SUCCESS);
+}
+
+_STATIC_H optiga_lib_status_t optiga_cmd_restore_context(const optiga_cmd_t * me)
+{
+#define OPTIGA_CMD_OF_CONTEXT_HANDLE_4TH_BYTE         (0x04)
+    uint16_t context_handle_length;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    do
+    {
+        if (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != me->optiga_context_datastore_id)
+        {
+            context_handle_length = sizeof(me->p_optiga->optiga_context_handle_buffer);
+            //Reading context handle secret from datastore
+            return_status = pal_os_datastore_read(me->optiga_context_datastore_id,
+                                                  me->p_optiga->optiga_context_handle_buffer,
+                                                  &context_handle_length);
+            if (PAL_STATUS_SUCCESS != return_status)
+            {
+                break;
+            }
+        }
+        // Check for valid context value
+        if (0 == optiga_common_get_uint32(me->p_optiga->optiga_context_handle_buffer) &&
+            0 == optiga_common_get_uint32(&me->p_optiga->optiga_context_handle_buffer[OPTIGA_CMD_OF_CONTEXT_HANDLE_4TH_BYTE]))
+        {
+            return_status = OPTIGA_CMD_ERROR;
+            break;
+        }
+
+        return_status = OPTIGA_LIB_SUCCESS;
+    } while (FALSE);
+#undef OPTIGA_CMD_OFFSET_OF_NEXT_BYTE
+    return (return_status);
+}
+_STATIC_H optiga_lib_status_t optiga_cmd_store_context(const optiga_cmd_t * me)
+{
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    do
+    {
+        if (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != me->optiga_context_datastore_id)
+        {
+            //Reading context handle secret from datastore
+            return_status = pal_os_datastore_write(me->optiga_context_datastore_id,
+                                                   me->p_optiga->optiga_context_handle_buffer,
+                                                   sizeof(me->p_optiga->optiga_context_handle_buffer));
+            if (PAL_STATUS_SUCCESS != return_status)
+            {
+                break;
+            }
+        }
+
+        return_status = OPTIGA_LIB_SUCCESS;
+    } while (FALSE);
+    return (return_status);
+}
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+_STATIC_H void optiga_cmd_clear_app_ctx(void * p_ctx)
+{
+    optiga_cmd_t * me = (optiga_cmd_t *)p_ctx;
+    /*In the case of hibernate if any low level error occurs while performing
+      close application this section clears the saved application context.*/
+    if ((OPTIGA_CMD_PARAM_INITIALIZE_APP_CONTEXT != me->cmd_param) &&
+        (OPTIGA_COMMS_SESSION_CONTEXT_SAVE == me->manage_context_operation))
+    {
+        pal_os_memset(me->p_optiga->optiga_context_handle_buffer,0,
+                        sizeof(me->p_optiga->optiga_context_handle_buffer));
+        if ((OPTIGA_HIBERNATE_CONTEXT_ID == me->optiga_context_datastore_id) &&
+            (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != me->optiga_context_datastore_id))
+        {
+            //Clearing context handle secret from datastore
+            me->exit_status = pal_os_datastore_write(me->optiga_context_datastore_id,
+                                                     me->p_optiga->optiga_context_handle_buffer,
+                                                     sizeof(me->p_optiga->optiga_context_handle_buffer));
+            if (PAL_STATUS_SUCCESS != me->exit_status)
+            {
+                me->cmd_next_execution_state = OPTIGA_CMD_EXEC_ERROR_HANDLER;
+            }
+        }
+    }
+}
+#endif
+
+_STATIC_H void optiga_cmd_execute_comms_open(optiga_cmd_t * me, uint8_t * exit_loop)
+{
+    do
+    {
+        *exit_loop = TRUE;
+        switch (me->cmd_sub_execution_state)
+        {
+            case OPTIGA_CMD_EXEC_COMMS_OPEN_ACQUIRE_LOCK:
+            {
+
+                // add to queue and exit
+                me->exit_status = optiga_cmd_request_lock(me, OPTIGA_CMD_QUEUE_REQUEST_LOCK);
+                if (OPTIGA_LIB_SUCCESS != me->exit_status)
+                {
+                    EXIT_STATE_WITH_ERROR(me,*exit_loop);
+                    break;
+                }
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_COMMS_OPEN_START;
+                break;
+            }
+            case OPTIGA_CMD_EXEC_COMMS_OPEN_START:
+            {
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                me->p_optiga->p_optiga_comms->protection_level =  me->protection_level;
+                me->p_optiga->p_optiga_comms->protocol_version = me->protocol_version;
+                me->p_optiga->p_optiga_comms->manage_context_operation = me->manage_context_operation;
+                me->p_optiga->p_optiga_comms->p_pal_os_event_ctx = me->p_optiga->p_pal_os_event_ctx;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+
+                (void)optiga_comms_set_callback_context(me->p_optiga->p_optiga_comms, me);
+                me->exit_status = optiga_comms_open(me->p_optiga->p_optiga_comms);
+
+                if (OPTIGA_LIB_SUCCESS != me->exit_status)
+                {
+                    EXIT_STATE_WITH_ERROR(me,*exit_loop);
+                    break;
+                }
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_COMMS_OPEN_DONE;
+                break;
+            }
+            case OPTIGA_CMD_EXEC_COMMS_OPEN_DONE:
+            {
+                pal_os_event_register_callback_oneshot(me->p_optiga->p_pal_os_event_ctx,
+                                                       (register_callback)optiga_cmd_event_trigger_execute,
+                                                       me, OPTIGA_CMD_SCHEDULER_RUNNING_TIME_MS);
+                me->cmd_next_execution_state = OPTIGA_CMD_EXEC_PREPARE_COMMAND;
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_PREPARE_APDU;
+                break;
+            }
+            default:
+                EXIT_STATE_WITH_ERROR(me,*exit_loop);
+            break;
+            //lint --e{788} suppress "Not all states are used as same enum is used for both main and sub state machine."
+        }
+
+    } while ((FALSE == *exit_loop) && (OPTIGA_CMD_EXEC_COMMS_OPEN == me->cmd_next_execution_state));
+}
+
+_STATIC_H void optiga_cmd_execute_comms_close(optiga_cmd_t * me, uint8_t * exit_loop)
+{
+    do
+    {
+        *exit_loop = TRUE;
+        switch (me->cmd_sub_execution_state)
+        {
+            case OPTIGA_CMD_EXEC_COMMS_CLOSE_START:
+            {
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                // In case PRL is enabled and save context is not invoked or is PRL is not enabled,
+                //change state to OPTIGA_CMD_EXEC_COMMS_CLOSE_DONE, since it synchronous in nature
+                if (OPTIGA_COMMS_SESSION_CONTEXT_SAVE != me->manage_context_operation)
+                {
+                    me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_COMMS_CLOSE_DONE;
+                }
+                me->p_optiga->p_optiga_comms->protection_level =  me->protection_level;
+                me->p_optiga->p_optiga_comms->protocol_version = me->protocol_version;
+                if (0 != me->p_optiga->protection_level_state)
+                {
+                    me->p_optiga->p_optiga_comms->manage_context_operation = me->manage_context_operation;
+                }
+                else
+                {
+                    me->p_optiga->p_optiga_comms->manage_context_operation = OPTIGA_COMMS_SESSION_CONTEXT_NONE;
+                }
+                me->p_optiga->protection_level_state = 0;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_COMMS_CLOSE_DONE;
+
+                me->p_optiga->p_optiga_comms->p_pal_os_event_ctx = me->p_optiga->p_pal_os_event_ctx;
+
+                (void)optiga_comms_set_callback_context(me->p_optiga->p_optiga_comms, me);
+                me->exit_status = optiga_comms_close(me->p_optiga->p_optiga_comms);
+
+                if (OPTIGA_LIB_SUCCESS != me->exit_status)
+                {
+                    EXIT_STATE_WITH_ERROR(me,*exit_loop);
+                    break;
+                }
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                // In case PRL is enabled and save context is requested,
+                //change state to OPTIGA_CMD_EXEC_COMMS_CLOSE_DONE, since it asynchronous in nature
+                if (OPTIGA_COMMS_SESSION_CONTEXT_SAVE == me->manage_context_operation)
+                {
+                    me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_COMMS_CLOSE_DONE;
+                    *exit_loop = TRUE;
+                }
+                // For synchronous behavior: After exit from optiga_comms_close, release lock
+                else
+                {
+                    me->exit_status = optiga_cmd_release_lock(me);
+                }
+#else
+                me->exit_status = optiga_cmd_release_lock(me);
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+                break;
+            }
+            case OPTIGA_CMD_EXEC_COMMS_CLOSE_DONE:
+            {
+                me->handler(me->caller_context, OPTIGA_LIB_SUCCESS);
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                // For asynchronous behavior, change state to release the lock
+                if (OPTIGA_COMMS_SESSION_CONTEXT_SAVE == me->manage_context_operation)
+                {
+                    me->exit_status = optiga_cmd_release_lock(me);
+                }
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+                break;
+            }
+            default:
+                EXIT_STATE_WITH_ERROR(me,*exit_loop);
+            break;
+            //lint --e{788} suppress "Not all states are used as same enum is used for both main and sub state machine."
+        }
+    } while ((FALSE == *exit_loop) && (OPTIGA_CMD_EXEC_COMMS_CLOSE == me->cmd_next_execution_state));
+}
+
+_STATIC_H void optiga_cmd_execute_prepare_command(optiga_cmd_t * me, uint8_t * exit_loop)
+{
+    optiga_cmd_handler_t optiga_cmd_handler = me->cmd_hdlrs;
+    do
+    {
+        switch (me->cmd_sub_execution_state)
+        {
+            case OPTIGA_CMD_EXEC_REQUEST_LOCK:
+            case OPTIGA_CMD_EXEC_REQUEST_SESSION:
+            {
+                *exit_loop = TRUE;
+                if (me->cmd_sub_execution_state == OPTIGA_CMD_EXEC_REQUEST_SESSION)
+                {
+                    me->exit_status = optiga_cmd_request_session(me);
+                }
+                else
+                {
+                    me->exit_status = optiga_cmd_request_lock(me, OPTIGA_CMD_QUEUE_REQUEST_LOCK);
+                }
+                if (OPTIGA_LIB_SUCCESS != me->exit_status)
+                {
+                    EXIT_STATE_WITH_ERROR(me,*exit_loop);
+                    break;
+                }
+
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_PREPARE_APDU;
+                break;
+            }
+            case OPTIGA_CMD_EXEC_RESET_STRICT_LOCK:
+            {
+                optiga_cmd_release_strict_lock(me);
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_REQUEST_STRICT_LOCK;
+                *exit_loop = FALSE;
+                break;
+            }
+            case OPTIGA_CMD_EXEC_REQUEST_STRICT_LOCK:
+            {
+                me->exit_status = optiga_cmd_request_lock(me, OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK);
+                if (OPTIGA_LIB_SUCCESS != me->exit_status)
+                {
+                    EXIT_STATE_WITH_ERROR(me,*exit_loop);
+                    break;
+                }
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_PREPARE_APDU;
+                *exit_loop = TRUE;
+                break;
+            }
+            case OPTIGA_CMD_EXEC_PREPARE_APDU:
+            {
+                *exit_loop = TRUE;
+                me->exit_status = optiga_cmd_handler(me);
+                if (OPTIGA_LIB_SUCCESS != me->exit_status)
+                {
+                    me->cmd_next_execution_state = OPTIGA_CMD_EXEC_ERROR_HANDLER;
+                    *exit_loop = FALSE;
+                    break;
+                }
+                me->p_optiga->comms_rx_size = OPTIGA_CMD_TOTAL_COMMS_BUFFER_SIZE;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                me->p_optiga->p_optiga_comms->protection_level = me->protection_level;
+                me->p_optiga->p_optiga_comms->protocol_version = me->protocol_version;
+                me->p_optiga->protection_level_state |= me->protection_level;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+                (void)optiga_comms_set_callback_context(me->p_optiga->p_optiga_comms, me);
+                me->exit_status = optiga_comms_transceive(me->p_optiga->p_optiga_comms,
+                                                          me->p_optiga->optiga_comms_buffer,
+                                                          me->p_optiga->comms_tx_size,
+                                                          me->p_optiga->optiga_comms_buffer,
+                                                          &(me->p_optiga->comms_rx_size));
+
+                if (OPTIGA_LIB_SUCCESS != me->exit_status)
+                {
+                    EXIT_STATE_WITH_ERROR(me,*exit_loop);
+                    break;
+                }
+
+                me->cmd_next_execution_state = OPTIGA_CMD_EXEC_PROCESS_RESPONSE;
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_PROCESS_OPTIGA_RESPONSE;
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_ENTER_HANDLER_CALL);
+                break;
+            }
+            default:
+                EXIT_STATE_WITH_ERROR(me,*exit_loop);
+            break;
+            //lint --e{788} suppress "Not all states are used as same enum is used for both main and sub state machine."
+        }
+    } while ((FALSE == *exit_loop) && (OPTIGA_CMD_EXEC_PREPARE_COMMAND == me->cmd_next_execution_state));
+}
+
+_STATIC_H void optiga_cmd_execute_get_device_error(optiga_cmd_t * me, uint8_t * exit_loop)
+{
+    do
+    {
+        *exit_loop = TRUE;
+        me->exit_status = optiga_cmd_get_error_code_handler(me);
+        if (((OPTIGA_LIB_SUCCESS != me->exit_status) && !(OPTIGA_DEVICE_ERROR & me->exit_status)) ||
+            ((OPTIGA_DEVICE_ERROR == me->exit_status) &&
+            ((me->device_error_status & OPTIGA_CMD_ERROR_CODE_STATE_MASK) == OPTIGA_CMD_ERROR_CODE_RX)))
+        {
+            me->cmd_next_execution_state = OPTIGA_CMD_EXEC_ERROR_HANDLER;
+            *exit_loop = FALSE;
+            break;
+        }
+    } while (FALSE);
+}
+
+_STATIC_H void optiga_cmd_execute_process_optiga_response(optiga_cmd_t * me, uint8_t * exit_loop)
+{
+    optiga_cmd_handler_t optiga_cmd_handler = me->cmd_hdlrs;
+    do
+    {
+        *exit_loop = TRUE;
+        if (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != (me->device_error_status & OPTIGA_CMD_ENTER_HANDLER_CALL_MASK))
+        {
+            me->exit_status = optiga_cmd_handler(me);
+        }
+        else
+        {
+            me->cmd_next_execution_state = OPTIGA_CMD_EXEC_ERROR_HANDLER;
+            *exit_loop = FALSE;
+            break;
+        }
+        if (OPTIGA_LIB_SUCCESS == me->exit_status)
+        {
+            // After successful Close Application, change state to invoke optiga_comms_close
+            if (OPTIGA_CMD_CLOSE_APPLICATION == OPTIGA_CMD_GET_APDU_CMD(me->apdu_data))
+            {
+                pal_os_event_register_callback_oneshot(me->p_optiga->p_pal_os_event_ctx,
+                                                       (register_callback)optiga_cmd_event_trigger_execute,
+                                                       me,
+                                                       OPTIGA_CMD_SCHEDULER_IDLING_TIME_MS);
+                *exit_loop = TRUE;
+                me->cmd_next_execution_state = OPTIGA_CMD_EXEC_COMMS_CLOSE;
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_COMMS_CLOSE_START;
+            }
+            else
+            {
+                if (FALSE == me->chaining_ongoing)
+                {
+                    if ((OPTIGA_CMD_STATE_EXIT != me->cmd_sub_execution_state) && (OPTIGA_CMD_EXEC_RELEASE_SESSION != me->cmd_sub_execution_state))
+                    {
+                        me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+                    }
+                    *exit_loop = FALSE;
+                    break;
+                }
+                // for chaining, trigger preparing of next command
+                else
+                {
+                    pal_os_event_register_callback_oneshot(me->p_optiga->p_pal_os_event_ctx,
+                                                           (register_callback)optiga_cmd_event_trigger_execute,
+                                                           (void*)me,
+                                                           OPTIGA_CMD_SCHEDULER_IDLING_TIME_MS);
+                    *exit_loop = TRUE;
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                    me->protection_level &= OPTIGA_PROTECTION_LEVEL_MASK;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+
+                    me->cmd_next_execution_state = OPTIGA_CMD_EXEC_PREPARE_COMMAND;
+                    me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_PREPARE_APDU;
+                }
+            }
+        }
+        else
+        {
+            // After OPTIGA error is analyzed, invoke upper layer handler and release lock
+            if (OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT == me->exit_status)
+            {
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+                *exit_loop = FALSE;
+                break;
+            }
+            else if (OPTIGA_CMD_EXEC_RELEASE_SESSION == me->cmd_sub_execution_state)
+            {
+                *exit_loop = FALSE;
+            }
+            // After OPTIGA responds with failure, invoke the next state to check which error occurred
+            else
+            {
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_GET_DEVICE_ERROR;
+                SET_DEV_ERROR_HANDLER_STATE(OPTIGA_CMD_ERROR_CODE_PREPARE);
+                *exit_loop = FALSE;
+            }
+        }
+    } while (FALSE);
+}
+
+_STATIC_H void optiga_cmd_execute_process_response(optiga_cmd_t * me, uint8_t * exit_loop)
+{
+    do
+    {
+        switch (me->cmd_sub_execution_state)
+        {
+            case OPTIGA_CMD_EXEC_PROCESS_OPTIGA_RESPONSE:
+            {
+                optiga_cmd_execute_process_optiga_response(me, exit_loop);
+                break;
+            }
+            case OPTIGA_CMD_EXEC_GET_DEVICE_ERROR:
+            {
+                optiga_cmd_execute_get_device_error(me, exit_loop);
+                break;
+            }
+            case OPTIGA_CMD_EXEC_RELEASE_SESSION:
+            {
+                //lint --e{534} suppress "The return code is not checked because this is exit state."
+                optiga_cmd_release_session(me);
+                if (OPTIGA_LIB_SUCCESS == me->exit_status)
+                {
+                    me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+                }
+                else
+                {
+                    me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_GET_DEVICE_ERROR;
+                    SET_DEV_ERROR_HANDLER_STATE(OPTIGA_CMD_ERROR_CODE_PREPARE);
+                }
+                *exit_loop = FALSE;
+                break;
+            }
+            case OPTIGA_CMD_EXEC_RELEASE_LOCK:
+            {
+                //lint --e{534} suppress "The return code is not checked because this is exit state."
+                optiga_cmd_release_lock(me);
+                me->cmd_sub_execution_state = OPTIGA_CMD_STATE_EXIT;
+                *exit_loop = FALSE;
+                break;
+            }
+            case OPTIGA_CMD_STATE_EXIT:
+            {
+                me->handler(me->caller_context, me->exit_status);
+                *exit_loop = TRUE;
+                break;
+            }
+            default:
+                EXIT_STATE_WITH_ERROR(me,*exit_loop);
+            break;
+            //lint --e{788} suppress "Not all states are used as same enum is used for both main and sub state machine."
+        }
+    } while ((FALSE == *exit_loop) && (OPTIGA_CMD_EXEC_PROCESS_RESPONSE == me->cmd_next_execution_state));
+}
+
+_STATIC_H void optiga_cmd_execute_error_handler(const optiga_cmd_t * me, uint8_t * exit_loop)
+{
+    do
+    {
+        //lint --e{534} suppress "The return code is not checked because this is exit state."
+        optiga_cmd_release_lock(me);
+        me->handler(me->caller_context, me->exit_status);
+        *exit_loop = TRUE;
+    } while (FALSE);
+}
+
+_STATIC_H void optiga_cmd_execute_handler(void * p_ctx, optiga_lib_status_t event)
+{
+    uint8_t exit_loop = TRUE;
+    optiga_cmd_t * me = (optiga_cmd_t *)p_ctx;
+
+    // in event of no success, release lock and exit
+    if (OPTIGA_LIB_SUCCESS != event)
+    {
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        optiga_cmd_clear_app_ctx(p_ctx);
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+        me->cmd_next_execution_state = OPTIGA_CMD_EXEC_ERROR_HANDLER;
+        me->exit_status = event;
+    }
+
+    do
+    {
+        switch (me->cmd_next_execution_state)
+        {
+            case OPTIGA_CMD_EXEC_COMMS_OPEN:
+            {
+                optiga_cmd_execute_comms_open(me, &exit_loop);
+                break;
+            }
+            case OPTIGA_CMD_EXEC_COMMS_CLOSE:
+            {
+                optiga_cmd_execute_comms_close(me, &exit_loop);
+                break;
+            }
+            case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+            {
+                optiga_cmd_execute_prepare_command(me, &exit_loop);
+                break;
+            }
+            case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+            {
+                optiga_cmd_execute_process_response(me, &exit_loop);
+                break;
+            }
+            case OPTIGA_CMD_EXEC_ERROR_HANDLER:
+            {
+                optiga_cmd_execute_error_handler(me, &exit_loop);
+                break;
+            }
+            default :
+                break;
+            //lint --e{788} suppress "Not all states are used as same enum is used for both main and sub state machine."
+        }
+    } while (FALSE == exit_loop);
+}
+
+optiga_cmd_t * optiga_cmd_create(uint8_t optiga_instance_id, callback_handler_t handler, void * caller_context)
+{
+    optiga_cmd_t * me = NULL;
+
+    pal_os_lock_enter_critical_section();
+    do
+    {
+        // Get number of free slots
+        if (0 == optiga_cmd_queue_get_count_of(g_optiga_list[optiga_instance_id],
+                                               OPTIGA_CMD_QUEUE_SLOT_STATE,
+                                               OPTIGA_CMD_QUEUE_NOT_ASSIGNED))
+        {
+            break;
+        }
+
+        me = (optiga_cmd_t *)pal_os_calloc(1, sizeof(optiga_cmd_t));
+        if (NULL == me)
+        {
+            break;
+        }
+
+        me->handler = handler;
+        me->caller_context = caller_context;
+
+        me->p_optiga = g_optiga_list[optiga_instance_id];
+        me->optiga_context_datastore_id = g_hibernate_datastore_id_list[optiga_instance_id];
+
+        if (FALSE == me->p_optiga->instance_init_state)
+        {
+            //create pal os event
+            me->p_optiga->p_pal_os_event_ctx = pal_os_event_create(optiga_cmd_queue_scheduler, me->p_optiga);
+            me->p_optiga->p_optiga_comms = optiga_comms_create(optiga_cmd_execute_handler, me);
+            if (NULL == me->p_optiga->p_optiga_comms)
+            {
+                pal_os_free(me);
+                me = NULL;
+                break;
+            }
+            me->p_optiga->instance_init_state = TRUE;
+            me->p_optiga->p_optiga_comms->p_pal_os_event_ctx = me->p_optiga->p_pal_os_event_ctx;
+        }
+        // attach optiga cmd queue entry
+        optiga_cmd_queue_assign_slot(me, &(me->queue_id));
+    } while (FALSE);
+
+    pal_os_lock_exit_critical_section();
+    return (me);
+}
+
+optiga_lib_status_t optiga_cmd_destroy(optiga_cmd_t * me)
+{
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    do
+    {
+        if (NULL != me)
+        {
+            return_status = optiga_cmd_release_session(me);
+            // attach optiga cmd queue entry
+            optiga_cmd_queue_deassign_slot(me);
+            pal_os_free(me);
+            //lint --e{838} suppress "Release session API returns success. Status is checked for future enhancements"
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+    } while (FALSE);
+    return (return_status);
+}
+
+
+/*
+* Last error code handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_get_error_code_handler(optiga_cmd_t * me)
+{
+    optiga_context_t * p_optiga;
+    optiga_lib_status_t return_status = OPTIGA_DEVICE_ERROR;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+
+#define OPTIGA_CMD_OFFSET                     (0x0000)
+#define OPTIGA_CMD_BYTES_TO_READ              (0x0001)
+#define OPTIGA_CMD_GET_DATA_OBJECT_CMD        (0x01)
+#define OPTIGA_CMD_PARAM                      (0x00)
+
+    p_optiga = me->p_optiga;
+
+    switch (me->device_error_status & OPTIGA_CMD_ERROR_CODE_STATE_MASK)
+    {
+        case OPTIGA_CMD_ERROR_CODE_PREPARE:
+        {
+            optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data), OPTIGA_CMD_LAST_ERROR_CODE);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data), OPTIGA_CMD_OFFSET);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data), OPTIGA_CMD_BYTES_TO_READ);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_GET_DATA_OBJECT_CMD,
+                                           OPTIGA_CMD_PARAM,
+                                           (uint16_t)(index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (uint16_t)(index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+            SET_DEV_ERROR_HANDLER_STATE(OPTIGA_CMD_ERROR_CODE_TX);
+            pal_os_event_register_callback_oneshot(me->p_optiga->p_pal_os_event_ctx,
+                                                   (register_callback)optiga_cmd_event_trigger_execute,
+                                                   me, OPTIGA_CMD_SCHEDULER_IDLING_TIME_MS);
+        }
+        break;
+        case OPTIGA_CMD_ERROR_CODE_TX:
+        {
+            me->p_optiga->comms_rx_size = OPTIGA_CMD_TOTAL_COMMS_BUFFER_SIZE;
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+            me->p_optiga->p_optiga_comms->protection_level = me->protection_level;
+            me->p_optiga->p_optiga_comms->protocol_version = me->protocol_version;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+
+            (void)optiga_comms_set_callback_context(p_optiga->p_optiga_comms, (void*)me);
+            return_status = optiga_comms_transceive(p_optiga->p_optiga_comms,
+                                                    p_optiga->optiga_comms_buffer,
+                                                    p_optiga->comms_tx_size,
+                                                    p_optiga->optiga_comms_buffer,
+                                                    &p_optiga->comms_rx_size);
+            if (OPTIGA_COMMS_SUCCESS != return_status)
+            {
+                return_status = OPTIGA_CMD_ERROR;
+                break;
+            }
+            SET_DEV_ERROR_HANDLER_STATE(OPTIGA_CMD_ERROR_CODE_RX);
+        }
+        break;
+        case OPTIGA_CMD_ERROR_CODE_RX:
+        {
+            if (OPTIGA_CMD_APDU_FAILURE == me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                break;
+            }
+            return_status = me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET];
+            return_status = return_status | OPTIGA_DEVICE_ERROR;
+            me->cmd_next_execution_state = OPTIGA_CMD_EXEC_PROCESS_RESPONSE;
+            me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_PROCESS_OPTIGA_RESPONSE;
+            pal_os_event_register_callback_oneshot(me->p_optiga->p_pal_os_event_ctx,
+                                                   (register_callback)optiga_cmd_event_trigger_execute,
+                                                   me, OPTIGA_CMD_SCHEDULER_IDLING_TIME_MS);
+        }
+        break;
+        default:
+            break;
+    }
+
+#undef OPTIGA_CMD_OFFSET
+#undef OPTIGA_CMD_BYTES_TO_READ
+#undef OPTIGA_CMD_GET_DATA_OBJECT_CMD
+#undef OPTIGA_CMD_PARAM
+    return (return_status);
+}
+
+/*
+* Open Application handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_open_application_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+
+            OPTIGA_CMD_LOG_MESSAGE("Sending open app command...");
+
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + sizeof(g_optiga_unique_application_identifier);
+            total_apdu_length += ((OPTIGA_CMD_PARAM_INITIALIZE_APP_CONTEXT == me->cmd_param) ? (0) :
+                                    (sizeof(me->p_optiga->optiga_context_handle_buffer)));
+            //lint --e{774} suppress "If OPTIGA_MAX_COMMS_BUFFER_SIZE is set to lesser value it will fail"
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+            if (OPTIGA_CMD_PARAM_INITIALIZE_APP_CONTEXT != me->cmd_param)
+            {
+                ///optiga context restore operation
+                if (OPTIGA_LIB_SUCCESS != optiga_cmd_restore_context(me))
+                {
+                    break;
+                }
+            }
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_OPEN_APPLICATION,
+                                           me->cmd_param,
+                                           ((OPTIGA_CMD_PARAM_INITIALIZE_APP_CONTEXT == me->cmd_param) ?
+                                           (sizeof(g_optiga_unique_application_identifier)) :
+                                           (sizeof(g_optiga_unique_application_identifier) +
+                                           sizeof(me->p_optiga->optiga_context_handle_buffer))),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            pal_os_memcpy(me->p_optiga->optiga_comms_buffer + OPTIGA_CMD_APDU_INDATA_OFFSET,
+                          g_optiga_unique_application_identifier,
+                          sizeof(g_optiga_unique_application_identifier));
+            if (OPTIGA_CMD_PARAM_INITIALIZE_APP_CONTEXT != me->cmd_param)
+            {
+                pal_os_memcpy(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                              sizeof(g_optiga_unique_application_identifier)],
+                              me->p_optiga->optiga_context_handle_buffer,
+                              sizeof(me->p_optiga->optiga_context_handle_buffer));
+            }
+
+            me->p_optiga->comms_tx_size = (OPTIGA_CMD_APDU_HEADER_SIZE +
+                                           ((OPTIGA_CMD_PARAM_INITIALIZE_APP_CONTEXT == me->cmd_param) ?
+                                           sizeof(g_optiga_unique_application_identifier):
+                                           (sizeof(g_optiga_unique_application_identifier) +
+                                           sizeof(me->p_optiga->optiga_context_handle_buffer))));
+
+            pal_os_memset(me->p_optiga->optiga_context_handle_buffer,
+                          0,
+                          sizeof(me->p_optiga->optiga_context_handle_buffer));
+            if (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != me->optiga_context_datastore_id)
+            {
+                //Clearing context handle secret from datastore
+                return_status = pal_os_datastore_write(me->optiga_context_datastore_id,
+                                                       me->p_optiga->optiga_context_handle_buffer,
+                                                       sizeof(me->p_optiga->optiga_context_handle_buffer));
+                if (PAL_STATUS_SUCCESS != return_status)
+                {
+                    return_status = OPTIGA_CMD_ERROR;
+                    break;
+                }
+            }
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for open app command...");
+
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing open app response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+            me->p_optiga->p_optiga_comms->manage_context_operation = OPTIGA_COMMS_SESSION_CONTEXT_NONE;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+            OPTIGA_CMD_LOG_MESSAGE("Response of open app command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+
+optiga_lib_status_t optiga_cmd_open_application(optiga_cmd_t * me, uint8_t cmd_param, void * params)
+{
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    optiga_cmd_execute(me,
+                       cmd_param,
+                       optiga_cmd_open_application_handler,
+                       OPTIGA_CMD_EXEC_COMMS_OPEN,
+                       OPTIGA_CMD_EXEC_COMMS_OPEN_ACQUIRE_LOCK,
+                       params,
+                       //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                       OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_OPEN_APPLICATION, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+
+/*
+* Close Application handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_close_application_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+
+            OPTIGA_CMD_LOG_MESSAGE("Sending close app command..");
+
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE;
+            //lint --e{774} suppress "If OPTIGA_MAX_COMMS_BUFFER_SIZE is set to lesser value it will fail"
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_CLOSE_APPLICATION,
+                                           me->cmd_param,
+                                           OPTIGA_CMD_ZERO_LENGTH_OR_VALUE,
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = OPTIGA_CMD_APDU_HEADER_SIZE;
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for close app command...");
+            // check if the close app was successful
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing close app response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            if (OPTIGA_CMD_PARAM_INITIALIZE_APP_CONTEXT != me->cmd_param)
+            {
+                pal_os_memcpy(me->p_optiga->optiga_context_handle_buffer,
+                              me->p_optiga->optiga_comms_buffer + OPTIGA_CMD_APDU_INDATA_OFFSET,
+                              sizeof(me->p_optiga->optiga_context_handle_buffer));
+                ///Optiga context store operation
+                if (OPTIGA_LIB_SUCCESS != optiga_cmd_store_context(me))
+                {
+                    pal_os_memset(me->p_optiga->optiga_context_handle_buffer,0,
+                                    sizeof(me->p_optiga->optiga_context_handle_buffer));
+                    break;
+                }
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of close app command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_close_application(optiga_cmd_t * me, uint8_t cmd_param, void * params)
+{
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    optiga_cmd_execute(me,
+                       cmd_param,
+                       optiga_cmd_close_application_handler,
+                       OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                       OPTIGA_CMD_EXEC_REQUEST_LOCK,
+                       params,
+                       //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                       OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_CLOSE_APPLICATION, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+
+/*
+* Get Data Object handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_get_data_object_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_get_data_object_params_t * p_optiga_read_data = (optiga_get_data_object_params_t *)me->p_input;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    uint16_t size_to_read, data_read;
+    uint8_t cmd = OPTIGA_CMD_GET_DATA_OBJECT;
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending read data command...");
+            // APDU header size + oid 2bytes + offset 2 bytes + length 2 bytes
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                                    OPTIGA_CMD_UINT16_SIZE_IN_BYTES + OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            //lint --e{774} suppress "If OPTIGA_MAX_COMMS_BUFFER_SIZE is set to lesser value it will fail"
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                *(p_optiga_read_data->ref_bytes_to_read) = 0x00;
+                break;
+            }
+            //oid
+            optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                     p_optiga_read_data->oid);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            size_to_read = MIN((OPTIGA_MAX_COMMS_BUFFER_SIZE - OPTIGA_CMD_APDU_HEADER_SIZE),
+                               (p_optiga_read_data->bytes_to_read - p_optiga_read_data->accumulated_size));
+
+            if (OPTIGA_CMD_READ_DATA == p_optiga_read_data->data_or_metadata)
+            {
+                //offset
+                optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                           (p_optiga_read_data->offset + p_optiga_read_data->accumulated_size));
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+                //length
+                optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                         size_to_read);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            }
+            // If OID is for Last error code, don't clear the error code in read
+            if (OPTIGA_CMD_LAST_ERROR_CODE == p_optiga_read_data->oid)
+            {
+                cmd = OPTIGA_CMD_GET_DATA_OBJECT_NO_ERROR_CLEAR;
+            }
+            //prepare APDU header
+            optiga_cmd_prepare_apdu_header(cmd,
+                                           me->cmd_param,
+                                           (index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           (me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET));
+
+            me->p_optiga->comms_tx_size = index_for_data - OPTIGA_COMMS_DATA_OFFSET;
+            p_optiga_read_data->last_read_size = size_to_read;
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for read data command...");
+            me->chaining_ongoing = FALSE;
+            // check if the read was successful
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing read data response...");
+                //check if it is out of boundary issue
+                if (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_read_data->accumulated_size)
+                {
+                    SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_ENTER_HANDLER_CALL);
+                }
+                //flag used to setting the received buffer length to 0, in case unexpected error
+                else
+                {
+                    //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                    //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                    SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                    *(p_optiga_read_data->ref_bytes_to_read) = 0x00;
+                }
+                return_status = OPTIGA_CMD_ERROR;
+            }
+            else if (me->exit_status == (optiga_lib_status_t)(OPTIGA_CMD_OUT_OF_BOUNDARY_ERROR | OPTIGA_DEVICE_ERROR))
+            {
+                *(p_optiga_read_data->ref_bytes_to_read) = p_optiga_read_data->accumulated_size;
+                return_status = OPTIGA_LIB_SUCCESS;
+            }
+            else
+            {
+                //copy data from optiga comms buffer to user provided buffer
+                data_read = me->p_optiga->comms_rx_size - OPTIGA_CMD_APDU_HEADER_SIZE;
+
+                // check if the data received is greater than the size of read buffer
+                if (p_optiga_read_data->bytes_to_read < data_read)
+                {
+                    OPTIGA_CMD_LOG_MESSAGE("Error in processing read data response...");
+                    return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                    *(p_optiga_read_data->ref_bytes_to_read) = 0x00;
+                    break;
+                }
+
+                //copy data from optiga comms buffer to user provided buffer
+                pal_os_memcpy(p_optiga_read_data->buffer + p_optiga_read_data->accumulated_size,
+                              me->p_optiga->optiga_comms_buffer + OPTIGA_CMD_APDU_INDATA_OFFSET,
+                              data_read);
+
+                p_optiga_read_data->accumulated_size += data_read;
+
+                if ((p_optiga_read_data->last_read_size > data_read) ||
+                    (p_optiga_read_data->accumulated_size == p_optiga_read_data->bytes_to_read))
+                {
+                    *(p_optiga_read_data->ref_bytes_to_read) = p_optiga_read_data->accumulated_size;
+                    p_optiga_read_data->accumulated_size = 0;
+                    p_optiga_read_data->last_read_size = 0;
+                }
+                else
+                {
+                    me->chaining_ongoing = TRUE;
+                }
+                OPTIGA_CMD_LOG_MESSAGE("Response of read data command is processed...");
+                return_status = OPTIGA_LIB_SUCCESS;
+            }
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_get_data_object(optiga_cmd_t * me, uint8_t cmd_param,
+                                               optiga_get_data_object_params_t * params)
+{
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    optiga_cmd_execute(me,
+                       cmd_param,
+                       optiga_cmd_get_data_object_handler,
+                       OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                       OPTIGA_CMD_EXEC_REQUEST_LOCK,
+                       params,
+                       //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                       OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_GET_DATA_OBJECT, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+
+/*
+* Set Data Object handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_set_data_object_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_set_data_object_params_t * p_optiga_write_data = (optiga_set_data_object_params_t *)me->p_input;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    uint16_t size_to_send;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+
+            OPTIGA_CMD_LOG_MESSAGE("Sending set data command...");
+            me->chaining_ongoing = FALSE;
+            //oid
+            optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                     p_optiga_write_data->oid);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            //offset
+            optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                     (p_optiga_write_data->offset + p_optiga_write_data->written_size));
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            // Check maximum size that can be written, based on optiga comms buffer size
+            size_to_send = MIN((OPTIGA_MAX_COMMS_BUFFER_SIZE + OPTIGA_COMMS_DATA_OFFSET - index_for_data),
+                               ((p_optiga_write_data->size) - p_optiga_write_data->written_size));
+
+            // APDU header size + oid 2 bytes + offset 2 bytes + size of data to send
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                                    OPTIGA_CMD_UINT16_SIZE_IN_BYTES + size_to_send;
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+
+            // prepare apdu
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_SET_DATA_OBJECT,
+                                           me->cmd_param,
+                                           (OPTIGA_CMD_APDU_HEADER_SIZE + size_to_send),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+            //data to be written
+            if (OPTIGA_UTIL_COUNT_DATA_OBJECT == me->cmd_param)
+            {
+                *(me->p_optiga->optiga_comms_buffer + index_for_data) = p_optiga_write_data->count;
+            }
+            else
+            {
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                              p_optiga_write_data->buffer + p_optiga_write_data->written_size,
+                              size_to_send);
+            }
+            p_optiga_write_data->written_size += size_to_send;
+
+            me->p_optiga->comms_tx_size = (index_for_data + size_to_send - OPTIGA_COMMS_DATA_OFFSET);
+
+            // check if chaining is required based on size written and the user requested write
+            if (p_optiga_write_data->written_size != p_optiga_write_data->size)
+            {
+                me->chaining_ongoing = TRUE;
+                // For chaining, the 2nd loop will be Write only
+                me->cmd_param = OPTIGA_CMD_WRITE_ONLY;
+            }
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for set data command...");
+            // check if the write was successful
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing set data response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of set data command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+    return (return_status);
+}
+
+
+optiga_lib_status_t optiga_cmd_set_data_object(optiga_cmd_t * me, uint8_t cmd_param,
+                                               optiga_set_data_object_params_t * params)
+{
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    optiga_cmd_execute(me,
+                       cmd_param,
+                       optiga_cmd_set_data_object_handler,
+                       OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                       OPTIGA_CMD_EXEC_REQUEST_LOCK,
+                       params,
+                       //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                       OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_SET_DATA_OBJECT, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+
+#if defined (OPTIGA_CRYPT_RANDOM_ENABLED) || defined (OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED) || defined (OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED)
+/*
+* Get Random handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_get_random_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_get_random_params_t * p_random_params = (optiga_get_random_params_t *)me->p_input;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending get random command...");
+            /// APDU header size + length of random
+            /// OID size in case of param 0x04
+            /// 0x41, Length and prepending optional data
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            total_apdu_length += ((TRUE == p_random_params->store_in_session) ?
+                                (OPTIGA_CMD_UINT16_SIZE_IN_BYTES + OPTIGA_CMD_TAG_LENGTH_SIZE + p_random_params->optional_data_length) : 0x00);
+
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+            /// Copy the random data length
+            optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                     p_random_params->random_data_length);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            if (TRUE == p_random_params->store_in_session)
+            {
+                /// Copy the data to buffer
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data),(me->session_oid));
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+                /// TLV formation for key usage
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_RSA_PRE_MASTER_OPTIONAL_DATA_TAG,
+                                              ((NULL != p_random_params->optional_data) ?
+                                              p_random_params->optional_data_length : 0x0000),
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                if ((NULL != p_random_params->optional_data))
+                {
+                    pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data, p_random_params->optional_data,
+                                  p_random_params->optional_data_length);
+                    index_for_data += p_random_params->optional_data_length;
+                }
+            }
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_GET_RANDOM,
+                                           me->cmd_param,
+                                           (index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = index_for_data - OPTIGA_COMMS_DATA_OFFSET;
+
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for get random command...");
+            // check if the random data retrieval app was successful
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing get random response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            if (OPTIGA_CMD_RANDOM_PARAM_TYPE_PRE_MASTER_SECRET != (uint8_t)me->cmd_param)
+            {
+                //copy data from optiga comms buffer to user provided buffer
+                pal_os_memcpy(p_random_params->random_data,
+                              me->p_optiga->optiga_comms_buffer + OPTIGA_CMD_APDU_INDATA_OFFSET,
+                              p_random_params->random_data_length);
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of get random command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+
+optiga_lib_status_t optiga_cmd_get_random(optiga_cmd_t * me, uint8_t cmd_param, optiga_get_random_params_t * params)
+{
+    optiga_cmd_sub_state_t cmd_handler_state = OPTIGA_CMD_EXEC_REQUEST_LOCK;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    if (TRUE == params->store_in_session)
+    {
+        cmd_handler_state = OPTIGA_CMD_EXEC_REQUEST_SESSION;
+    }
+
+    optiga_cmd_execute(me,
+                       cmd_param,
+                       optiga_cmd_get_random_handler,
+                       OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                       cmd_handler_state,
+                       params,
+                       //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                       OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_GET_RANDOM, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+#endif //OPTIGA_CRYPT_RANDOM_ENABLED
+
+#if defined (OPTIGA_CRYPT_ECDSA_SIGN_ENABLED) || defined (OPTIGA_CRYPT_RSA_SIGN_ENABLED)
+/*
+* CalcSign handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_calc_sign_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_calc_sign_params_t * p_optiga_calc_sign = (optiga_calc_sign_params_t *)me->p_input;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    uint16_t private_key_oid;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            // APDU headed length + TLV of Digest + TLV of signature key OID
+            OPTIGA_CMD_LOG_MESSAGE("Sending calculate sign command..");
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_TAG_LENGTH_SIZE + p_optiga_calc_sign->digest_length +
+                                    OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                *(p_optiga_calc_sign->p_signature_length) = 0x00;
+                break;
+            }
+            // Tag and length for digest
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_SIGN_DIGEST_TAG,
+                                          p_optiga_calc_sign->digest_length,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+            //Digest data
+            pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                          p_optiga_calc_sign->p_digest,
+                          p_optiga_calc_sign->digest_length);
+
+            index_for_data += p_optiga_calc_sign->digest_length;
+
+            // Tag and length for OID of signature key
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_SIGN_OID_TAG,
+                                          OPTIGA_CMD_SIGN_OID_LEN,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+            //oid
+            private_key_oid = me->session_oid;
+            if (OPTIGA_KEY_ID_SESSION_BASED != p_optiga_calc_sign->private_key_oid)
+            {
+                private_key_oid = (uint16_t)p_optiga_calc_sign->private_key_oid;
+            }
+            optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                     private_key_oid);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            // prepare apdu
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_CALC_SIGN,
+                                           me->cmd_param,
+                                           (index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for calculate sign command...");
+            // check if the calculate signature command was successful
+            if (OPTIGA_CMD_APDU_SUCCESS == me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                // if the received signature length is greater than the user provided signature buffer length
+                if ((*(p_optiga_calc_sign->p_signature_length)) <
+                    (me->p_optiga->comms_rx_size - OPTIGA_CMD_APDU_HEADER_SIZE))
+                {
+                    OPTIGA_CMD_LOG_MESSAGE("Error in processing calculate sign response...");
+                    *(p_optiga_calc_sign->p_signature_length) = 0x00;
+                    return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                }
+                else
+                {
+                    *(p_optiga_calc_sign->p_signature_length) = me->p_optiga->comms_rx_size - OPTIGA_CMD_APDU_HEADER_SIZE;
+                    //copy signed data from optiga comms buffer to user provided buffer
+
+                    pal_os_memcpy(p_optiga_calc_sign->p_signature,
+                                  me->p_optiga->optiga_comms_buffer + OPTIGA_CMD_APDU_INDATA_OFFSET,
+                                  *(p_optiga_calc_sign->p_signature_length));
+                    OPTIGA_CMD_LOG_MESSAGE("Response of calculate sign command is processed...");
+                    return_status = OPTIGA_LIB_SUCCESS;
+                }
+            }
+            else
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing calculate sign response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                *(p_optiga_calc_sign->p_signature_length) = 0x00;
+            }
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+
+optiga_lib_status_t optiga_cmd_calc_sign(optiga_cmd_t * me, uint8_t cmd_param, optiga_calc_sign_params_t * params)
+{
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    optiga_calc_sign_params_t * p_optiga_calc_sign = (optiga_calc_sign_params_t*)params;
+    optiga_cmd_sub_state_t cmd_handler_state = OPTIGA_CMD_EXEC_REQUEST_LOCK;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+        if (OPTIGA_KEY_ID_SESSION_BASED == p_optiga_calc_sign->private_key_oid)
+        {
+            if (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE == me->session_oid)
+            {
+                break;
+            }
+            cmd_handler_state = OPTIGA_CMD_EXEC_REQUEST_SESSION;
+        }
+
+
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_calc_sign_handler,
+                           OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                           cmd_handler_state,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_CALC_SIGN, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+        return_status = OPTIGA_LIB_SUCCESS;
+    } while (FALSE);
+    return (return_status);
+}
+#endif //(OPTIGA_CRYPT_ECDSA_SIGN_ENABLED) ||(OPTIGA_CRYPT_RSA_SIGN_ENABLED)
+
+#if defined (OPTIGA_CRYPT_ECDSA_VERIFY_ENABLED) || defined (OPTIGA_CRYPT_RSA_VERIFY_ENABLED)
+/*
+* VerifySign handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_verify_sign_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_verify_sign_params_t * p_optiga_verify_sign = (optiga_verify_sign_params_t *)me->p_input;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending verify sign command..");
+            // APDU header length + TLV of digest + TLV of signature +
+            // If public key from OID (TLV of public key OID)
+            // If public key from host (TLV of algo ID + TLV of public key)
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_TAG_LENGTH_SIZE + p_optiga_verify_sign->digest_length +
+                                    OPTIGA_CMD_TAG_LENGTH_SIZE + (p_optiga_verify_sign->signature_length) +
+                                    (OPTIGA_CRYPT_OID_DATA == p_optiga_verify_sign->public_key_source_type ?
+                                     (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES):
+                                    (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES + OPTIGA_CMD_NO_OF_BYTES_IN_TAG + OPTIGA_CMD_TAG_LENGTH_SIZE +
+                                     p_optiga_verify_sign->public_key->length));
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+            //TLV formation for digest
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_VERIFY_SIGN_DIGEST_TAG,
+                                          p_optiga_verify_sign->digest_length,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+
+            pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                          p_optiga_verify_sign->p_digest,
+                          p_optiga_verify_sign->digest_length);
+            index_for_data += p_optiga_verify_sign->digest_length;
+
+            //TLV formation for signature
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_VERIFY_SIGN_SIGNATURE_TAG,
+                                          p_optiga_verify_sign->signature_length,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+
+            pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                          p_optiga_verify_sign->p_signature,
+                          p_optiga_verify_sign->signature_length);
+            index_for_data += p_optiga_verify_sign->signature_length;
+
+            if (OPTIGA_CRYPT_OID_DATA == p_optiga_verify_sign->public_key_source_type)
+            {
+                //TLV formation for public key certificate OID
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_VERIFY_SIGN_PUB_KEY_CERT_OID_TAG,
+                                              OPTIGA_CMD_VERIFY_SIGN_PUB_KEY_CERT_OID_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data),
+                                         p_optiga_verify_sign->certificate_oid);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            }
+            else
+            {
+                //TLV formation for public key from host
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_VERIFY_ALGO_ID_TAG,
+                                              OPTIGA_CMD_VERIFY_ALGO_ID_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                *(me->p_optiga->optiga_comms_buffer + index_for_data++) = (uint8_t)p_optiga_verify_sign->public_key->key_type;
+
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_VERIFY_PUBLIC_KEY_TAG,
+                                              p_optiga_verify_sign->public_key->length,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                              p_optiga_verify_sign->public_key->public_key,
+                              p_optiga_verify_sign->public_key->length);
+                index_for_data += p_optiga_verify_sign->public_key->length;
+            }
+
+            //form apdu header
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_VERIFY_SIGN,
+                                           me->cmd_param,
+                                           (uint16_t)(index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (uint16_t)(index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for verify sign command...");
+            if (OPTIGA_CMD_APDU_FAILURE == me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing verify sign response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of veriy sign command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_verify_sign(optiga_cmd_t * me,
+                                           uint8_t cmd_param,
+                                           optiga_verify_sign_params_t * params)
+{
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    optiga_cmd_execute(me,
+                       cmd_param,
+                       optiga_cmd_verify_sign_handler,
+                       OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                       OPTIGA_CMD_EXEC_REQUEST_LOCK,
+                       params,
+                       //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                       OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_VERIFY_SIGN, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+#endif //OPTIGA_CRYPT_ECDSA_VERIFY_ENABLED
+
+#ifdef OPTIGA_CRYPT_ECDH_ENABLED
+/*
+* CalcSSec handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_calc_ssec_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    optiga_calc_ssec_params_t * p_optiga_ecdh = (optiga_calc_ssec_params_t *)me->p_input;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    uint16_t private_key_oid;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending calculate shared secret command..");
+            // APDU header length + TLV of private key + TLV of algo id + TLV of public key
+            // If shared secret option to export (TLV of export shared secret)
+            // If shared secret store in OID (TLV of shared secret OID)
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                                    OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_NO_OF_BYTES_IN_TAG + OPTIGA_CMD_TAG_LENGTH_SIZE +
+                                    p_optiga_ecdh->public_key->length +
+                                    (TRUE == p_optiga_ecdh->export_to_host?(OPTIGA_CMD_TAG_LENGTH_SIZE):
+                                    (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES));
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+            // Tag and length for private key OID
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_SSEC_PRIVATE_KEY_TAG,
+                                          OPTIGA_CMD_SSEC_PRIVATE_KEY_LEN,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+
+            private_key_oid = (uint16_t)p_optiga_ecdh->private_key;
+            if (OPTIGA_KEY_ID_SESSION_BASED == p_optiga_ecdh->private_key)
+            {
+                private_key_oid = me->session_oid;
+            }
+
+            optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data], private_key_oid);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            // Tag and length for algorithm ID
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_SSEC_ALG_ID_TAG,
+                                          OPTIGA_CMD_SSEC_ALG_ID_LEN,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+
+            me->p_optiga->optiga_comms_buffer[index_for_data++] = (uint8_t)p_optiga_ecdh->public_key->key_type;
+
+            // Tag and length for public key
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_SSEC_PUB_KEY_TAG,
+                                          p_optiga_ecdh->public_key->length,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+
+            //Copy the public key to APDU
+            pal_os_memcpy(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                          p_optiga_ecdh->public_key->public_key,
+                          p_optiga_ecdh->public_key->length);
+
+            index_for_data += p_optiga_ecdh->public_key->length;
+
+            // check if shared secret needs to be exported or stored
+            if (FALSE == p_optiga_ecdh->export_to_host)
+            {
+                // Tag and length for storing shared secret in session OID
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_SSEC_STORE_SESSION_TAG,
+                                              OPTIGA_CMD_SSEC_STORE_SESSION_LEN,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+                // store session secret oid
+                optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data], me->session_oid);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            }
+            else
+            {
+                // Tag and length for exporting shared secret
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_SSEC_EXPORT_TAG,
+                                              OPTIGA_CMD_SSEC_EXPORT_LEN,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+            }
+
+            // prepare apdu
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_CALC_SSEC,
+                                           me->cmd_param,
+                                           (index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for calculate shared secret command...");
+            // check if the shared secret transceive was successful
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing calculate shared secret response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            if (FALSE != p_optiga_ecdh->export_to_host)
+            {
+                //copy shared secret from optiga comms buffer to user provided buffer
+                pal_os_memcpy(p_optiga_ecdh->shared_secret,
+                              me->p_optiga->optiga_comms_buffer + OPTIGA_CMD_APDU_INDATA_OFFSET,
+                              (me->p_optiga->comms_rx_size - OPTIGA_CMD_APDU_HEADER_SIZE));
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of calculate shared secret command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_calc_ssec(optiga_cmd_t * me, uint8_t cmd_param, optiga_calc_ssec_params_t * params)
+{
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    optiga_calc_ssec_params_t * p_optiga_ecdh = (optiga_calc_ssec_params_t *)params;
+    optiga_cmd_sub_state_t cmd_handler_state = OPTIGA_CMD_EXEC_REQUEST_SESSION;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+        if ((OPTIGA_KEY_ID_SESSION_BASED == p_optiga_ecdh->private_key) &&
+            (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE == me->session_oid))
+        {
+            break;
+        }
+        if ((OPTIGA_KEY_ID_SESSION_BASED != p_optiga_ecdh->private_key) &&
+            (FALSE != p_optiga_ecdh->export_to_host))
+        {
+            cmd_handler_state = OPTIGA_CMD_EXEC_REQUEST_LOCK;
+        }
+
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_calc_ssec_handler,
+                           OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                           cmd_handler_state,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_CALC_SSEC, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+        return_status = OPTIGA_LIB_SUCCESS;
+
+    } while (FALSE);
+
+    return (return_status);
+}
+#endif //OPTIGA_CRYPT_ECDH_ENABLED
+
+#if defined (OPTIGA_CRYPT_TLS_PRF_ENABLED) || defined (OPTIGA_CRYPT_HKDF_ENABLED)
+/*
+* DeriveKey
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_derive_key_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    optiga_derive_key_params_t * p_optiga_derive_key = (optiga_derive_key_params_t *)me->p_input;
+    uint16_t actual_secret_length = 0;
+    uint16_t derive_key_length_sent;
+    uint16_t secret_oid;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending derive key command..");
+            // APDU header length + TLV of OID shared secret + TLV of secret derivation data +
+            // TLV of length of the key to be derived
+            // If derive key option to export (TLV of export derive key)
+            // If derive key store in OID (TLV of derive key OID)
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                                    OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                                    (NULL != p_optiga_derive_key->derived_key?(OPTIGA_CMD_TAG_LENGTH_SIZE):
+                                    (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES));
+            if ((NULL != p_optiga_derive_key->label) && (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_derive_key->label_length))
+            {
+                total_apdu_length += p_optiga_derive_key->label_length;
+            }
+            //check if seed/salt is available
+            if ((NULL != p_optiga_derive_key->random_data) && (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_derive_key->random_data_length))
+            {
+                total_apdu_length += p_optiga_derive_key->random_data_length;
+            }
+            if ((NULL != p_optiga_derive_key->info) && (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_derive_key->info_length))
+            {
+                total_apdu_length += (OPTIGA_CMD_TAG_LENGTH_SIZE + p_optiga_derive_key->info_length);
+            }
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+
+            // OID of shared secret to derive new secret from
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_DERIVE_KEY_SEC_OID_TAG,
+                                          OPTIGA_CMD_DERIVE_KEY_SEC_OID_TAG_LENGTH,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+            secret_oid = (p_optiga_derive_key->input_shared_secret_oid == 0x00) ?
+                          me->session_oid : p_optiga_derive_key->input_shared_secret_oid;
+            optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data), secret_oid);
+            index_for_data += 2;
+
+            // Length of key to be derived
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_DERIVE_KEY_KEY_LEN_TAG,
+                                          OPTIGA_CMD_DERIVE_KEY_KEY_LEN_TAG_LENGTH,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+            derive_key_length_sent = p_optiga_derive_key->derived_key_length;
+            if ((derive_key_length_sent > OPTIGA_CMD_ZERO_LENGTH_OR_VALUE) &&
+                (derive_key_length_sent < OPTIGA_CMD_DERIVE_KEY_DERIVE_KEY_LEN_MIN))
+            {
+                derive_key_length_sent = OPTIGA_CMD_DERIVE_KEY_DERIVE_KEY_LEN_MIN;
+            }
+            optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data), derive_key_length_sent);
+            index_for_data += 2;
+
+            if ((NULL != p_optiga_derive_key->info) && (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_derive_key->info_length))
+            {
+                ///TLV formation for Info data
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_DERIVE_KEY_INFO_TAG,
+                                              p_optiga_derive_key->info_length,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                              p_optiga_derive_key->info,
+                              p_optiga_derive_key->info_length);
+                index_for_data += p_optiga_derive_key->info_length;
+            }
+
+            //copy label(secret) if present
+            *(me->p_optiga->optiga_comms_buffer + index_for_data++) = OPTIGA_CMD_DERIVE_KEY_DERIVATION_DATA_TAG;
+            index_for_data += 2;
+
+            if ((NULL != p_optiga_derive_key->label) && (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_derive_key->label_length))
+            {
+                // pre increase index
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                              p_optiga_derive_key->label,
+                              p_optiga_derive_key->label_length);
+
+                actual_secret_length = p_optiga_derive_key->label_length;
+            }
+            //copy seed(secret) if not NULL
+            if ((NULL != p_optiga_derive_key->random_data) && (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_derive_key->random_data_length))
+            {
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data+actual_secret_length,
+                              p_optiga_derive_key->random_data,
+                              p_optiga_derive_key->random_data_length);
+
+                actual_secret_length += p_optiga_derive_key->random_data_length;
+            }
+
+            //Add secret length
+            optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data - 2), (actual_secret_length));
+            index_for_data += actual_secret_length;
+
+            // Alternate output options
+            if (NULL == p_optiga_derive_key->derived_key)
+            {
+                //store internal
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_DERIVE_KEY_STORE_TAG,
+                                              OPTIGA_CMD_DERIVE_KEY_STORE_TAG_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data), (me->session_oid));
+                index_for_data += 2;
+            }
+            else
+            {
+                //export
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_DERIVE_KEY_EXPORT_TAG,
+                                              OPTIGA_CMD_ZERO_LENGTH_OR_VALUE,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+            }
+
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_DERIVE_KEY,
+                                           me->cmd_param,
+                                          (index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for derive key command...");
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing derive key response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of derive key command is processed...");
+            // session release
+            return_status = OPTIGA_LIB_SUCCESS;
+            if (NULL != p_optiga_derive_key->derived_key)
+            {
+                pal_os_memcpy(p_optiga_derive_key->derived_key,
+                              me->p_optiga->optiga_comms_buffer + OPTIGA_CMD_APDU_INDATA_OFFSET,
+                              p_optiga_derive_key->derived_key_length);
+            }
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_derive_key(optiga_cmd_t * me, uint8_t cmd_param, optiga_derive_key_params_t * params)
+{
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    optiga_derive_key_params_t * p_optiga_tls_prf_sha256 = (optiga_derive_key_params_t*)params;
+    optiga_cmd_sub_state_t initial_state;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+        if ((OPTIGA_KEY_ID_SESSION_BASED == (optiga_key_id_t)p_optiga_tls_prf_sha256->input_shared_secret_oid) &&
+            (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE == me->session_oid))
+        {
+            break;
+        }
+
+        me->chaining_ongoing = FALSE;
+        me->cmd_param = cmd_param;
+        initial_state = OPTIGA_CMD_EXEC_REQUEST_LOCK;
+
+        if ((NULL == p_optiga_tls_prf_sha256->derived_key) ||
+            (0x00 == p_optiga_tls_prf_sha256->input_shared_secret_oid))
+        {
+            initial_state = OPTIGA_CMD_EXEC_REQUEST_SESSION;
+        }
+
+        optiga_cmd_execute(me,
+                           me->cmd_param,
+                           optiga_cmd_derive_key_handler,
+                           OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                           initial_state,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_DERIVE_KEY, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+        return_status = OPTIGA_LIB_SUCCESS;
+
+    } while (FALSE);
+    return (return_status);
+}
+#endif //(OPTIGA_CRYPT_TLS_PRF_ENABLED) || (OPTIGA_CRYPT_HKDF_ENABLED)
+
+#if defined (OPTIGA_CRYPT_ECC_GENERATE_KEYPAIR_ENABLED) || defined (OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED)
+/*
+* GenKeyPair handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_gen_keypair_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_gen_keypair_params_t * p_optiga_gen_keypair = (optiga_gen_keypair_params_t *)me->p_input;
+    uint16_t header_offset;
+    uint16_t private_key_length;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    uint16_t out_data_size;
+    uint16_t public_key_length;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending generate keypair command..");
+            // APDU header length +
+            // If private key option to store in OID (TLV of private key + TLV of key usages)
+            // If private key option to export (TLV of export key pair)
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE +
+                                    (FALSE == p_optiga_gen_keypair->export_private_key ?
+                                    (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES + OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_NO_OF_BYTES_IN_TAG):
+                                    (OPTIGA_CMD_TAG_LENGTH_SIZE ));
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                *p_optiga_gen_keypair->public_key_length = 0;
+                break;
+            }
+            if (FALSE == p_optiga_gen_keypair->export_private_key)
+            {
+                ///TLV formation for private key OID
+                optiga_cmd_prepare_tag_header (OPTIGA_CMD_GEN_KEY_PAIR_PRIVATE_KEY_OID_TAG,
+                                               OPTIGA_CMD_GEN_KEY_PAIR_PRIVATE_KEY_OID_LENGTH,
+                                               me->p_optiga->optiga_comms_buffer,
+                                               &index_for_data);
+                ///Update OID based on input param
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data),
+                                         ((OPTIGA_KEY_ID_SESSION_BASED == p_optiga_gen_keypair->private_key_oid)?
+                                         me->session_oid:(uint16_t)p_optiga_gen_keypair->private_key_oid));
+
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+                ///TLV formation for key usage
+                optiga_cmd_prepare_tag_header (OPTIGA_CMD_GEN_KEY_PAIR_KEY_USAGE_TAG,
+                                               OPTIGA_CMD_GEN_KEY_PAIR_KEY_USAGE_LENGTH,
+                                               me->p_optiga->optiga_comms_buffer,
+                                               &index_for_data);
+
+                *(me->p_optiga->optiga_comms_buffer + index_for_data++) = p_optiga_gen_keypair->key_usage;
+            }
+            else
+            {
+                ///TLV formation for export key
+                optiga_cmd_prepare_tag_header (OPTIGA_CMD_GEN_KEY_PAIR_EXPORT_KEY_TAG,
+                                               OPTIGA_CMD_GEN_KEY_PAIR_EXPORT_KEY_LENGTH,
+                                               me->p_optiga->optiga_comms_buffer,
+                                               &index_for_data);
+            }
+
+            //form apdu header
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_GEN_KEYPAIR, me->cmd_param,
+                                            (uint16_t)(index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+            me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (uint16_t)(index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for generate keypair command...");
+            // check if the write was successful
+            if (OPTIGA_CMD_APDU_FAILURE == me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing generate keypair response...");
+                *p_optiga_gen_keypair->public_key_length = 0;
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            header_offset = 0;
+            optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET - OPTIGA_CMD_UINT16_SIZE_IN_BYTES],
+                                     &out_data_size);
+
+            while (out_data_size > header_offset)
+            {
+                if (OPTIGA_CMD_GEN_KEY_PAIR_PUBLIC_KEY_TAG ==
+                    me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + header_offset])
+                {
+                    optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                                                header_offset + OPTIGA_CMD_NO_OF_BYTES_IN_TAG], &public_key_length);
+                    if (public_key_length > *p_optiga_gen_keypair->public_key_length)
+                    {
+                        OPTIGA_CMD_LOG_MESSAGE("Error in processing generate keypair response...");
+                        return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                        *p_optiga_gen_keypair->public_key_length = 0;
+                        break;
+                    }
+                    *p_optiga_gen_keypair->public_key_length = public_key_length;
+                    pal_os_memcpy(p_optiga_gen_keypair->public_key,
+                                  &me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + header_offset +
+                                   OPTIGA_CMD_UINT16_SIZE_IN_BYTES + OPTIGA_CMD_NO_OF_BYTES_IN_TAG],
+                                   *p_optiga_gen_keypair->public_key_length);
+                    header_offset +=  (uint16_t)OPTIGA_CMD_UINT16_SIZE_IN_BYTES+ OPTIGA_CMD_NO_OF_BYTES_IN_TAG +
+                                        *p_optiga_gen_keypair->public_key_length;
+                    return_status = OPTIGA_LIB_SUCCESS;
+                }
+                else if (OPTIGA_CMD_GEN_KEY_PAIR_PRIVATE_KEY_TAG == me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                                                             header_offset])
+                {
+                    optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + header_offset
+                                             + OPTIGA_CMD_NO_OF_BYTES_IN_TAG], &private_key_length);
+
+                    pal_os_memcpy(p_optiga_gen_keypair->private_key,
+                                  &me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + header_offset +
+                                  OPTIGA_CMD_UINT16_SIZE_IN_BYTES+ OPTIGA_CMD_NO_OF_BYTES_IN_TAG], private_key_length);
+                    header_offset +=  OPTIGA_CMD_UINT16_SIZE_IN_BYTES+ OPTIGA_CMD_NO_OF_BYTES_IN_TAG + private_key_length;
+                    return_status = OPTIGA_LIB_SUCCESS;
+                }
+                else
+                {
+                    break;
+                }
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of generate keypair command is processed...");
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_gen_keypair(optiga_cmd_t * me, uint8_t cmd_param, optiga_gen_keypair_params_t * params)
+{
+    optiga_gen_keypair_params_t * p_optiga_gen_keypair = (optiga_gen_keypair_params_t*)params;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+
+    if ((OPTIGA_KEY_ID_SESSION_BASED == p_optiga_gen_keypair->private_key_oid)
+        && (FALSE == p_optiga_gen_keypair->export_private_key))
+    {
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_gen_keypair_handler,
+                           OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                           OPTIGA_CMD_EXEC_REQUEST_SESSION,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_GEN_KEYPAIR, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+    }
+    else
+    {
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_gen_keypair_handler,
+                           OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                           OPTIGA_CMD_EXEC_REQUEST_LOCK,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_GEN_KEYPAIR, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+    }
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+#endif //OPTIGA_CRYPT_ECC_GENERATE_KEYPAIR_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+
+/*
+* EncryptAsym handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_encrypt_asym_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_encrypt_asym_params_t * p_optiga_encrypt_asym = (optiga_encrypt_asym_params_t *)me->p_input;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    uint16_t out_data_size;
+
+#define PUBLIC_KEY_HOST ((public_key_from_host_t *)(p_optiga_encrypt_asym->key))
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending asymmetric encryption command..");
+            // APDU header length + default TLV of OID of session + default TLV of OID of public key
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES) + (OPTIGA_CMD_TAG_LENGTH_SIZE +
+                                OPTIGA_CMD_UINT16_SIZE_IN_BYTES);
+            if (NULL != p_optiga_encrypt_asym->message)
+            {
+                // Add TLV of message and reduce 2 it is already added by default
+                total_apdu_length += (p_optiga_encrypt_asym->message_length - OPTIGA_CMD_UINT16_SIZE_IN_BYTES);
+            }
+            if (p_optiga_encrypt_asym->public_key_source_type)
+            {
+                // Add TLV of public key and reduce 1 because alg id is only 1 byte
+                total_apdu_length += (OPTIGA_CMD_TAG_LENGTH_SIZE +(PUBLIC_KEY_HOST->length));
+                total_apdu_length--;
+            }
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                *(p_optiga_encrypt_asym->processed_message_length) = 0;
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+
+            // message for encryption
+            if ((NULL == p_optiga_encrypt_asym->message) && (0 == p_optiga_encrypt_asym->message_length))
+            {
+                //TLV formation for session
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENCRYPT_ASYM_SESSION_OID_TAG,
+                                              OPTIGA_CMD_ENCRYPT_ASYM_SESSION_OID_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                //Add session OID
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data ), (me->session_oid));
+                index_for_data += 2;
+            }
+            else
+            {
+                //TLV formation for message
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENCRYPT_ASYM_MESSAGE_TAG,
+                                              p_optiga_encrypt_asym->message_length,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                                p_optiga_encrypt_asym->message,
+                                p_optiga_encrypt_asym->message_length);
+                index_for_data += p_optiga_encrypt_asym->message_length;
+
+            }
+
+            // key for encryption
+
+            if (p_optiga_encrypt_asym->public_key_source_type)
+            {
+
+                //TLV formation for public key from host
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENCRYPT_ASYM_ALGO_ID_TAG,
+                                              OPTIGA_CMD_ENCRYPT_ASYM_ALGO_ID_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                *(me->p_optiga->optiga_comms_buffer + index_for_data++) = (uint8_t)PUBLIC_KEY_HOST->key_type;
+
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENCRYPT_ASYM_PUBLIC_KEY_TAG,
+                                              PUBLIC_KEY_HOST->length,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                              PUBLIC_KEY_HOST->public_key,
+                              PUBLIC_KEY_HOST->length);
+
+                index_for_data += PUBLIC_KEY_HOST->length;
+#undef PUBLIC_KEY_HOST
+            }
+            else
+            {
+                //TLV for public key from OID
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENCRYPT_ASYM_PUB_KEY_CERT_OID_TAG,
+                                              OPTIGA_CMD_ENCRYPT_ASYM_PUB_KEY_CERT_OID_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                //Add session OID
+                optiga_common_set_uint16(me->p_optiga->optiga_comms_buffer + index_for_data,
+                                        *((uint16_t * )(p_optiga_encrypt_asym->key)));
+                index_for_data += OPTIGA_CMD_ENCRYPT_ASYM_PUB_KEY_CERT_OID_LENGTH;
+            }
+
+
+            //form apdu header
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_ENCRYPT_ASYM,
+                                           me->cmd_param,
+                                           (uint16_t)(index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (uint16_t)(index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for asymmetric encryption command...");
+            // check if the random data retrieval app was successful
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing asymmetric encryption response...");
+                *(p_optiga_encrypt_asym->processed_message_length) = 0;
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + OPTIGA_CMD_NO_OF_BYTES_IN_TAG],
+                                     &out_data_size);
+            if ((*(p_optiga_encrypt_asym->processed_message_length )) < out_data_size)
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing asymmetric encryption response...");
+                *(p_optiga_encrypt_asym->processed_message_length) = 0;
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+            //copy data from optiga comms buffer to user provided buffer
+            pal_os_memcpy(p_optiga_encrypt_asym->processed_message,
+                          &me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                          OPTIGA_CMD_NO_OF_BYTES_IN_TAG], out_data_size);
+            *(p_optiga_encrypt_asym->processed_message_length) = out_data_size ;
+            OPTIGA_CMD_LOG_MESSAGE("Response of asymmetric encryption command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_encrypt_asym(optiga_cmd_t * me, uint8_t cmd_param, optiga_encrypt_asym_params_t * params)
+{
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+
+    // for encrypting session data, instance must have session.
+    if (((NULL == params->message) && (0 == params->message_length) && (0x0000 != me->session_oid)) ||
+        (NULL != params->message))
+    {
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_encrypt_asym_handler,
+                           OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                           OPTIGA_CMD_EXEC_REQUEST_LOCK,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_ENCRYPT_ASYM, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+        return_status = OPTIGA_LIB_SUCCESS;
+    }
+    return (return_status);
+}
+#endif // OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+
+/*
+* EncryptAsym handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_decrypt_asym_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_decrypt_asym_params_t * p_optiga_decrypt_asym = (optiga_decrypt_asym_params_t *)me->p_input;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    uint16_t out_data_size;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending asymmetric decryption command..");
+            // APDU headed length + TLV of encrypt message + TLV of decrypt key OID + (optional)TLV of session key OID
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_TAG_LENGTH_SIZE + p_optiga_decrypt_asym->message_length +
+                                OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                                ((NULL != p_optiga_decrypt_asym->processed_message) &&
+                                (NULL != p_optiga_decrypt_asym->processed_message_length)
+                                ? 0 : OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES);
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                if (NULL != p_optiga_decrypt_asym->processed_message_length)
+                {
+                    *(p_optiga_decrypt_asym->processed_message_length) = 0;
+                }
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+            // Tag and length for encrypt message
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_DECRYPT_ASYM_ENCRYPT_MESSAGE_TAG,
+                                          p_optiga_decrypt_asym->message_length,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+            //Encrypt data
+            pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                          p_optiga_decrypt_asym->message,
+                          p_optiga_decrypt_asym->message_length);
+
+            index_for_data += p_optiga_decrypt_asym->message_length;
+
+            // Tag and length for OID of decrypt key
+            optiga_cmd_prepare_tag_header(OPTIGA_CMD_DECRYPT_ASYM_DECRYPT_KEY_TAG,
+                                          OPTIGA_CMD_DECRYPT_ASYM_DECRYPT_KEY_LENGTH,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+            //OID of decrypt key
+            optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                     (uint16_t)*((optiga_key_id_t*)p_optiga_decrypt_asym->key));
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            if ((NULL == p_optiga_decrypt_asym->processed_message) &&
+                (NULL == p_optiga_decrypt_asym->processed_message_length))
+            {
+                // Tag and length for session OID
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_DECRYPT_ASYM_SESSION_OID_TAG,
+                                              OPTIGA_CMD_DECRYPT_ASYM_SESSION_OID_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+                //OID of decrypt key
+                optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                         me->session_oid);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            }
+
+            // prepare apdu
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_DECRYPT_ASYM,
+                                           me->cmd_param,
+                                           (index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for asymmetric decryption command...");
+            // check if the write was successful
+            if (OPTIGA_CMD_APDU_FAILURE == me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                if (NULL != p_optiga_decrypt_asym->processed_message_length)
+                {
+                    *p_optiga_decrypt_asym->processed_message_length = 0;
+                }
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing asymmetric decryption response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            if ((NULL != p_optiga_decrypt_asym->processed_message) &&
+                (NULL != p_optiga_decrypt_asym->processed_message_length))
+            {
+                optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                                         OPTIGA_CMD_NO_OF_BYTES_IN_TAG], &out_data_size);
+                // if the received decrypted length is greater than the user provided decrypt buffer length
+                if ((*(p_optiga_decrypt_asym->processed_message_length )) < out_data_size)
+                {
+                    OPTIGA_CMD_LOG_MESSAGE("Error in processing asymmetric decryption response...");
+                    *(p_optiga_decrypt_asym->processed_message_length) = 0;
+                    return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                    break;
+                }
+
+                pal_os_memcpy(p_optiga_decrypt_asym->processed_message,
+                              &me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + OPTIGA_CMD_TAG_LENGTH_SIZE],
+                              out_data_size);
+                *p_optiga_decrypt_asym->processed_message_length = out_data_size;
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of asymmetric decryption command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_decrypt_asym(optiga_cmd_t * me, uint8_t cmd_param, optiga_decrypt_asym_params_t * params)
+{
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    optiga_decrypt_asym_params_t * p_optiga_decrypt_asym = (optiga_decrypt_asym_params_t*)params;
+    optiga_cmd_sub_state_t cmd_handler_state = OPTIGA_CMD_EXEC_REQUEST_LOCK;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+        if ((NULL == p_optiga_decrypt_asym->processed_message) &&
+            (NULL == p_optiga_decrypt_asym->processed_message_length))
+        {
+            cmd_handler_state = OPTIGA_CMD_EXEC_REQUEST_SESSION;
+        }
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_decrypt_asym_handler,
+                           OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                           cmd_handler_state,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_DECRYPT_ASYM, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+        return_status = OPTIGA_LIB_SUCCESS;
+    } while (FALSE);
+    return (return_status);
+}
+#endif // OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+
+#ifdef OPTIGA_CRYPT_HASH_ENABLED
+
+_STATIC_H void optiga_cmd_calc_hash_set_current_hash_sequence(const optiga_cmd_t * me)
+{
+    optiga_calc_hash_params_t * p_optiga_calc_hash = (optiga_calc_hash_params_t *)me->p_input;
+    uint32_t apparent_comms_buffer_size = (OPTIGA_MAX_COMMS_BUFFER_SIZE - (OPTIGA_CMD_APDU_INDATA_OFFSET + OPTIGA_CMD_HASH_HEADER_SIZE \
+                                          + OPTIGA_CMD_INTERMEDIATE_CONTEXT_HEADER));
+
+    p_optiga_calc_hash->current_hash_sequence = p_optiga_calc_hash->hash_sequence;
+
+    // Check for hash sequence as S&F
+    if(OPTIGA_CRYPT_HASH_START_FINAL == p_optiga_calc_hash->hash_sequence)
+    {
+        // Calculate the apparent comms buffer size and compare with hash data length
+        if(apparent_comms_buffer_size < p_optiga_calc_hash->p_hash_data->length)
+        {
+            // sent data is 0 hence change the hash sequence to S
+            if( 0 == p_optiga_calc_hash->data_sent)
+            {
+                p_optiga_calc_hash->current_hash_sequence = OPTIGA_CRYPT_HASH_START;
+            }
+            // sent data is greater than 0 and next fragment is greater than apparent_comms_buffer_size hence change the hash sequence to C
+            else if((p_optiga_calc_hash->data_sent + apparent_comms_buffer_size) < p_optiga_calc_hash->p_hash_data->length)
+            {
+                p_optiga_calc_hash->current_hash_sequence = OPTIGA_CRYPT_HASH_CONTINUE;
+            }
+            // sent data is greater than 0 and next fragment is less than apparent_comms_buffer_size hence change the hash sequence to F
+            else
+            {
+                p_optiga_calc_hash->current_hash_sequence = OPTIGA_CRYPT_HASH_FINAL;
+            }
+        }
+    }
+}
+
+/*
+* CalCHash handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_calc_hash_handler(optiga_cmd_t * me)
+{
+    optiga_calc_hash_params_t * p_optiga_calc_hash = (optiga_calc_hash_params_t *)me->p_input;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    uint16_t out_data_size;
+    uint32_t length_to_hash;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            optiga_cmd_calc_hash_set_current_hash_sequence(me);
+            OPTIGA_CMD_LOG_MESSAGE("Sending calculate hash command..");
+            //Hash Input
+            // tag setting
+            me->chaining_ongoing = FALSE;
+
+            // add data if available
+            if (NULL != p_optiga_calc_hash->p_hash_data)
+            {
+                 //lint --e{734} suppress "length_to_hash parameter is of uint16 type, while the arguments used for
+                 //calculating are of uint32 type. The final value calculated never crosses uint16 max value and for
+                 // future use case, explicit type-casting is not done "
+                length_to_hash = MIN(((OPTIGA_MAX_COMMS_BUFFER_SIZE - (index_for_data + OPTIGA_CMD_HASH_HEADER_SIZE + OPTIGA_CMD_INTERMEDIATE_CONTEXT_HEADER)) -
+                                       p_optiga_calc_hash->apparent_context_size),(p_optiga_calc_hash->p_hash_data->length - p_optiga_calc_hash->data_sent));
+
+                *(me->p_optiga->optiga_comms_buffer + index_for_data++) = p_optiga_calc_hash->current_hash_sequence;
+
+                // add length
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data), length_to_hash);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                              p_optiga_calc_hash->p_hash_data->buffer + p_optiga_calc_hash->data_sent,
+                              length_to_hash);
+                index_for_data += length_to_hash;
+
+                p_optiga_calc_hash->data_sent += length_to_hash;
+                if (p_optiga_calc_hash->data_sent != p_optiga_calc_hash->p_hash_data->length)
+                {
+                    me->chaining_ongoing = TRUE;
+                }
+            }
+            else if (NULL != p_optiga_calc_hash->p_hash_oid)
+            {
+                //OID data
+                optiga_cmd_prepare_tag_header(p_optiga_calc_hash->current_hash_sequence,
+                                              OPTIGA_CMD_OID_DATA_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              (uint16_t*)&index_for_data);
+
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data),
+                                          p_optiga_calc_hash->p_hash_oid->oid);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data),
+                                          p_optiga_calc_hash->p_hash_oid->offset);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data),
+                                          p_optiga_calc_hash->p_hash_oid->length);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            }
+            else
+            {
+                // Tag header in case of sequence as START
+                optiga_cmd_prepare_tag_header (p_optiga_calc_hash->current_hash_sequence,
+                                               OPTIGA_CMD_ZERO_LENGTH_OR_VALUE,
+                                               me->p_optiga->optiga_comms_buffer,
+                                               (uint16_t*)&index_for_data);
+            }
+            //Hash Context
+            if ((NULL != p_optiga_calc_hash->p_hash_context) &&
+                (0 != p_optiga_calc_hash->apparent_context_size))
+            {
+                *(me->p_optiga->optiga_comms_buffer + index_for_data++) = OPTIGA_CRYPT_INTERMEDIATE;
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data),
+                                          p_optiga_calc_hash->p_hash_context->context_buffer_length);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                              p_optiga_calc_hash->p_hash_context->context_buffer,
+                              p_optiga_calc_hash->p_hash_context->context_buffer_length);
+
+                index_for_data += p_optiga_calc_hash->p_hash_context->context_buffer_length;
+                p_optiga_calc_hash->apparent_context_size = 0;
+            }
+
+            //Export Option
+            if((TRUE == p_optiga_calc_hash->export_hash_ctx) && (FALSE == me->chaining_ongoing))
+            {
+                optiga_cmd_prepare_tag_header(OPTIGA_CRYPT_HASH_CONTX_OUT,
+                                              OPTIGA_CMD_ZERO_LENGTH_OR_VALUE,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              (uint16_t*)&index_for_data);
+            }
+
+            //form apdu header
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_CALC_HASH,
+                                           me->cmd_param,
+                                           (uint16_t)(index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (uint16_t)(index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for calculate hash command...");
+            // check for response status code
+            if (OPTIGA_CMD_APDU_FAILURE == me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing calculate hash response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            // Copy the digest to buffer, if chaining is false and digest out buffer is not NULL
+            if((FALSE == me->chaining_ongoing) && (NULL != p_optiga_calc_hash->p_out_digest))
+            {
+                // If the out data tag is not the digest out then return failure
+                if (OPTIGA_CRYPT_HASH_START_FINAL != me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET])
+                {
+                   break;
+                }
+                optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                                         OPTIGA_CMD_NO_OF_BYTES_IN_TAG], &out_data_size);
+
+                pal_os_memcpy(p_optiga_calc_hash->p_out_digest,
+                              &me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                              OPTIGA_CMD_NO_OF_BYTES_IN_TAG], out_data_size);
+            }
+            // Copy the intermediate hash context
+            else if ((TRUE == p_optiga_calc_hash->export_hash_ctx) && (FALSE == me->chaining_ongoing) && (NULL != p_optiga_calc_hash->p_hash_context))
+            {
+                // If the out data tag is not the intermediate tag then return failure
+                if (OPTIGA_CRYPT_INTERMEDIATE != me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET])
+                {
+                    break;
+                }
+
+                optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                                         OPTIGA_CMD_NO_OF_BYTES_IN_TAG], &out_data_size);
+                if (p_optiga_calc_hash->p_hash_context->context_buffer_length < out_data_size)
+                {
+                    OPTIGA_CMD_LOG_MESSAGE("Error in processing calculate hash response...");
+                    return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                    break;
+                }
+
+                pal_os_memcpy(p_optiga_calc_hash->p_hash_context->context_buffer,
+                              &me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                              OPTIGA_CMD_NO_OF_BYTES_IN_TAG], out_data_size);
+                p_optiga_calc_hash->p_hash_context->context_buffer_length = out_data_size;
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of calculate hash command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_calc_hash(optiga_cmd_t * me,
+                                         uint8_t cmd_param,
+                                         optiga_calc_hash_params_t * params)
+{
+    optiga_calc_hash_params_t * p_optiga_calc_hash = (optiga_calc_hash_params_t*)params;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+
+    p_optiga_calc_hash->data_sent = 0;
+
+    optiga_cmd_execute(me,
+                       cmd_param,
+                       optiga_cmd_calc_hash_handler,
+                       OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                       OPTIGA_CMD_EXEC_REQUEST_LOCK,
+                       params,
+                       //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                       OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_CALC_HASH, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+#endif //OPTIGA_CRYPT_HASH_ENABLED
+
+#if defined (OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || defined (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || \
+defined (OPTIGA_CRYPT_HMAC_ENABLED) || defined (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED) || defined (OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED)
+/*
+* Symmetric encrypt decrypt handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_enc_dec_sym_handler(optiga_cmd_t * me)
+{
+    optiga_encrypt_sym_params_t * p_optiga_sym_enc_dec_params = (optiga_encrypt_sym_params_t *)me->p_input;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    uint16_t response_data_length = 0;
+    uint16_t max_packet_length = 0;
+    uint16_t in_data_length = 0;
+    uint16_t total_apdu_length = 0;
+    uint16_t length_to_send = 0;
+    uint16_t symmetric_key_oid = 0;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+
+    me->chaining_ongoing = FALSE;
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending symmetric encrypt/decrypt command..");
+
+            ///Calculate length of data to be send
+            in_data_length = optiga_cmd_sym_get_max_indata_header_length(p_optiga_sym_enc_dec_params);
+            if (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE == in_data_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+                if (NULL != p_optiga_sym_enc_dec_params->out_data_length)
+                {
+                    *p_optiga_sym_enc_dec_params->out_data_length = 0;
+                }
+                break;
+            }
+            max_packet_length = optiga_cmd_sym_get_max_packet_length(p_optiga_sym_enc_dec_params, in_data_length);
+            /// If the mode is HMAC compare the input_data_length and maximum_packet_length
+            if ((TRUE == OPTIGA_CMD_IS_MODE_HMAC(p_optiga_sym_enc_dec_params->mode) && \
+                (OPTIGA_CMD_DECRYPT_SYM == OPTIGA_CMD_GET_APDU_CMD(me->apdu_data))))
+            {
+                if(max_packet_length < p_optiga_sym_enc_dec_params->in_data_length)
+                {
+                    return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+                    break;
+                }
+            }
+            length_to_send = (uint16_t)MIN(max_packet_length,(p_optiga_sym_enc_dec_params->in_data_length -
+                                                p_optiga_sym_enc_dec_params->sent_data_length));
+
+            // APDU header length + in data header size + length of data to transfer
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + in_data_length + length_to_send;
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                if (NULL != p_optiga_sym_enc_dec_params->out_data_length)
+                {
+                    *p_optiga_sym_enc_dec_params->out_data_length = 0;
+                }
+                break;
+            }
+
+            ///Secret key OID
+            // If the command is for HMAC verify then copy the secret oid thought the symmetric key oid is session based
+            symmetric_key_oid =
+                    (((uint16_t)OPTIGA_KEY_ID_SESSION_BASED == p_optiga_sym_enc_dec_params->symmetric_key_oid) && \
+                    (TRUE == OPTIGA_CMD_IS_MODE_HMAC(p_optiga_sym_enc_dec_params->mode)) && \
+                    ((OPTIGA_CMD_DECRYPT_SYM != OPTIGA_CMD_GET_APDU_CMD(me->apdu_data)))) ? \
+                    me->session_oid : p_optiga_sym_enc_dec_params->symmetric_key_oid;
+
+            optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                     symmetric_key_oid);
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+            ///Assign sequence
+            me->p_optiga->optiga_comms_buffer[index_for_data++] =
+                                              optiga_cmd_sym_get_current_enc_dec_sequence(p_optiga_sym_enc_dec_params,
+                                                                                          length_to_send,
+                                                                                          max_packet_length);
+            // For HMAC based mode verification append session oid
+            if ((TRUE == OPTIGA_CMD_IS_MODE_HMAC(p_optiga_sym_enc_dec_params->mode)) && \
+                (OPTIGA_CMD_DECRYPT_SYM == OPTIGA_CMD_GET_APDU_CMD(me->apdu_data)))
+            {                
+                optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                        length_to_send + OPTIGA_CMD_DECRYPT_SYM_SESSION_OID_LENGTH);
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+
+                optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data], me->session_oid);
+            }
+            else
+            {
+                optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data], length_to_send);
+            }
+            index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+            
+            if (NULL != p_optiga_sym_enc_dec_params->in_data)
+            {
+                pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                              p_optiga_sym_enc_dec_params->in_data + p_optiga_sym_enc_dec_params->sent_data_length,
+                              length_to_send);
+                index_for_data += length_to_send;
+            }
+            p_optiga_sym_enc_dec_params->sent_data_length += length_to_send;
+
+            if ((OPTIGA_CRYPT_SYM_START_FINAL == p_optiga_sym_enc_dec_params->current_sequence) ||
+               (OPTIGA_CRYPT_SYM_START == p_optiga_sym_enc_dec_params->current_sequence))
+            {
+                if ((NULL != p_optiga_sym_enc_dec_params->iv) && \
+                    (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_sym_enc_dec_params->iv_length))
+                {
+                    ///TLV formation for IV
+                    optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENC_DEC_SYM_IV_TAG,
+                                                  p_optiga_sym_enc_dec_params->iv_length,
+                                                  me->p_optiga->optiga_comms_buffer,
+                                                  &index_for_data);
+                    pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                                  p_optiga_sym_enc_dec_params->iv,
+                                  p_optiga_sym_enc_dec_params->iv_length);
+                    index_for_data += p_optiga_sym_enc_dec_params->iv_length;
+                }
+                if ((NULL != p_optiga_sym_enc_dec_params->associated_data) && \
+                    (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_sym_enc_dec_params->associated_data_length))
+                {
+                    ///TLV formation for Associate data
+                    optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENC_DEC_SYM_ASSOCIATED_DATA_TAG,
+                                                  p_optiga_sym_enc_dec_params->associated_data_length,
+                                                  me->p_optiga->optiga_comms_buffer,
+                                                  &index_for_data);
+                    pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                                  p_optiga_sym_enc_dec_params->associated_data,
+                                  p_optiga_sym_enc_dec_params->associated_data_length);
+                    index_for_data += p_optiga_sym_enc_dec_params->associated_data_length;
+                }
+                if (0 != p_optiga_sym_enc_dec_params->total_input_data_length)
+                {
+                    ///TLV information for total input data length
+
+                    optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENC_DEC_SYM_TOTAL_DATA_LENGTH_TAG,
+                                                  OPTIGA_CMD_UINT16_SIZE_IN_BYTES,
+                                                  me->p_optiga->optiga_comms_buffer,
+                                                  &index_for_data);
+                    optiga_common_set_uint16(&me->p_optiga->optiga_comms_buffer[index_for_data],
+                                             p_optiga_sym_enc_dec_params->total_input_data_length);
+                    index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+                }
+                if ((OPTIGA_CMD_DECRYPT_SYM == OPTIGA_CMD_GET_APDU_CMD(me->apdu_data)) && \
+                    (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE != p_optiga_sym_enc_dec_params->generated_hmac_length))
+                {
+                    ///TLV formation for Associate data
+                    optiga_cmd_prepare_tag_header(OPTIGA_CMD_ENC_DEC_SYM_VERIFICATION_DATA_TAG,
+                                                  (uint16_t)p_optiga_sym_enc_dec_params->generated_hmac_length,
+                                                  me->p_optiga->optiga_comms_buffer,
+                                                  &index_for_data);
+                    pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                                  p_optiga_sym_enc_dec_params->generated_hmac,
+                                  p_optiga_sym_enc_dec_params->generated_hmac_length);
+                    index_for_data += (uint16_t)p_optiga_sym_enc_dec_params->generated_hmac_length;
+                }
+            }
+            //form apdu header
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_GET_APDU_CMD(me->apdu_data),
+                                           me->cmd_param,
+                                           (uint16_t)(index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (uint16_t)(index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for symmetric encrypt/decrypt command...");
+            // Return success when operation mode is clear auto state
+            if (OPTIGA_CMD_OPERATION_MODE_CLEAR_AUTO_STATE == p_optiga_sym_enc_dec_params->operation_mode)
+            {
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_RELEASE_SESSION;
+                return_status = OPTIGA_LIB_SUCCESS;
+                break;
+            }
+            // check if the write was successful
+            if (OPTIGA_CMD_APDU_FAILURE == me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing symmetric encrypt/decrypt response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                if (NULL != p_optiga_sym_enc_dec_params->out_data_length)
+                {
+                    *p_optiga_sym_enc_dec_params->out_data_length = 0;
+                }
+                if((TRUE == OPTIGA_CMD_IS_MODE_HMAC(p_optiga_sym_enc_dec_params->mode)) && \
+                    ((OPTIGA_CMD_DECRYPT_SYM == OPTIGA_CMD_GET_APDU_CMD(me->apdu_data))))
+                {
+                    me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_RELEASE_SESSION;                
+                }
+                break;
+            }
+
+            // No need to check the 0x61 tag and chaining for HMAC verify
+            if ((TRUE == OPTIGA_CMD_IS_MODE_HMAC(p_optiga_sym_enc_dec_params->mode)) && \
+                ((OPTIGA_CMD_DECRYPT_SYM == OPTIGA_CMD_GET_APDU_CMD(me->apdu_data))))
+            {
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_RELEASE_SESSION;                
+            }
+            else
+            {
+                // check if 0x61 outdata tag is available in response for expected modes
+                if ((FALSE == OPTIGA_CMD_IS_MODE_MAC(p_optiga_sym_enc_dec_params->mode)) ||
+                   ((TRUE == OPTIGA_CMD_IS_MODE_MAC(p_optiga_sym_enc_dec_params->mode)) &&
+                   ((OPTIGA_CRYPT_SYM_START_FINAL == p_optiga_sym_enc_dec_params->current_sequence) || \
+                   (OPTIGA_CRYPT_SYM_FINAL == p_optiga_sym_enc_dec_params->current_sequence))))
+                {
+                    if (OPTIGA_CMD_ENC_DEC_SYM_OUT_DATA_TAG != me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET])
+                    {
+                        if (NULL != p_optiga_sym_enc_dec_params->out_data_length)
+                        {
+                            *p_optiga_sym_enc_dec_params->out_data_length = 0;
+                        }
+                        break;
+                    }
+                    optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                                             OPTIGA_CMD_NO_OF_BYTES_IN_TAG], &response_data_length);
+                }
+                // check if output buffer is available
+                if ((NULL != p_optiga_sym_enc_dec_params->out_data_length) && \
+                    (NULL != p_optiga_sym_enc_dec_params->out_data))
+                {
+                    // check if data received is bigger than the size of output buffer
+                    if ((p_optiga_sym_enc_dec_params->received_data_length + response_data_length) > \
+                        (*p_optiga_sym_enc_dec_params->out_data_length))
+                    {
+                        // If the encryption mode is MAC based and for START_FINAL or START encryption sequence
+                        if (((OPTIGA_CRYPT_SYM_START_FINAL == p_optiga_sym_enc_dec_params->current_sequence) || \
+                            (OPTIGA_CRYPT_SYM_FINAL == p_optiga_sym_enc_dec_params->current_sequence)) && \
+                            (TRUE == OPTIGA_CMD_IS_MODE_MAC(p_optiga_sym_enc_dec_params->mode)))
+                        {
+                            response_data_length = (uint16_t)(*p_optiga_sym_enc_dec_params->out_data_length);
+                        }
+                        else
+                        {
+                            return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                            *p_optiga_sym_enc_dec_params->out_data_length = 0;
+                            break;
+                        }
+                    }
+                    pal_os_memcpy(p_optiga_sym_enc_dec_params->out_data + p_optiga_sym_enc_dec_params->received_data_length,
+                                  &me->p_optiga->optiga_comms_buffer[(OPTIGA_CMD_APDU_INDATA_OFFSET + \
+                                  OPTIGA_CMD_UINT16_SIZE_IN_BYTES + OPTIGA_CMD_NO_OF_BYTES_IN_TAG)], response_data_length);
+                    p_optiga_sym_enc_dec_params->received_data_length += response_data_length;
+                }
+
+
+                // check if internal chaining is required
+                if (p_optiga_sym_enc_dec_params->in_data_length != p_optiga_sym_enc_dec_params->sent_data_length)
+                {
+                    me->chaining_ongoing = TRUE;
+                }
+                else
+                {
+                    if (NULL != p_optiga_sym_enc_dec_params->out_data_length)
+                    {
+                        *p_optiga_sym_enc_dec_params->out_data_length = p_optiga_sym_enc_dec_params->received_data_length;
+                    }
+                    // check if strict lock is needed to be released, based on encryption sequence
+                    if ((OPTIGA_CRYPT_SYM_START_FINAL == p_optiga_sym_enc_dec_params->current_sequence) ||
+                       (OPTIGA_CRYPT_SYM_FINAL == p_optiga_sym_enc_dec_params->current_sequence))
+                    {
+                        me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+                    }
+                    else
+                    {
+                        me->cmd_sub_execution_state = OPTIGA_CMD_STATE_EXIT;
+                        pal_os_event_start(me->p_optiga->p_pal_os_event_ctx, optiga_cmd_queue_scheduler, me->p_optiga);
+                    }
+                }
+            }
+
+            OPTIGA_CMD_LOG_MESSAGE("Response of symmetric encrypt/decrypt command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+#endif //(OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || (OPTIGA_CRYPT_HMAC_ENABLED) || (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED) || (OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED)
+
+#if defined (OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || defined (OPTIGA_CRYPT_HMAC_ENABLED)
+optiga_lib_status_t optiga_cmd_encrypt_sym(optiga_cmd_t * me,
+                                           uint8_t cmd_param,
+                                           optiga_encrypt_sym_params_t * params)
+{
+    optiga_cmd_state_t next_execution_state = OPTIGA_CMD_EXEC_PREPARE_COMMAND;
+    optiga_cmd_sub_state_t next_execution_sub_state = OPTIGA_CMD_EXEC_REQUEST_STRICT_LOCK;
+    optiga_lib_status_t return_status = OPTIGA_LIB_SUCCESS;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    params->sent_data_length = 0;
+    params->current_sequence = OPTIGA_CMD_RESET_SEQUENCE;
+    params->received_data_length = 0;
+
+    if ((OPTIGA_KEY_ID_SESSION_BASED == (optiga_key_id_t)params->symmetric_key_oid) &&
+        (OPTIGA_CMD_ZERO_LENGTH_OR_VALUE == me->session_oid) && (TRUE == OPTIGA_CMD_IS_MODE_HMAC(params->mode)))
+    {
+        if (NULL != params->out_data_length)
+        {
+            *params->out_data_length = 0;
+        }
+        return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    }
+    // Continue or Final API is invoked without strict lock acquired by instance
+    else if (((OPTIGA_CRYPT_SYM_FINAL == params->original_sequence) ||
+            (OPTIGA_CRYPT_SYM_CONTINUE == params->original_sequence)) &&
+            ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK !=
+            optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) ||
+            (OPTIGA_CMD_QUEUE_PROCESSING != optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))))
+    {
+        if (NULL != params->out_data_length)
+        {
+            *params->out_data_length = 0;
+        }
+        return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    }
+    else
+    {
+        // Continue or Final for encrypt symmetric is invoked while the strict lock was acquired by another command/mode
+        /*
+         Below are the conditions to be met for API to return failure :
+         1. API is invoked for encryption sequence Continue or Final
+         2. Instance has already acquired strict sequence
+         3.  - APDU CMD for which instance acquired strict lock is not Symmetric Encryption
+             - Symmetric mode of operation for which instance acquired strict lock doesn't match current invoked mode.
+         */
+        if (((OPTIGA_CRYPT_SYM_FINAL == params->original_sequence) ||
+           (OPTIGA_CRYPT_SYM_CONTINUE == params->original_sequence)) &&
+           ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == \
+           optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) &&
+           (OPTIGA_CMD_QUEUE_PROCESSING == optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))) &&
+           ((OPTIGA_CMD_ENCRYPT_SYM != OPTIGA_CMD_GET_APDU_CMD(me->apdu_data)) ||
+           ((OPTIGA_CMD_ENCRYPT_SYM == OPTIGA_CMD_GET_APDU_CMD(me->apdu_data)) &&
+           (params->operation_mode != OPTIGA_CMD_GET_APDU_INFO(me->apdu_data)))))
+        {
+            if (NULL != params->out_data_length)
+            {
+                *params->out_data_length = 0;
+            }
+            return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+
+            next_execution_state = OPTIGA_CMD_EXEC_PROCESS_RESPONSE;
+            next_execution_sub_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+        }
+        else
+        {
+            // Is re-acquisition of strict lock required
+            /*
+             Below are the conditions to be met for instance to reacquire strict lock :
+             1. Instance has already acquired strict sequence
+             2. API is invoked for encryption sequence Start or Start and Final
+             */
+            if (((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == \
+               optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) &&
+               (OPTIGA_CMD_QUEUE_PROCESSING == optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))) &&
+               ((OPTIGA_CRYPT_SYM_START_FINAL == params->original_sequence) || \
+               (OPTIGA_CRYPT_SYM_START == params->original_sequence)))
+            {
+                /// Reacquire the strict sequence
+                next_execution_state = OPTIGA_CMD_EXEC_PREPARE_COMMAND;
+                next_execution_sub_state = OPTIGA_CMD_EXEC_RESET_STRICT_LOCK;
+            }
+        }
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_enc_dec_sym_handler,
+                           next_execution_state,
+                           next_execution_sub_state,
+                           params,
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_ENCRYPT_SYM, params->operation_mode));
+    }
+    return (return_status);
+}
+#endif //(OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || (OPTIGA_CRYPT_HMAC_ENABLED)
+
+#if defined (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || defined (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED) ||\
+    defined (OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED)
+
+optiga_lib_status_t optiga_cmd_decrypt_sym(optiga_cmd_t * me,
+                                           uint8_t cmd_param,
+                                           optiga_decrypt_sym_params_t * params)
+{
+    optiga_cmd_state_t next_execution_state = OPTIGA_CMD_EXEC_PREPARE_COMMAND;
+    optiga_cmd_sub_state_t next_execution_sub_state = OPTIGA_CMD_EXEC_REQUEST_STRICT_LOCK;
+    optiga_lib_status_t return_status = OPTIGA_LIB_SUCCESS;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+    params->sent_data_length = 0;
+    params->current_sequence = OPTIGA_CMD_RESET_SEQUENCE;
+    params->received_data_length = 0;
+
+    // No session is acquired by instance and mode is HMAC
+    if ((OPTIGA_CMD_ZERO_LENGTH_OR_VALUE == me->session_oid) && (TRUE == OPTIGA_CMD_IS_MODE_HMAC(params->mode)) && \
+        (OPTIGA_CMD_OPERATION_MODE_HMAC == params->operation_mode))
+    {
+        return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    }
+
+    // Continue or Final API is invoked without strict lock acquired by instance
+    else if (((OPTIGA_CRYPT_SYM_FINAL == params->original_sequence) ||
+             (OPTIGA_CRYPT_SYM_CONTINUE == params->original_sequence)) &&
+             ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK != optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) ||
+             (OPTIGA_CMD_QUEUE_PROCESSING != optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))))
+    {
+        *params->out_data_length = 0;
+        return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    }
+    else
+    {
+        // Continue or Final for decrypt symmetric is invoked while the strict lock was acquired by another command
+        if (((OPTIGA_CRYPT_SYM_FINAL == params->original_sequence) ||
+           (OPTIGA_CRYPT_SYM_CONTINUE == params->original_sequence)) &&
+           ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == \
+           optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) &&
+           (OPTIGA_CMD_QUEUE_PROCESSING == optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))) &&
+           (OPTIGA_CMD_DECRYPT_SYM != OPTIGA_CMD_GET_APDU_CMD(me->apdu_data)))
+        {
+            *params->out_data_length = 0;
+            return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+            next_execution_state = OPTIGA_CMD_EXEC_PROCESS_RESPONSE;
+            next_execution_sub_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+        }
+        else
+        {
+            if (((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == \
+               optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) &&
+               (OPTIGA_CMD_QUEUE_PROCESSING == optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))) &&
+               ((OPTIGA_CRYPT_SYM_START_FINAL == params->original_sequence) || \
+               (OPTIGA_CRYPT_SYM_START == params->original_sequence)))
+            {
+                /// Reacquire the strict sequence
+                next_execution_state = OPTIGA_CMD_EXEC_PREPARE_COMMAND;
+                next_execution_sub_state = OPTIGA_CMD_EXEC_RESET_STRICT_LOCK;
+            }
+        }
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_enc_dec_sym_handler,
+                           next_execution_state,
+                           next_execution_sub_state,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_DECRYPT_SYM, params->operation_mode));
+    }
+    return (return_status);
+}
+#endif //(OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED) || (OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED)
+
+/*
+* Set Data Object handler for protected update
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_set_object_protected_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_set_object_protected_params_t * p_optiga_write_protected_data = (optiga_set_object_protected_params_t *)me->p_input;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending set data object command..");
+            me->chaining_ongoing = FALSE;
+
+            // APDU header size + Set Object protected tag 1 bytes + length of buffer 2 bytes + size of data to send
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE + OPTIGA_CMD_NO_OF_BYTES_IN_TAG + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                                p_optiga_write_protected_data->p_protected_update_buffer_length;
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+
+            // Copy the tag and protected length
+            optiga_cmd_prepare_tag_header((OPTIGA_CMD_SET_OBJECT_PROTECTED_TAG |
+                                           (uint8_t)p_optiga_write_protected_data->set_obj_protected_tag),
+                                          p_optiga_write_protected_data->p_protected_update_buffer_length,
+                                          me->p_optiga->optiga_comms_buffer,
+                                          &index_for_data);
+            // data to be written
+            pal_os_memcpy(me->p_optiga->optiga_comms_buffer + index_for_data,
+                          p_optiga_write_protected_data->p_protected_update_buffer,
+                          p_optiga_write_protected_data->p_protected_update_buffer_length);
+
+            index_for_data += p_optiga_write_protected_data->p_protected_update_buffer_length;
+            // prepare apdu
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_SET_OBJECT_PROTECTED,
+                                           me->cmd_param,
+                                           (index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for set data object data command...");
+            // check if the write was successful
+            if (OPTIGA_CMD_APDU_SUCCESS != me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing set data object response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+            if (OPTIGA_SET_PROTECTED_UPDATE_FINAL == p_optiga_write_protected_data->set_obj_protected_tag)
+            {
+                me->cmd_sub_execution_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+            }
+            else
+            {
+                me->cmd_sub_execution_state = OPTIGA_CMD_STATE_EXIT;
+                pal_os_event_start(me->p_optiga->p_pal_os_event_ctx, optiga_cmd_queue_scheduler, me->p_optiga);
+            }
+            OPTIGA_CMD_LOG_MESSAGE("Response of set data object command is processed...");
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        default:
+            break;
+    }
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_set_object_protected(optiga_cmd_t * me, uint8_t cmd_param,
+                                                    optiga_set_object_protected_params_t * params)
+{
+    optiga_cmd_state_t next_execution_state = OPTIGA_CMD_EXEC_PREPARE_COMMAND;
+    optiga_cmd_sub_state_t next_execution_sub_state = OPTIGA_CMD_EXEC_REQUEST_STRICT_LOCK;
+    optiga_lib_status_t return_status = OPTIGA_LIB_SUCCESS;
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+
+    // Continue or Final API is invoked without strict lock acquired by instance
+    if (((OPTIGA_SET_PROTECTED_UPDATE_FINAL == params->set_obj_protected_tag) ||
+       (OPTIGA_SET_PROTECTED_UPDATE_CONTINUE == params->set_obj_protected_tag)) &&
+       ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK != optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) ||
+       (OPTIGA_CMD_QUEUE_PROCESSING != optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))))
+
+    {
+        return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+    }
+    else
+    {
+        if (( NULL == params->p_protected_update_buffer ) &&
+            (OPTIGA_SET_PROTECTED_UPDATE_FINAL == params->set_obj_protected_tag))
+        {
+            /// Release the strict sequence
+            next_execution_state = OPTIGA_CMD_EXEC_PROCESS_RESPONSE;
+            next_execution_sub_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+        }
+        // Continue or Final for set object protected API is invoked while the strict lock was acquired by another command
+        else if (((OPTIGA_SET_PROTECTED_UPDATE_FINAL == params->set_obj_protected_tag) ||
+                (OPTIGA_SET_PROTECTED_UPDATE_CONTINUE == params->set_obj_protected_tag)) &&
+                ((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == \
+                optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) &&
+                (OPTIGA_CMD_QUEUE_PROCESSING == optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))) &&
+                (OPTIGA_CMD_SET_OBJECT_PROTECTED != OPTIGA_CMD_GET_APDU_CMD(me->apdu_data)))
+        {
+            return_status = OPTIGA_CMD_ERROR_INVALID_INPUT;
+            /// Release the strict sequence
+            next_execution_state = OPTIGA_CMD_EXEC_PROCESS_RESPONSE;
+            next_execution_sub_state = OPTIGA_CMD_EXEC_RELEASE_LOCK;
+        }
+        else
+        {
+            if (((OPTIGA_CMD_QUEUE_REQUEST_STRICT_LOCK == \
+               optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_LOCK_TYPE)) &&
+               (OPTIGA_CMD_QUEUE_PROCESSING == optiga_cmd_queue_get_state_of(me, OPTIGA_CMD_QUEUE_SLOT_STATE))) &&
+               (OPTIGA_SET_PROTECTED_UPDATE_START == params->set_obj_protected_tag))
+            {
+                /// Reacquire the strict sequence
+                next_execution_state = OPTIGA_CMD_EXEC_PREPARE_COMMAND;
+                next_execution_sub_state = OPTIGA_CMD_EXEC_RESET_STRICT_LOCK;
+            }
+        }
+        optiga_cmd_execute(me,
+                           cmd_param,
+                           optiga_cmd_set_object_protected_handler,
+                           next_execution_state,
+                           next_execution_sub_state,
+                           params,
+                           //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                           OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_SET_OBJECT_PROTECTED, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+    }
+
+    return (return_status);
+}
+
+#ifdef OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+/*
+* Symmetric Generate Key handler
+*/
+_STATIC_H optiga_lib_status_t optiga_cmd_gen_symkey_handler(optiga_cmd_t * me)
+{
+    uint16_t total_apdu_length;
+    optiga_gen_symkey_params_t * p_optiga_gen_symkey = (optiga_gen_symkey_params_t *)me->p_input;
+    uint16_t index_for_data = OPTIGA_CMD_APDU_INDATA_OFFSET;
+    uint16_t gen_sym_key_length;
+    optiga_lib_status_t return_status = OPTIGA_CMD_ERROR;
+
+    switch ((uint8_t)me->cmd_next_execution_state)
+    {
+        case OPTIGA_CMD_EXEC_PREPARE_COMMAND:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Sending generate symmetric key command..");
+            // APDU header length +
+            // If symmetric key option to store in OID (TLV of symmetric key + TLV of key usages)
+            // If symmetric key option to export (TLV of export key)
+            total_apdu_length = OPTIGA_CMD_APDU_HEADER_SIZE +
+                                (FALSE == p_optiga_gen_symkey->export_symmetric_key ?
+                                (OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_UINT16_SIZE_IN_BYTES +
+                                OPTIGA_CMD_TAG_LENGTH_SIZE + OPTIGA_CMD_NO_OF_BYTES_IN_TAG):
+                                (OPTIGA_CMD_TAG_LENGTH_SIZE ));
+            if (OPTIGA_MAX_COMMS_BUFFER_SIZE < total_apdu_length)
+            {
+                return_status = OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT;
+                break;
+            }
+            if (FALSE == p_optiga_gen_symkey->export_symmetric_key)
+            {
+                ///TLV formation for symmetric key OID
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_GEN_SYM_KEY_OID_TAG,
+                                              OPTIGA_CMD_GEN_SYM_KEY_OID_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+                ///Update OID based on input param
+                optiga_common_set_uint16((me->p_optiga->optiga_comms_buffer + index_for_data),
+                                         (uint16_t)*((optiga_key_id_t *)p_optiga_gen_symkey->symmetric_key));
+
+                index_for_data += OPTIGA_CMD_UINT16_SIZE_IN_BYTES;
+                ///TLV formation for key usage
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_GEN_SYM_KEY_USAGE_TAG,
+                                              OPTIGA_CMD_GEN_SYM_KEY_USAGE_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+
+                *(me->p_optiga->optiga_comms_buffer + index_for_data++) = p_optiga_gen_symkey->key_usage;
+            }
+            else
+            {
+                ///TLV formation for export key
+                optiga_cmd_prepare_tag_header(OPTIGA_CMD_GEN_SYM_KEY_EXPORT_TAG,
+                                              OPTIGA_CMD_GEN_SYM_KEY_EXPORT_LENGTH,
+                                              me->p_optiga->optiga_comms_buffer,
+                                              &index_for_data);
+            }
+
+            //form apdu header
+            optiga_cmd_prepare_apdu_header(OPTIGA_CMD_GEN_SYM_KEY,
+                                           me->cmd_param,
+                                           (uint16_t)(index_for_data - OPTIGA_CMD_APDU_INDATA_OFFSET),
+                                           me->p_optiga->optiga_comms_buffer + OPTIGA_COMMS_DATA_OFFSET);
+
+            me->p_optiga->comms_tx_size = (uint16_t)(index_for_data - OPTIGA_COMMS_DATA_OFFSET);
+            return_status = OPTIGA_LIB_SUCCESS;
+        }
+        break;
+        case OPTIGA_CMD_EXEC_PROCESS_RESPONSE:
+        {
+            OPTIGA_CMD_LOG_MESSAGE("Processing response for generate symmetric key command...");
+            // check for response status code
+            if (OPTIGA_CMD_APDU_FAILURE == me->p_optiga->optiga_comms_buffer[OPTIGA_COMMS_DATA_OFFSET])
+            {
+                OPTIGA_CMD_LOG_MESSAGE("Error in processing generate keypair response...");
+                //lint --e{835} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                //lint --e{845} suppress "SET_DEV_ERROR_NOTIFICATION is generically written for any unsigned interger value"
+                SET_DEV_ERROR_NOTIFICATION(OPTIGA_CMD_EXIT_HANDLER_CALL);
+                break;
+            }
+
+            if (FALSE != p_optiga_gen_symkey->export_symmetric_key)
+            {
+                if (OPTIGA_CMD_GEN_SYM_KEY_TAG != me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET])
+                {
+                    break;
+                }
+                optiga_common_get_uint16(&me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                                         OPTIGA_CMD_NO_OF_BYTES_IN_TAG], &gen_sym_key_length);
+
+                pal_os_memcpy((uint8_t *)p_optiga_gen_symkey->symmetric_key,
+                              &me->p_optiga->optiga_comms_buffer[OPTIGA_CMD_APDU_INDATA_OFFSET +
+                              OPTIGA_CMD_UINT16_SIZE_IN_BYTES + OPTIGA_CMD_NO_OF_BYTES_IN_TAG],
+                              gen_sym_key_length);
+            }
+            return_status = OPTIGA_LIB_SUCCESS;
+
+            OPTIGA_CMD_LOG_MESSAGE("Response of symmetric generate key command is processed...");
+        }
+        break;
+        default:
+            break;
+    }
+
+    return (return_status);
+}
+
+optiga_lib_status_t optiga_cmd_gen_symkey(optiga_cmd_t * me, uint8_t cmd_param, optiga_gen_symkey_params_t * params)
+{
+    OPTIGA_CMD_LOG_MESSAGE(__FUNCTION__);
+
+    optiga_cmd_execute(me,
+                       cmd_param,
+                       optiga_cmd_gen_symkey_handler,
+                       OPTIGA_CMD_EXEC_PREPARE_COMMAND,
+                       OPTIGA_CMD_EXEC_REQUEST_LOCK,
+                       params,
+                       //lint --e{835} suppress "Upper 8 bits of apdu_data is kept as zero and is reserved for future enhancements"
+                       OPTIGA_CMD_SET_APDU_DATA(OPTIGA_CMD_GEN_SYM_KEY, OPTIGA_CMD_ZERO_LENGTH_OR_VALUE));
+
+    return (OPTIGA_LIB_SUCCESS);
+}
+#endif //OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/common/optiga_lib_common.c b/3rdparty/experimental/optiga/optiga/common/optiga_lib_common.c
new file mode 100644
index 000000000..6dac7f070
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/common/optiga_lib_common.c
@@ -0,0 +1,72 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_lib_common.c
+*
+* \brief   This file implements the commonly used functions by the OPTIGA Library .
+*
+* \ingroup  grOptigaLibCommon
+*
+* @{
+*/
+
+#include "optiga/common/optiga_lib_types.h"
+#include "optiga/common/optiga_lib_common.h"
+
+void optiga_common_set_uint16 (uint8_t * p_output_buffer,uint16_t two_byte_value)
+{
+    *p_output_buffer = (uint8_t)(two_byte_value>>8);
+    *(p_output_buffer + 1) = (uint8_t)(two_byte_value);
+}
+
+void optiga_common_set_uint32 (uint8_t* p_output_buffer,uint32_t four_byte_value)
+{
+    *(p_output_buffer) = (uint8_t)(four_byte_value>>24);
+    *(p_output_buffer + 1) = (uint8_t)(four_byte_value>>16);
+    *(p_output_buffer + 2) = (uint8_t)(four_byte_value>>8);
+    *(p_output_buffer + 3) = (uint8_t)(four_byte_value);
+}
+
+uint32_t optiga_common_get_uint32 (const uint8_t* p_input_buffer)
+{
+    uint32_t four_byte_value;
+    four_byte_value = ((uint32_t)(*p_input_buffer))<< 24 | ((uint32_t)(*(p_input_buffer + 1))<< 16 |
+                      ((uint32_t)(*(p_input_buffer + 2)))<< 8 | (uint32_t)(*(p_input_buffer + 3)));
+
+    return (four_byte_value);
+}
+
+void optiga_common_get_uint16 (const uint8_t * p_input_buffer,uint16_t* p_two_byte_value)
+{
+    *p_two_byte_value = (uint16_t)(*p_input_buffer << 8);
+    *p_two_byte_value |= (uint16_t)(*(p_input_buffer+1));
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/common/optiga_lib_logger.c b/3rdparty/experimental/optiga/optiga/common/optiga_lib_logger.c
new file mode 100644
index 000000000..f4e191116
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/common/optiga_lib_logger.c
@@ -0,0 +1,260 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_lib_logger.c
+*
+* \brief   This file implements the APIs for the OPTIGA library logger.
+*
+* \ingroup  grOptigaLibCommon
+*
+* @{
+*/
+
+#include "optiga/common/optiga_lib_common.h"
+#include "optiga/common/optiga_lib_logger.h"
+#include "optiga/pal/pal_logger.h"
+#include "optiga/pal/pal_os_memory.h"
+
+
+#define OPTIGA_LOGGER_NEW_LINE_CHAR          0x0D, 0x0A
+
+extern pal_logger_t logger_console;
+
+/*Convert Byte to HexString */
+#define OPTIGA_LOGGER_CONVERT_BYTE_TO_HEX(hex_byte, p_hex_string, index) \
+{ \
+    uint8_t nibble;                       \
+    nibble = (hex_byte & 0xF0)>>4;         \
+    p_hex_string [index++] = ((nibble > 0x09)) ? (nibble + 0x37) : (nibble + 0x30); \
+    nibble = hex_byte & 0x0F;         \
+    p_hex_string [index++] = ((nibble > 0x09)) ? (nibble + 0x37) : (nibble + 0x30); \
+}
+
+/* Converts the uint8 array to hex string format */
+_STATIC_H void optiga_lib_byte_to_hex_string(const uint8_t * p_array_buffer,
+                                             uint8_t * p_hex_string,
+                                             uint32_t length,
+                                             bool_t is_input_byte_array)
+{
+    uint32_t loop = 0;
+    uint8_t hex_byte = 0, index = 0;
+
+    do
+    {
+        if ((NULL == p_array_buffer) || (NULL == p_hex_string))
+        {
+            return;
+        }
+
+        for (loop = 0; loop < length; loop++)
+        {
+            index = 0;
+            hex_byte = p_array_buffer[loop];
+            if (TRUE == is_input_byte_array)
+            {
+                p_hex_string [index++] = '0';
+                p_hex_string [index++] = 'x';
+            }
+
+            /*Convert Byte to HexString */
+            OPTIGA_LOGGER_CONVERT_BYTE_TO_HEX(hex_byte,p_hex_string, index);
+            
+            p_hex_string [index++] = ' ';
+            p_hex_string += index;
+        }
+        *p_hex_string = 0x00;
+    } while(0);
+}
+/* Converts the uint16 value to hex string format */
+_STATIC_H void optiga_lib_word_to_hex_string(uint16_t value,
+                                             uint8_t * p_buffer)
+{
+    uint8_t array_buffer [5] = {0};   
+    uint8_t loop, hex_byte = 0, index = 0;
+    
+    array_buffer [0] = (uint8_t)((value & 0xFF00) >> 8);
+    array_buffer [1] = (uint8_t)((value & 0x00FF));
+
+    p_buffer [index++] = '0';
+    p_buffer [index++] = 'x';
+    
+    for (loop = 0; loop < 2; loop++)
+    {
+        hex_byte = array_buffer[loop];
+
+        /*Convert Byte to HexString */
+        OPTIGA_LOGGER_CONVERT_BYTE_TO_HEX(hex_byte,p_buffer, index);
+    }    
+
+}
+
+/* Converts the uint16 value to hex string format */
+_STATIC_H void optiga_lib_print_length_of_data(uint16_t value)
+{
+    uint8_t uint16t_conv_buffer [10] = {0};
+    char_t print_buffer[50];      
+
+    sprintf((char_t *)print_buffer, "%37s", "Length of data - ");
+    strcat(print_buffer,OPTIGA_HEX_BYTE_SEPERATOR);
+    optiga_lib_word_to_hex_string(value,uint16t_conv_buffer);
+    strcat(print_buffer,(char_t *)uint16t_conv_buffer); 
+    
+    optiga_lib_print_string_with_newline(print_buffer);
+}
+
+void optiga_lib_print_string(const char_t * p_log_string)
+{
+    if (NULL == p_log_string)
+    {
+        return;
+    }
+
+    //lint --e{534} The return value is not used hence not checked*/
+    pal_logger_write(&logger_console, (const uint8_t *)p_log_string, strlen(p_log_string));
+}
+
+void optiga_lib_print_string_with_newline(const char_t * p_log_string)
+{
+    uint8_t new_line_characters [2] = {OPTIGA_LOGGER_NEW_LINE_CHAR};
+
+    if (NULL == p_log_string)
+    {
+        return;
+    }
+
+    //lint --e{534} The return value is not used hence not checked*/
+    pal_logger_write(&logger_console, (const uint8_t *)p_log_string, strlen(p_log_string));
+    //lint --e{534} The return value is not used hence not checked*/
+    pal_logger_write(&logger_console, new_line_characters, 2);
+
+}
+
+void optiga_lib_print_message(const char_t * p_log_string,
+                              const char_t * p_log_layer,
+                              const char_t * p_log_color)                                  
+{
+    uint8_t new_line_characters[2] = {OPTIGA_LOGGER_NEW_LINE_CHAR};
+    char_t color_buffer[400];
+
+    if ((NULL == p_log_string) || (NULL == p_log_layer) || (NULL == p_log_color))
+    {
+        return;
+    }
+
+    OPTIGA_LIB_LOGGER_PRINT_INFO(color_buffer, p_log_string, p_log_layer, p_log_color);
+    //lint --e{534} The return value is not used hence not checked*/
+    pal_logger_write(&logger_console, (const uint8_t *)color_buffer, strlen(color_buffer));
+    //lint --e{534} The return value is not used hence not checked*/
+    pal_logger_write(&logger_console, new_line_characters, 2);
+}
+
+void optiga_lib_print_status(const char_t * p_log_layer,
+                             const char_t * p_log_color,
+                             uint16_t return_value)
+{
+    uint8_t new_line_characters[2] = {OPTIGA_LOGGER_NEW_LINE_CHAR};
+    uint8_t uint16t_conv_buffer[10] = {0};
+    char_t return_value_buffer[20] = {0};
+    char_t string_buffer[100] = {0};
+    char_t color_buffer[400];
+
+    if ((NULL == p_log_layer) || (NULL == p_log_color))
+    {
+        return;
+    }
+
+    // if return value is successful, log SUCCESS
+    if (OPTIGA_LIB_SUCCESS == return_value)
+    {
+        strcat(string_buffer,p_log_layer);
+        strcat(string_buffer,"Passed");
+        strcat(return_value_buffer,"");
+    }
+    else
+    {
+        strcat(string_buffer,p_log_layer);
+        strcat(string_buffer,"Failed with return value - ");
+        strcat(return_value_buffer,OPTIGA_HEX_BYTE_SEPERATOR);
+        optiga_lib_word_to_hex_string(return_value,uint16t_conv_buffer);
+        strcat(return_value_buffer,(char_t *)uint16t_conv_buffer);
+    }
+
+    OPTIGA_LIB_LOGGER_PRINT_INFO(color_buffer, (char_t *)return_value_buffer, string_buffer, p_log_color);
+
+    //lint --e{534} The return value is not used hence not checked*/
+    pal_logger_write(&logger_console, (const uint8_t *)color_buffer, strlen(color_buffer));
+    //Print new line
+    //lint --e{534} The return value is not used hence not checked*/
+    pal_logger_write(&logger_console, new_line_characters, 2);
+}
+
+void optiga_lib_print_array_hex_format(const uint8_t * p_log_string,
+                                       uint16_t length,
+                                       const char_t * p_log_color)
+{
+    uint8_t temp_buffer[350];
+    char_t output_buffer[400];
+    uint16_t index;
+    uint16_t temp_length;
+    char_t new_line_characters[2] = {OPTIGA_LOGGER_NEW_LINE_CHAR};
+    uint8_t buffer_window = 32; // Alignment of 16 bytes per line
+
+    if ((NULL == p_log_string) || (NULL == p_log_color))
+    {
+        return;
+    }
+    
+    optiga_lib_print_length_of_data(length);
+    
+    //Logging the arrays in chunks of 16 bytes through chaining
+    for (index = 0; index < length; index+=buffer_window)
+    {
+        temp_length = buffer_window;
+        if ((length - index) < buffer_window)
+        {
+            temp_length =  length - index;
+        }
+
+        pal_os_memset(temp_buffer, 0x00, sizeof(temp_buffer));
+        pal_os_memset(output_buffer, 0x00, sizeof(output_buffer));
+
+        optiga_lib_byte_to_hex_string((uint8_t*)(p_log_string + index), temp_buffer, temp_length, FALSE);
+
+        OPTIGA_LIB_LOGGER_PRINT_ARRAY(output_buffer,temp_buffer, p_log_color);
+
+        // New line characted entered at the end of each segment
+        output_buffer[strlen(output_buffer)] = new_line_characters[0];
+        output_buffer[strlen(output_buffer)+1] = new_line_characters[1];
+        //lint --e{534} The return value is not used hence not checked*/
+        pal_logger_write(&logger_console, (const uint8_t *)output_buffer, strlen(output_buffer) + 2);
+    }
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c.c b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c.c
new file mode 100644
index 000000000..571ddacef
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c.c
@@ -0,0 +1,355 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c.c
+*
+* \brief   This file implements the wrapper API Layer for IFX I2C protocol v2.00.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+#include "optiga/ifx_i2c/ifx_i2c.h"
+#include "optiga/pal/pal_os_event.h"
+
+#ifndef OPTIGA_COMMS_SHIELDED_CONNECTION
+#include "optiga/ifx_i2c/ifx_i2c_transport_layer.h"
+#else
+#include "optiga/ifx_i2c/ifx_i2c_presentation_layer.h"
+#endif
+
+/// @cond hidden
+
+// IFX I2C states
+#define IFX_I2C_STATE_UNINIT         (0x01)
+#define IFX_I2C_STATE_IDLE           (0x02)
+#define IFX_I2C_STATUS_BUSY          (0x03)
+#define IFX_I2C_STATUS_NOT_BUSY      (0x04)
+
+/// IFX I2C Reset states
+#define IFX_I2C_STATE_RESET_PIN_LOW        (0xB1)
+#define IFX_I2C_STATE_RESET_PIN_HIGH       (0xB2)
+#define IFX_I2C_STATE_RESET_INIT           (0xB3)
+
+void ifx_i2c_tl_event_handler(ifx_i2c_context_t * p_ctx,
+                              optiga_lib_status_t event,
+                              const uint8_t * p_data,
+                              uint16_t data_len);
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+_STATIC_H void ifx_i2c_prl_close_event_handler(ifx_i2c_context_t * p_ctx,
+                                               optiga_lib_status_t event,
+                                               const uint8_t * p_data,
+                                               uint16_t data_len);
+#endif
+_STATIC_H optiga_lib_status_t ifx_i2c_init(ifx_i2c_context_t * p_ifx_i2c_context);
+
+//lint --e{526} suppress "This API is defined in ifx_i2c_physical_layer.c file. As it is a low level API, it is not exposed in header file"
+extern optiga_lib_status_t ifx_i2c_pl_write_slave_address(ifx_i2c_context_t * p_ctx,
+                                                          uint8_t slave_address,
+                                                          uint8_t storage_type);
+/// @endcond
+
+optiga_lib_status_t ifx_i2c_open(ifx_i2c_context_t * p_ctx)
+{
+    optiga_lib_status_t api_status = (int32_t)IFX_I2C_STACK_ERROR;
+
+    //If api status is not busy, proceed
+    if ((IFX_I2C_STATUS_BUSY != p_ctx->status))
+    {
+        do
+        {
+            p_ctx->p_pal_i2c_ctx->p_upper_layer_ctx = p_ctx;
+            p_ctx->reset_type = OPTIGA_COMMS_DEFAULT_RESET_TYPE;
+            if(p_ctx->reset_type > (uint8_t)IFX_I2C_WARM_RESET)
+            {
+                break;
+            }
+            p_ctx->reset_state = IFX_I2C_STATE_RESET_PIN_LOW;
+            p_ctx->do_pal_init = TRUE;
+            p_ctx->state = IFX_I2C_STATE_UNINIT;
+
+            api_status = ifx_i2c_init(p_ctx);
+            if (IFX_I2C_STACK_SUCCESS == api_status)
+            {
+                p_ctx->status = IFX_I2C_STATUS_BUSY;
+            }
+        }while(FALSE);
+    }
+    return (api_status);
+}
+
+
+optiga_lib_status_t ifx_i2c_reset(ifx_i2c_context_t * p_ctx,
+                                  ifx_i2c_reset_type_t reset_type)
+{
+    optiga_lib_status_t api_status = (int32_t)IFX_I2C_STACK_ERROR;
+
+    // Proceed, if not busy and in idle state
+    if ((IFX_I2C_STATE_IDLE == p_ctx->state) && (IFX_I2C_STATUS_BUSY != p_ctx->status))
+    {
+        p_ctx->reset_type = (uint8_t)reset_type;
+        p_ctx->reset_state = IFX_I2C_STATE_RESET_PIN_LOW;
+        p_ctx->do_pal_init = FALSE;
+
+        api_status = ifx_i2c_init(p_ctx);
+        if (IFX_I2C_STACK_SUCCESS == api_status)
+        {
+            p_ctx->status = IFX_I2C_STATUS_BUSY;
+        }
+    }
+    return (api_status);
+}
+
+
+optiga_lib_status_t ifx_i2c_transceive(ifx_i2c_context_t * p_ctx,
+                                       const uint8_t * p_tx_data,
+                                       uint16_t tx_data_length,
+                                       uint8_t * p_rx_buffer,
+                                       uint16_t * p_rx_buffer_len)
+{
+    optiga_lib_status_t api_status = (int32_t)IFX_I2C_STACK_ERROR;
+    // Proceed, if not busy and in idle state
+    if ((IFX_I2C_STATE_IDLE == p_ctx->state) && (IFX_I2C_STATUS_BUSY != p_ctx->status))
+    {
+        p_ctx->p_upper_layer_rx_buffer = p_rx_buffer;
+        p_ctx->p_upper_layer_rx_buffer_len = p_rx_buffer_len;
+#ifndef OPTIGA_COMMS_SHIELDED_CONNECTION
+        api_status = ifx_i2c_tl_transceive(p_ctx,
+                                           (uint8_t * )p_tx_data,
+                                           (tx_data_length),
+                                           (uint8_t * )p_rx_buffer,
+                                           p_rx_buffer_len);
+        if (IFX_I2C_STACK_SUCCESS == api_status)
+        {
+            p_ctx->status = IFX_I2C_STATUS_BUSY;
+        }
+#else
+        api_status = ifx_i2c_prl_transceive(p_ctx,
+                                         (uint8_t * )p_tx_data,
+                                         tx_data_length,
+                                         (uint8_t * )p_rx_buffer,
+                                         p_rx_buffer_len);
+#endif
+        if ((IFX_I2C_STACK_SUCCESS == api_status) && (IFX_I2C_STACK_SUCCESS == p_ctx->close_state))
+        {
+            p_ctx->status = IFX_I2C_STATUS_BUSY;
+        }
+    }
+    return (api_status);
+}
+
+
+optiga_lib_status_t ifx_i2c_close(ifx_i2c_context_t * p_ctx)
+{
+    optiga_lib_status_t api_status = (int32_t)IFX_I2C_STACK_ERROR;
+    // Proceed, if not busy and in idle state
+    if (IFX_I2C_STATUS_BUSY != p_ctx->status)
+    {
+        api_status = IFX_I2C_STACK_SUCCESS;
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        p_ctx->close_state = IFX_I2C_STACK_ERROR;
+        p_ctx->state = IFX_I2C_STATE_UNINIT;
+        //lint --e{838} suppress "Previous value of api_status is needed for scenario when shielded connection is disabled"
+        api_status = ifx_i2c_prl_close(p_ctx, ifx_i2c_prl_close_event_handler);
+        if (IFX_I2C_STACK_ERROR == api_status)
+        {
+            //lint --e{534} suppress "Error handling is not required so return value is not checked"
+            pal_i2c_deinit(p_ctx->p_pal_i2c_ctx);
+            // Also power off the device
+            pal_gpio_set_low(p_ctx->p_slave_vdd_pin);
+            pal_gpio_set_low(p_ctx->p_slave_reset_pin);
+            p_ctx->status = IFX_I2C_STATUS_NOT_BUSY;
+        }
+#else
+        ifx_i2c_tl_event_handler(p_ctx, IFX_I2C_STACK_SUCCESS, NULL, 0);
+        //lint --e{534} suppress "Error handling is not required so return value is not checked"
+        // Close I2C master
+        pal_i2c_deinit(p_ctx->p_pal_i2c_ctx);
+        // Also power off the device
+        pal_gpio_set_low(p_ctx->p_slave_vdd_pin);
+        pal_gpio_set_low(p_ctx->p_slave_reset_pin);
+        p_ctx->state = IFX_I2C_STATE_UNINIT;
+        p_ctx->status = IFX_I2C_STATUS_NOT_BUSY;
+#endif
+
+    }
+    return (api_status);
+}
+
+
+optiga_lib_status_t ifx_i2c_set_slave_address(ifx_i2c_context_t * p_ctx,
+                                              uint8_t slave_address,
+                                              uint8_t persistent)
+{
+    optiga_lib_status_t api_status = (int32_t)IFX_I2C_STACK_ERROR;
+
+    if ((IFX_I2C_STATE_IDLE == p_ctx->state))
+    {
+        p_ctx->p_pal_i2c_ctx->p_upper_layer_ctx = p_ctx;
+
+        api_status = ifx_i2c_pl_write_slave_address(p_ctx, slave_address, persistent);
+    }
+
+    return (api_status);
+}
+
+/// @cond hidden
+//lint --e{715} suppress "The arguments p_data and data_len is not used in this function 
+//                        but as per the function signature those 2 parameter should be passed"
+void ifx_i2c_tl_event_handler(ifx_i2c_context_t * p_ctx,
+                              optiga_lib_status_t event,
+                              const uint8_t * p_data,
+                              uint16_t data_len)
+{
+    // If there is no upper layer handler, don't do anything and return
+    if (NULL != p_ctx->upper_layer_event_handler)
+    {
+        p_ctx->upper_layer_event_handler(p_ctx->p_upper_layer_ctx, event);
+    }
+    p_ctx->close_state = event;
+    p_ctx->status = IFX_I2C_STATUS_NOT_BUSY;
+    switch (p_ctx->state)
+    {
+        case IFX_I2C_STATE_UNINIT:
+        {
+            if (IFX_I2C_STACK_SUCCESS == event)
+            {
+                p_ctx->state = IFX_I2C_STATE_IDLE;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+}
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+/// @cond hidden
+//lint --e{715} suppress "The arguments p_data and data_len is not used in this function 
+//                        but as per the function signature those 2 parameter should be passed"
+_STATIC_H void ifx_i2c_prl_close_event_handler(ifx_i2c_context_t * p_ctx,
+                                               optiga_lib_status_t event,
+                                               const uint8_t * p_data,
+                                               uint16_t data_len)
+{
+    p_ctx->status = IFX_I2C_STATUS_NOT_BUSY;
+    switch (p_ctx->state)
+    {
+        case IFX_I2C_STATE_UNINIT:
+        {
+            //lint --e{534} suppress "Error handling is not required so return value is not checked"
+            pal_i2c_deinit(p_ctx->p_pal_i2c_ctx);
+            // Also power off the device
+            pal_gpio_set_low(p_ctx->p_slave_vdd_pin);
+            pal_gpio_set_low(p_ctx->p_slave_reset_pin);
+            break;
+        }
+        default:
+            break;
+    }
+    // If there is no upper layer handler, don't do anything and return
+    if (NULL != p_ctx->upper_layer_event_handler)
+    {
+        p_ctx->upper_layer_event_handler(p_ctx->p_upper_layer_ctx, event);
+    }
+}
+#endif
+_STATIC_H optiga_lib_status_t ifx_i2c_init(ifx_i2c_context_t * p_ifx_i2c_context)
+{
+    optiga_lib_status_t api_status = IFX_I2C_STACK_ERROR;
+
+    if (((uint8_t)IFX_I2C_WARM_RESET == p_ifx_i2c_context->reset_type) ||
+        ((uint8_t)IFX_I2C_COLD_RESET == p_ifx_i2c_context->reset_type))
+    {
+        switch (p_ifx_i2c_context->reset_state)
+        {
+            case IFX_I2C_STATE_RESET_PIN_LOW:
+            {
+                // Setting the Vdd & Reset pin to low
+                if ((uint8_t)IFX_I2C_COLD_RESET == p_ifx_i2c_context->reset_type)
+                {
+                    pal_gpio_set_low(p_ifx_i2c_context->p_slave_vdd_pin);
+                }
+                pal_gpio_set_low(p_ifx_i2c_context->p_slave_reset_pin);
+                p_ifx_i2c_context->reset_state = IFX_I2C_STATE_RESET_PIN_HIGH;
+                pal_os_event_register_callback_oneshot(p_ifx_i2c_context->pal_os_event_ctx,
+                                                       (register_callback)ifx_i2c_init,
+                                                       (void * )p_ifx_i2c_context,
+                                                       RESET_LOW_TIME_MSEC);
+                api_status = IFX_I2C_STACK_SUCCESS;
+                break;
+            }
+            case IFX_I2C_STATE_RESET_PIN_HIGH:
+            {
+                // Setting the Vdd & Reset pin to high
+                if ((uint8_t)IFX_I2C_COLD_RESET == p_ifx_i2c_context->reset_type)
+                {
+                    pal_gpio_set_high(p_ifx_i2c_context->p_slave_vdd_pin);
+                }
+                pal_gpio_set_high(p_ifx_i2c_context->p_slave_reset_pin);
+                p_ifx_i2c_context->reset_state = IFX_I2C_STATE_RESET_INIT;
+                pal_os_event_register_callback_oneshot(p_ifx_i2c_context->pal_os_event_ctx,
+                                                       (register_callback)ifx_i2c_init,
+                                                       (void * )p_ifx_i2c_context,
+                                                       STARTUP_TIME_MSEC);
+                api_status = IFX_I2C_STACK_SUCCESS;
+                break;
+            }
+            case IFX_I2C_STATE_RESET_INIT:
+            {
+                //Frequency and frame size negotiation
+#ifndef OPTIGA_COMMS_SHIELDED_CONNECTION
+                api_status = ifx_i2c_tl_init(p_ifx_i2c_context, ifx_i2c_tl_event_handler);
+#else
+                api_status = ifx_i2c_prl_init(p_ifx_i2c_context, ifx_i2c_tl_event_handler);
+#endif
+                break;
+            }
+            default:
+                break;
+        }
+    }
+    //soft reset
+    else
+    {
+        p_ifx_i2c_context->pl.request_soft_reset = (uint8_t)TRUE;    //Soft reset
+#ifndef OPTIGA_COMMS_SHIELDED_CONNECTION
+        api_status = ifx_i2c_tl_init(p_ifx_i2c_context, ifx_i2c_tl_event_handler);
+#else
+        api_status = ifx_i2c_prl_init(p_ifx_i2c_context, ifx_i2c_tl_event_handler);
+#endif
+    }
+
+    return (api_status);
+}
+/// @endcond
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_config.c b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_config.c
new file mode 100644
index 000000000..8d8c9ea06
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_config.c
@@ -0,0 +1,114 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_config.c
+*
+* \brief   This file provides the ifx i2c platform specific context configurations.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+// Protocol Stack Includes
+#include "optiga/pal/pal_ifx_i2c_config.h"
+#include "optiga/ifx_i2c/ifx_i2c_config.h"
+
+#if defined OPTIGA_COMMS_SHIELDED_CONNECTION    
+/** @brief This is Data Store context. Only one context is supported per slave.
+ *
+ * - The following parameters in #ifx_i2c_datastore_config_t must be initialized with appropriate values <br>
+ *   - <b>protocol_version</b> : Protocol version supported for secure communication.
+ *   - <b>datastore_shared_secret_id</b> : ID to read and write the shared secret.
+ *   - <b>datastore_shared_secret_id</b> : ID to read and write the shielded connection context data.<br>
+ *   - <b>shared_secret_length</b> : Max supported shared secret length.
+ */
+ 
+ifx_i2c_datastore_config_t ifx_i2c_datastore_config =
+{
+    /// Protocol version
+    PROTOCOL_VERSION_PRE_SHARED_SECRET,
+    /// Platform binding shared secret host Pal datastore ID
+    OPTIGA_PLATFORM_BINDING_SHARED_SECRET_ID,
+    /// Manage context Pal datastore ID
+    OPTIGA_COMMS_MANAGE_CONTEXT_ID,
+    /// Max shared secret length
+    OPTIGA_SHARED_SECRET_MAX_LENGTH,
+};
+#endif
+/** @brief This is IFX I2C context. Only one context is supported per slave.
+ *
+ * - The following parameters in #ifx_i2c_context_t must be initialized with appropriate values <br>
+ *   - <b>slave address</b> : Address of I2C slave
+ *   - <b>frame_size</b> : Frame size in bytes. Minimum supported value is 16 bytes.<br> 
+ *              - It is recommended not to use a value greater than the slave's frame size.
+ *              - The user specified frame size is written to I2C slave's frame size register.
+ *                The frame size register is read back from I2C slave.
+ *                This frame value is used by the ifx-i2c protocol even if it is not equal to the user specified value.
+ *
+ *   - <b>frequency</b> : Frequency/speed of I2C master in KHz.
+ *              - This must be lowest of the maximum frequency supported by the devices (master/slave) connected on the 
+ *                bus.
+ *              - Initial negotiation starts with a frequency of 100KHz.
+ *              - If the user specified frequency is more than 400 KHz, the I2C slave is configured to operate in 
+ *                "Fm+" mode, otherwise the I2C slave is configured for "SM & Fm" mode. <br>
+ *              - If the user specified frequency negotiation fails, the I2C master frequency remains at 
+ *                100KHz<br>
+ * 
+ *   - <b>upper_layer_event_handler</b> : Upper layer event handler. This is invoked when #ifx_i2c_open() is 
+ *                                        asynchronously completed.
+ *   - <b>upper_layer_ctx</b> : Context of upper layer.
+ *   - <b>p_slave_vdd_pin</b> : GPIO pin for VDD. If not set, cold reset is not done. 
+ *   - <b>p_slave_reset_pin</b> : GPIO pin for Reset. If not set, warm reset is not done.
+ *   - <b>ifx_i2c_datastore_config</b> : Data store configuration instance
+ * - The other fields must be initialized by the user of the structure.
+ */
+//lint --e{785} suppress "Only required fields are initialized by default, the rest are handled by user of this structure"
+ifx_i2c_context_t ifx_i2c_context_0 =
+{
+    /// Slave address
+    IFX_I2C_BASE_ADDR,
+    /// i2c-master frequency
+    400,
+    /// IFX-I2C frame size
+    IFX_I2C_FRAME_SIZE,
+    /// Vdd pin
+    &optiga_vdd_0,
+    /// Reset pin
+    &optiga_reset_0,
+    /// optiga pal i2c context
+    &optiga_pal_i2c_context_0,
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION            
+    /// Data store context
+    &ifx_i2c_datastore_config
+#endif    
+};
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_data_link_layer.c b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_data_link_layer.c
new file mode 100644
index 000000000..9056d547d
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_data_link_layer.c
@@ -0,0 +1,690 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_data_link_layer.c
+*
+* \brief   This file implements the APIs for data link layer of the Infineon I2C Protocol Stack library.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+#include "optiga/ifx_i2c/ifx_i2c_data_link_layer.h"
+#include "optiga/ifx_i2c/ifx_i2c_physical_layer.h"
+
+/// @cond hidden
+
+// Data Link layer internal states
+#define DL_STATE_UNINIT                 (0x00)
+#define DL_STATE_IDLE                   (0x01)
+#define DL_STATE_TX                     (0x02)
+#define DL_STATE_RX                     (0x03)
+#define DL_STATE_ACK                    (0x04)
+#define DL_STATE_RESEND                 (0x05)
+#define DL_STATE_NACK                   (0x06)
+#define DL_STATE_ERROR                  (0x08)
+#define DL_STATE_DISCARD                (0x09)
+#define DL_STATE_RX_DF                  (0x0A)
+#define DL_STATE_RX_CF                  (0x0B)
+
+// Data Link Layer Frame Control Constants
+#define DL_FCTR_FTYPE_MASK              (0x80)
+#define DL_FCTR_FTYPE_OFFSET            (7U)
+#define DL_FCTR_VALUE_CONTROL_FRAME     (0x01)
+
+#define DL_FCTR_SEQCTR_MASK             (0x60)
+#define DL_FCTR_SEQCTR_OFFSET           (5U)
+#define DL_FCTR_SEQCTR_VALUE_ACK        (0x00)
+#define DL_FCTR_SEQCTR_VALUE_NACK       (0x01)
+#define DL_FCTR_SEQCTR_VALUE_RESYNC     (0x02)
+#define DL_FCTR_SEQCTR_VALUE_RFU        (0x03)
+
+#define DL_FCTR_FRNR_MASK               (0x0C)
+#define DL_FCTR_FRNR_OFFSET             (2U)
+
+#define DL_FCTR_ACKNR_MASK              (0x03)
+#define DL_FCTR_ACKNR_OFFSET            (0U)
+
+// Data Link Layer frame counter max value
+#define DL_MAX_FRAME_NUM                (0x03)
+
+// Data link layer length
+#define DL_CONTROL_FRAME_LENGTH         (5U)
+
+// Seconds to milliseconds
+#define DL_SEC_TO_MSECS                 (1000U)
+
+#if defined (OPTIGA_LIB_ENABLE_LOGGING) && defined (OPTIGA_LIB_ENABLE_COMMS_LOGGING)
+
+// Logs the message provided from OPTIGA Comms layer
+#define OPTIGA_COMMS_LOG_MESSAGE(msg) \
+{\
+    optiga_lib_print_message(msg,OPTIGA_COMMUNICATION_LAYER,OPTIGA_COMMUNICATION_LAYER_COLOR);\
+}
+
+// Logs the status info provided from OPTIGA Comms layer
+//lint --e{750} suppress "The unused OPTIGA_COMMS_LOG_STATUS macro is kept for future enhancements"
+#define OPTIGA_COMMS_LOG_STATUS(return_value)                                 \
+{                                                       \
+    if (OPTIGA_LIB_SUCCESS != return_value)                                 \
+    {                                                     \
+        optiga_lib_print_status(OPTIGA_COMMUNICATION_LAYER,OPTIGA_ERROR_COLOR,return_value);        \
+    }                                                     \
+    else                                                  \
+    {                                                     \
+        optiga_lib_print_status(OPTIGA_COMMUNICATION_LAYER,OPTIGA_COMMUNICATION_LAYER_COLOR,return_value);  \
+    }                                                     \
+}
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+
+// Logs the transmitted data to OPTIGA from IFXI2C layer in hexadecimal format
+#define OPTIGA_IFXI2C_LOG_TRANSMIT_HEX_DATA(array,array_len,p_ifx_i2c_ctx)              \
+{                                                 \
+  if (0 != frame_len)                                       \
+  {                                               \
+    if (((((ifx_i2c_context_t * )p_ifx_i2c_ctx)->protection_level & 0x0F) == 0x01) ||       \
+      ((((ifx_i2c_context_t * )p_ifx_i2c_ctx)->protection_level & 0x0F) == 0x03))       \
+      {                                             \
+        optiga_lib_print_array_hex_format(array,array_len,OPTIGA_PROTECTED_DATA_COLOR);  \
+      }                                             \
+      else                                          \
+      {                                             \
+        optiga_lib_print_array_hex_format(array,array_len,OPTIGA_UNPROTECTED_DATA_COLOR);\
+      }                                             \
+  }                                               \
+}
+
+// Logs the received data from OPTIGA in hexadecimal format
+#define OPTIGA_IFXI2C_LOG_RECEIVE_HEX_DATA(array,array_len,p_ifx_i2c_ctx) \
+{\
+    if (((((ifx_i2c_context_t * )p_ifx_i2c_ctx)->protection_level & 0x0F) == 0x02) || \
+        ((((ifx_i2c_context_t * )p_ifx_i2c_ctx)->protection_level & 0x0F) == 0x03)) \
+        { \
+            optiga_lib_print_array_hex_format(array,array_len,OPTIGA_PROTECTED_DATA_COLOR); \
+        } \
+        else \
+        { \
+            optiga_lib_print_array_hex_format(array,array_len,OPTIGA_UNPROTECTED_DATA_COLOR); \
+        } \
+}
+#else
+
+// Logs the transmitted data to OPTIGA from IFXI2C layer in hexadecimal format
+#define OPTIGA_IFXI2C_LOG_TRANSMIT_HEX_DATA(array,array_len,p_ifx_i2c_ctx) \
+{\
+    OPTIGA_COMMS_LOG_MESSAGE("");\
+    optiga_lib_print_array_hex_format(array,array_len,OPTIGA_UNPROTECTED_DATA_COLOR);\
+}
+
+// Logs the received data from OPTIGA in hexadecimal format
+#define OPTIGA_IFXI2C_LOG_RECEIVE_HEX_DATA(array,array_len,p_ifx_i2c_ctx) \
+{\
+    OPTIGA_COMMS_LOG_MESSAGE("");\
+    optiga_lib_print_array_hex_format(array,array_len,OPTIGA_UNPROTECTED_DATA_COLOR);\
+}
+
+#endif
+
+#else
+
+#define OPTIGA_IFXI2C_LOG_TRANSMIT_HEX_DATA(array,array_len,p_ifx_i2c_ctx) {}
+#define OPTIGA_IFXI2C_LOG_RECEIVE_HEX_DATA(array,array_len,p_ifx_i2c_ctx) {}
+#define OPTIGA_COMMS_LOG_MESSAGE(msg) {}
+//lint --e{750} suppress "The unused OPTIGA_COMMS_LOG_STATUS macro is kept for future enhancements"
+#define OPTIGA_COMMS_LOG_STATUS(return_value) {}
+#endif
+
+// Setup debug log statements
+#if IFX_I2C_LOG_DL == 1
+#define LOG_DL IFX_I2C_LOG
+#else
+#define LOG_DL(...) //printf(__VA_ARGS__)
+#endif
+
+/// Helper function to calculate CRC of a byte
+_STATIC_H uint16_t ifx_i2c_dl_calc_crc_byte(uint16_t seed,
+                                                       uint8_t byte);
+/// Helper function to calculate CRC of a frame
+_STATIC_H uint16_t ifx_i2c_dl_calc_crc(const uint8_t * p_data,
+                                                  uint16_t data_len);
+/// Internal function to send frame
+_STATIC_H optiga_lib_status_t ifx_i2c_dl_send_frame_internal(ifx_i2c_context_t * p_ctx,
+                                                             uint16_t frame_len,
+                                                             uint8_t seqctr_value,
+                                                             uint8_t resend);
+/// Helper function to send resync
+_STATIC_H optiga_lib_status_t ifx_i2c_dl_resync(ifx_i2c_context_t * p_ctx);
+/// Helper function to resend frame
+_STATIC_H void ifx_i2c_dl_resend_frame(ifx_i2c_context_t * p_ctx,
+                                       uint8_t seqctr_value);
+/// Data Link Layer state machine
+_STATIC_H void ifx_i2c_pl_event_handler(ifx_i2c_context_t * p_ctx,
+                                        optiga_lib_status_t event,
+                                        const uint8_t * p_data,
+                                        uint16_t data_len);
+
+/// @endcond
+
+optiga_lib_status_t ifx_i2c_dl_init(ifx_i2c_context_t * p_ctx, ifx_i2c_event_handler_t handler)
+{
+    LOG_DL("[IFX-DL]: Init\n");
+
+    p_ctx->dl.state = DL_STATE_UNINIT;
+    // Initialize Physical Layer (and register event handler)
+    if (IFX_I2C_STACK_SUCCESS != ifx_i2c_pl_init(p_ctx, ifx_i2c_pl_event_handler))
+    {
+        return (IFX_I2C_STACK_ERROR);
+    }
+
+    // Initialize internal variables
+    p_ctx->dl.upper_layer_event_handler = handler;
+    p_ctx->dl.state = DL_STATE_IDLE;
+    p_ctx->dl.tx_seq_nr = DL_MAX_FRAME_NUM;
+    p_ctx->dl.rx_seq_nr = DL_MAX_FRAME_NUM;
+    p_ctx->dl.resynced = 0;
+    p_ctx->dl.error = 0;
+    p_ctx->dl.p_tx_frame_buffer = p_ctx->tx_frame_buffer;
+    p_ctx->dl.p_rx_frame_buffer = p_ctx->rx_frame_buffer;
+
+    return IFX_I2C_STACK_SUCCESS;
+}
+
+optiga_lib_status_t ifx_i2c_dl_send_frame(ifx_i2c_context_t * p_ctx, uint16_t frame_len)
+{
+    LOG_DL("[IFX-DL]: Start TX Frame\n");
+    // State must be idle and payload available
+    if (p_ctx->dl.state != DL_STATE_IDLE || (0 == frame_len))
+    {
+        return (IFX_I2C_STACK_ERROR);
+    }
+
+    p_ctx->dl.state = DL_STATE_TX;
+    p_ctx->dl.retransmit_counter = 0;
+    p_ctx->dl.action_rx_only = 0;
+    p_ctx->dl.tx_buffer_size = frame_len;
+    p_ctx->dl.data_poll_timeout = PL_TRANS_TIMEOUT_MS;
+
+    return (ifx_i2c_dl_send_frame_internal(p_ctx, frame_len, DL_FCTR_SEQCTR_VALUE_ACK, 0));
+}
+
+optiga_lib_status_t ifx_i2c_dl_receive_frame(ifx_i2c_context_t * p_ctx)
+{
+    LOG_DL("[IFX-DL]: Start RX Frame\n");
+
+    if (DL_STATE_IDLE != p_ctx->dl.state)
+    {
+        return (IFX_I2C_STACK_ERROR);
+    }
+
+    // Set internal state
+    p_ctx->dl.state = DL_STATE_RX;
+    p_ctx->dl.retransmit_counter = 0;
+    p_ctx->dl.action_rx_only = 1;
+    p_ctx->dl.frame_start_time = pal_os_timer_get_time_in_milliseconds();
+    p_ctx->dl.data_poll_timeout = TL_MAX_EXIT_TIMEOUT * DL_SEC_TO_MSECS;
+
+    return (ifx_i2c_pl_receive_frame(p_ctx));
+}
+
+_STATIC_H uint16_t ifx_i2c_dl_calc_crc_byte(uint16_t seed, uint8_t byte)
+{
+    uint16_t h1;
+    uint16_t h2;
+    uint16_t h3;
+    uint16_t h4;
+
+    h1 = (seed ^ byte) & 0xFF;
+    h2 = h1 & 0x0F;
+    h3 = ((uint16_t)(h2 << 4)) ^ h1;
+    h4 = h3 >> 4;
+
+    return ((uint16_t)((((uint16_t)((((uint16_t)(h3 << 1)) ^ h4) << 4)) ^ h2) << 3)) ^ h4 ^ (seed >> 8);
+}
+
+_STATIC_H uint16_t ifx_i2c_dl_calc_crc(const uint8_t * p_data, uint16_t data_len)
+{
+    uint16_t i;
+    uint16_t crc = 0;
+
+    for (i = 0; i < data_len; i++)
+    {
+        crc = ifx_i2c_dl_calc_crc_byte(crc, p_data[i]);
+    }
+
+    return (crc);
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_dl_send_frame_internal(ifx_i2c_context_t * p_ctx,
+                                                             uint16_t frame_len,
+                                                             uint8_t seqctr_value,
+                                                             uint8_t resend)
+{
+    uint16_t crc;
+    uint16_t ack_nr = p_ctx->dl.rx_seq_nr;
+    uint8_t * p_buffer;
+
+    LOG_DL("[IFX-DL]: TX Frame len %d\n", frame_len);
+    // In case of sending a NACK the next frame is referenced
+    if (DL_FCTR_SEQCTR_VALUE_NACK == seqctr_value)
+    {
+        ack_nr = (p_ctx->dl.rx_seq_nr + 1) & DL_MAX_FRAME_NUM;
+    }
+    p_buffer = p_ctx->dl.p_tx_frame_buffer;
+    if (DL_FCTR_SEQCTR_VALUE_RESYNC == seqctr_value)
+    {
+        ack_nr = 0;
+        // Use rx buffer to send resync
+        p_buffer = p_ctx->dl.p_rx_frame_buffer;
+    }
+    // Use tx buffer when discarding a frame and send nakc for later received frame
+    if ((DL_FCTR_SEQCTR_VALUE_ACK == seqctr_value) && (DL_STATE_DISCARD == p_ctx->dl.state))
+    {
+        p_buffer = p_ctx->dl.p_rx_frame_buffer;
+    }
+
+    // Set sequence control value (ACK or NACK) and referenced frame number
+    //lint --e{835} suppress "DL_FCTR_ACKNR_OFFSET macro is defined as 0x00 and is kept for future enhancements"
+    p_buffer[0] = (uint8_t)(ack_nr << DL_FCTR_ACKNR_OFFSET);
+    p_buffer[0] |= (uint8_t)(seqctr_value << DL_FCTR_SEQCTR_OFFSET);
+
+    if (0 != frame_len) // Data frame
+    {
+        // Increment and set frame transmit sequence number
+        if ((0 == resend) || (0 != p_ctx->dl.resynced))
+        {
+            p_ctx->dl.tx_seq_nr = (p_ctx->dl.tx_seq_nr + 1) & DL_MAX_FRAME_NUM;
+        }
+        p_buffer[0] |= (uint8_t)(p_ctx->dl.tx_seq_nr << DL_FCTR_FRNR_OFFSET);
+        // Reset resync received
+        p_ctx->dl.resynced = 0;
+        OPTIGA_COMMS_LOG_MESSAGE(">>>>");
+    }
+    else // Control frame
+    {
+        p_buffer[0] |= DL_FCTR_FTYPE_MASK;
+    }
+
+    // Set frame length
+    p_buffer[1] = (uint8_t)(frame_len >> 8);
+    p_buffer[2] = (uint8_t)frame_len;
+
+    // Calculate frame CRC
+    crc = ifx_i2c_dl_calc_crc(p_buffer, 3 + frame_len);
+    p_buffer[3 + frame_len] = (uint8_t) (crc >> 8);
+    p_buffer[4 + frame_len] = (uint8_t)crc;
+
+    // Transmit frame
+    OPTIGA_IFXI2C_LOG_TRANSMIT_HEX_DATA(p_buffer,DL_HEADER_SIZE + frame_len,p_ctx)
+    return (ifx_i2c_pl_send_frame(p_ctx, p_buffer, DL_HEADER_SIZE + frame_len));
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_dl_resync(ifx_i2c_context_t * p_ctx)
+{
+    optiga_lib_status_t api_status;
+    // Reset tx and rx counters
+    p_ctx->dl.tx_seq_nr = DL_MAX_FRAME_NUM;
+    p_ctx->dl.rx_seq_nr = DL_MAX_FRAME_NUM;
+    p_ctx->dl.resynced = 1;
+    LOG_DL("[IFX-DL]: Send Re-Sync Frame\n");
+    p_ctx->dl.state = DL_STATE_RESEND;
+    api_status = ifx_i2c_dl_send_frame_internal(p_ctx, 0, DL_FCTR_SEQCTR_VALUE_RESYNC, 0);
+    return (api_status);
+}
+
+_STATIC_H void ifx_i2c_dl_resend_frame(ifx_i2c_context_t * p_ctx, uint8_t seqctr_value)
+{
+    optiga_lib_status_t status;
+    // If exit timeout not violated
+    uint32_t current_time_stamp = pal_os_timer_get_time_in_milliseconds();
+    uint32_t time_stamp_diff = current_time_stamp - p_ctx->tl.api_start_time;
+
+    if (p_ctx->tl.api_start_time > current_time_stamp)
+    {
+        time_stamp_diff = (0xFFFFFFFF + (current_time_stamp - p_ctx->tl.api_start_time)) + 0x01;
+    }
+    if (time_stamp_diff < (TL_MAX_EXIT_TIMEOUT * DL_SEC_TO_MSECS))
+    {
+        if (DL_TRANS_REPEAT == p_ctx->dl.retransmit_counter)
+        {
+            LOG_DL("[IFX-DL]: Re-Sync counters\n");
+            p_ctx->dl.retransmit_counter = 0;
+            status = ifx_i2c_dl_resync(p_ctx);
+        }
+        else
+        {
+            LOG_DL("[IFX-DL]: Re-TX Frame\n");
+            p_ctx->dl.retransmit_counter++;
+            p_ctx->dl.state = DL_STATE_TX;
+            status = ifx_i2c_dl_send_frame_internal(p_ctx, p_ctx->dl.tx_buffer_size, seqctr_value, 1);
+        }
+        // Handle error in above case by sending NACK
+        if (IFX_I2C_STACK_SUCCESS != status)
+        {
+            p_ctx->dl.state  = DL_STATE_NACK;
+        }
+    }
+    else
+    {
+        p_ctx->dl.state = DL_STATE_ERROR;
+    }
+}
+
+_STATIC_H void ifx_i2c_pl_event_handler(ifx_i2c_context_t * p_ctx,
+                                        optiga_lib_status_t event,
+                                        const uint8_t * p_data,
+                                        uint16_t data_len)
+{
+    uint8_t fctr = 0;
+    uint8_t fr_nr = 0;
+    uint8_t ack_nr = 0;
+    uint8_t seqctr = 0;
+    uint8_t current_event;
+    uint8_t ftype = 0;
+    uint8_t continue_state_machine = TRUE;
+    uint16_t packet_len = 0;
+    uint16_t crc_received = 0;
+    uint16_t crc_calculated = 0;
+    LOG_DL("[IFX-DL]: #Enter DL Handler\n");
+    do
+    {
+        if ((IFX_I2C_FATAL_ERROR == event) && (DL_STATE_IDLE != p_ctx->dl.state))
+        {    // Exit in case of fatal error
+            LOG_DL("[IFX-DL]: Fatal error received\n");
+            p_ctx->dl.state = DL_STATE_ERROR;
+        }
+        switch (p_ctx->dl.state)
+        {
+            case DL_STATE_IDLE:
+            {
+                current_event = (event != IFX_I2C_STACK_SUCCESS) ? IFX_I2C_DL_EVENT_ERROR : IFX_I2C_DL_EVENT_TX_SUCCESS;
+                continue_state_machine = FALSE;
+                p_ctx->dl.upper_layer_event_handler(p_ctx,current_event, 0, 0);
+            }
+            break;
+            case DL_STATE_TX:
+            {
+                // If writing a frame failed retry sending
+                if (IFX_I2C_STACK_ERROR == event)
+                {
+                    p_ctx->dl.state = DL_STATE_RESEND;
+                    break;
+                }
+                LOG_DL("[IFX-DL]: Frame Sent\n");
+                // Transmission successful, start receiving frame
+                p_ctx->dl.frame_start_time = pal_os_timer_get_time_in_milliseconds();
+                p_ctx->dl.state = DL_STATE_RX;
+                if (0 != ifx_i2c_pl_receive_frame(p_ctx))
+                {
+                    p_ctx->dl.state  = DL_STATE_NACK;
+                }
+                else
+                {
+                    continue_state_machine = FALSE;
+                }
+            }
+            break;
+            case DL_STATE_RX:
+            {
+                if (IFX_I2C_STACK_ERROR == event)
+                {    // If no frame was received retry sending
+                    p_ctx->dl.state = DL_STATE_RESEND;
+                    break;
+                }
+                // Received frame from device, start analyzing
+                LOG_DL("[IFX-DL]: Received Frame of length %d\n",data_len);
+
+                if (data_len < DL_HEADER_SIZE)
+                {    // Received length is less than minimum size
+                    LOG_DL("[IFX-DL]: received data_len < DL_HEADER_SIZE\n");
+                    p_ctx->dl.state  = DL_STATE_NACK;
+                    break;
+                }
+                // Check transmit frame sequence number
+                fctr = p_data[0];
+                ftype = (fctr & DL_FCTR_FTYPE_MASK) >> DL_FCTR_FTYPE_OFFSET;
+                seqctr = (fctr & DL_FCTR_SEQCTR_MASK) >> DL_FCTR_SEQCTR_OFFSET;
+                //lint --e{835} suppress "DL_FCTR_ACKNR_OFFSET is defined as 0x00 and is kept for future enhancements"
+                ack_nr = (fctr & DL_FCTR_ACKNR_MASK) >> DL_FCTR_ACKNR_OFFSET;
+                fr_nr = (fctr & DL_FCTR_FRNR_MASK) >> DL_FCTR_FRNR_OFFSET;
+                packet_len = (p_data[1] << 8) | p_data[2];
+
+                // Check frame CRC value
+                crc_received = (p_data[data_len - 2] << 8) | p_data[data_len - 1];
+                crc_calculated = ifx_i2c_dl_calc_crc(p_data, data_len - 2);
+                p_ctx->dl.state = (ftype == DL_FCTR_VALUE_CONTROL_FRAME) ? DL_STATE_RX_CF : DL_STATE_RX_DF;
+            }
+            break;
+            case DL_STATE_RX_DF:
+            {
+                LOG_DL("[IFX-DL]: Data Frame Received\n");
+                if ((crc_received != crc_calculated) || (0 == packet_len) ||
+                    (data_len != (DL_HEADER_SIZE + packet_len)) || (DL_FCTR_SEQCTR_VALUE_RFU == seqctr) ||
+                    (DL_FCTR_SEQCTR_VALUE_RESYNC == seqctr))
+                {
+                    // CRC,Length of data frame is 0/ SEQCTR has RFU/Re-sync in Data frame
+                    LOG_DL("[IFX-DL]: NACK for CRC error,Data frame length is not correct,RFU in SEQCTR\n");
+                    p_ctx->dl.state  = DL_STATE_NACK;
+                    break;
+                }
+                if (fr_nr != ((p_ctx->dl.rx_seq_nr + 1) & DL_MAX_FRAME_NUM))
+                {
+                    LOG_DL("[IFX-DL]: Data frame number not expected\n");
+                    p_ctx->dl.state  = DL_STATE_DISCARD;
+                    continue_state_machine = FALSE;
+                    //lint --e{534} suppress "Error handling is not required so return value is not checked"
+                    ifx_i2c_dl_send_frame_internal(p_ctx, 0, DL_FCTR_SEQCTR_VALUE_ACK, 0);
+                    break;
+                }
+                if (ack_nr != p_ctx->dl.tx_seq_nr)
+                {
+                    // ack number error
+                    LOG_DL("[IFX-DL]: Error in ack number\n");
+                    //lint --e{534} suppress "Error handling is not required so return value is not checked"
+                    p_ctx->dl.state = DL_STATE_DISCARD;
+                    break;
+                }
+                if (DL_FCTR_SEQCTR_VALUE_NACK == seqctr)
+                {
+                    // NACK for transmitted frame
+                    LOG_DL("[IFX-DL]: NACK received in data frame\n");
+                    p_ctx->dl.state = DL_STATE_RESEND;
+                    break;
+                }
+                p_ctx->dl.rx_seq_nr = (p_ctx->dl.rx_seq_nr + 1) & DL_MAX_FRAME_NUM;
+                memcpy(p_ctx->dl.p_rx_frame_buffer, p_data, data_len);
+                p_ctx->dl.rx_buffer_size = data_len;
+
+                // Send control frame to acknowledge reception of this data frame
+                LOG_DL("[IFX-DL]: Read Data Frame -> Send ACK\n");
+                p_ctx->dl.retransmit_counter = 0;
+                p_ctx->dl.state = DL_STATE_ACK;
+                continue_state_machine = FALSE;
+
+                OPTIGA_COMMS_LOG_MESSAGE("<<<<");\
+                OPTIGA_IFXI2C_LOG_RECEIVE_HEX_DATA(p_data,data_len,p_ctx);
+                //lint --e{534} suppress "Error handling is not required so return value is not checked"
+                ifx_i2c_dl_send_frame_internal(p_ctx, 0, DL_FCTR_SEQCTR_VALUE_ACK, 0);
+            }
+            break;
+            case DL_STATE_RX_CF:
+            {
+                LOG_DL("[IFX-DL]: Control Frame Received\n");
+                // Except Re-Sync, Discard Control frame when in receiver mode
+                // Discard Re-Sync in transmission mode
+                //lint --e{514} suppress "Refer the above comment for the explaination of this check"
+                if ((p_ctx->dl.action_rx_only) ^ (DL_FCTR_SEQCTR_VALUE_RESYNC == seqctr))
+                {
+                    //If control frame already received for data frame, ignore any received control frame
+                    LOG_DL("[IFX-DL]: CF in receiver mode,Discard\n");
+                    p_ctx->dl.state = DL_STATE_DISCARD;
+                    break;
+                }
+                if (crc_received != crc_calculated)
+                {
+                    // Re-Transmit frame in case of CF CRC error
+                    LOG_DL("[IFX-DL]: Retransmit frame for CF CRC error\n");
+                    p_ctx->dl.state = DL_STATE_RESEND;
+                    break;
+                }
+                if ((data_len > DL_CONTROL_FRAME_LENGTH) || (0 != packet_len))
+                {
+                    // Control frame is more than 5/Control frame with non-zero FRNR/packet len is not 0
+                    LOG_DL("[IFX-DL]: Errors in control frame\n");
+                    p_ctx->dl.state = DL_STATE_DISCARD;
+                    break;
+                }
+                if (DL_FCTR_SEQCTR_VALUE_RESYNC == seqctr)
+                {    // Re-sync received
+                    LOG_DL("[IFX-DL]: Re-Sync received\n");
+                    p_ctx->dl.state = DL_STATE_DISCARD;
+                    p_ctx->dl.resynced = 1;
+                    p_ctx->dl.tx_seq_nr = DL_MAX_FRAME_NUM;
+                    p_ctx->dl.rx_seq_nr = DL_MAX_FRAME_NUM;
+                    break;
+                }
+                if ((0 != fr_nr) || (DL_FCTR_SEQCTR_VALUE_RFU == seqctr) || (ack_nr != p_ctx->dl.tx_seq_nr))
+                {
+                    // Control frame with non-zero FRNR/ ACK not received/ ack number != tx number
+                    LOG_DL("[IFX-DL]: Errors in control frame\n");
+                    p_ctx->dl.state = DL_STATE_DISCARD;
+                    break;
+                }
+                if (DL_FCTR_SEQCTR_VALUE_NACK == seqctr)
+                {
+                    // NACK for transmitted frame
+                    LOG_DL("[IFX-DL]: NACK received\n");
+                    p_ctx->dl.state = DL_STATE_RESEND;
+                    break;
+                }
+
+                LOG_DL("[IFX-DL]: ACK received\n");
+                // Report frame reception to upper layer and go in idle state
+                p_ctx->dl.state = DL_STATE_IDLE;
+                continue_state_machine = FALSE;
+                p_ctx->dl.upper_layer_event_handler(p_ctx, IFX_I2C_DL_EVENT_TX_SUCCESS, 0, 0);
+            }
+            break;
+            case DL_STATE_DISCARD:
+            {
+                LOG_DL("[IFX-DL]: Discard frame\n");
+                p_ctx->dl.state = DL_STATE_RX;
+                continue_state_machine = FALSE;
+                //lint --e{534} suppress "Error handling is not required so return value is not checked"
+                ifx_i2c_pl_receive_frame(p_ctx);
+            }
+            break;
+            case DL_STATE_ACK:
+            {
+                LOG_DL("[IFX-DL]: ACK sent\n");
+                if (IFX_I2C_STACK_ERROR == event)
+                {
+                    // If writing the ACK frame failed, Re-Send
+                    LOG_DL("[IFX-DL]: Physical Layer error -> Resend ACK\n");
+                    p_ctx->dl.state = DL_STATE_RESEND;
+                    break;
+                }
+                // Control frame successful transmitted
+                p_ctx->dl.state = DL_STATE_IDLE;
+                continue_state_machine = FALSE;
+                if (0 != p_ctx->dl.action_rx_only)
+                {
+                    p_ctx->dl.upper_layer_event_handler(p_ctx,
+                                                        IFX_I2C_DL_EVENT_RX_SUCCESS,
+                                                        p_ctx->dl.p_rx_frame_buffer + 3,
+                                                        p_ctx->dl.rx_buffer_size - DL_HEADER_SIZE);
+                }
+                else
+                {
+                    p_ctx->dl.upper_layer_event_handler(p_ctx,
+                                                        IFX_I2C_DL_EVENT_TX_SUCCESS | IFX_I2C_DL_EVENT_RX_SUCCESS,
+                                                        p_ctx->dl.p_rx_frame_buffer + 3,
+                                                        p_ctx->dl.rx_buffer_size - DL_HEADER_SIZE);
+                }
+            }
+            break;
+            case DL_STATE_NACK:
+            {
+                // Sending NACK
+                LOG_DL("[IFX-DL]: Sending NACK\n");
+                p_ctx->dl.state = DL_STATE_TX;
+                continue_state_machine = FALSE;
+                //lint --e{534} suppress "Error handling is not required so return value is not checked"
+                ifx_i2c_dl_send_frame_internal(p_ctx, 0, DL_FCTR_SEQCTR_VALUE_NACK, 0);
+            }
+            break;
+            case DL_STATE_RESEND:
+            {
+                //Resend frame
+                ifx_i2c_dl_resend_frame(p_ctx, DL_FCTR_SEQCTR_VALUE_ACK);
+                if (DL_STATE_ERROR != p_ctx->dl.state)
+                {
+                    continue_state_machine = FALSE;
+                }
+            }
+            break;
+            case DL_STATE_ERROR:
+            {
+                if (0 == p_ctx->dl.resynced)
+                {
+                    p_ctx->dl.error = 1;
+                }
+                if (0 == p_ctx->dl.error)
+                {
+                    LOG_DL("[IFX-DL]: Exit error after fatal error\n");
+                    //After sending resync, inform upper layer
+                    p_ctx->dl.state = DL_STATE_IDLE;
+                    p_ctx->dl.upper_layer_event_handler(p_ctx, IFX_I2C_DL_EVENT_ERROR, 0, 0);
+                }
+                else
+                {
+                    LOG_DL("[IFX-DL]: Sending re-sync after fatal error\n");
+                    // Send re-sync to slave on error
+                    //lint --e{534} suppress "As this is last step, no effect of checking return code"
+                    ifx_i2c_dl_resync(p_ctx);
+                    p_ctx->dl.state = DL_STATE_ERROR;
+                    p_ctx->dl.error = 0;
+                }
+                continue_state_machine = FALSE;
+            }
+            break;
+            default:
+                LOG_DL("[IFX-DL]: Default condition occurred. Exiting with error\n");
+                p_ctx->dl.state = DL_STATE_IDLE;
+                p_ctx->dl.upper_layer_event_handler(p_ctx, IFX_I2C_DL_EVENT_ERROR, 0, 0);
+                continue_state_machine = FALSE;
+                break;
+        }
+    } while (TRUE == continue_state_machine);
+    LOG_DL("[IFX-DL]: #Exiting DL Handler\n");
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c
new file mode 100644
index 000000000..49954990f
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c
@@ -0,0 +1,799 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_physical_layer.c
+*
+* \brief   This file implements the APIs for physical layer of the Infineon I2C Protocol Stack library.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+#include "optiga/ifx_i2c/ifx_i2c_physical_layer.h"
+#include "optiga/pal/pal_os_event.h"
+
+/// @cond hidden
+
+// Physical Layer Register addresses
+#define PL_REG_DATA                     (0x80)
+#define PL_REG_DATA_REG_LEN             (0x81)
+#define PL_REG_I2C_STATE                (0x82)
+#define PL_REG_BASE_ADDR                (0x83)
+#define PL_REG_MAX_SCL_FREQU            (0x84)
+#define PL_REG_SOFT_RESET               (0x88)
+#define PL_REG_I2C_MODE                 (0x89)
+
+// Physical Layer Register lengths
+#define PL_REG_LEN_I2C_STATE            (4U)
+#define PL_REG_LEN_MAX_SCL_FREQU        (4U)
+#define PL_REG_LEN_I2C_MODE             (2U)
+#define PL_REG_LEN_DATA_REG_LEN         (2U)
+#define PL_REG_LEN_SOFT_RESET           (2U)
+#define PL_REG_LEN_BASE_ADDR            (2U)
+
+// Physical Layer State Register masks
+#define PL_REG_I2C_STATE_RESPONSE_READY (0x40)
+#define PL_REG_I2C_STATE_SOFT_RESET     (0x08)
+
+// Physical Layer low level interface constants
+#define PL_ACTION_READ_REGISTER         (0x01)
+#define PL_ACTION_WRITE_REGISTER        (0x02)
+#define PL_I2C_CMD_WRITE                (0x01)
+#define PL_I2C_CMD_READ                 (0x02)
+
+// Physical Layer high level interface constants
+#define PL_ACTION_WRITE_FRAME           (0x01)
+#define PL_ACTION_READ_FRAME            (0x02)
+#define PL_STATE_UNINIT                 (0x00)
+#define PL_STATE_INIT                   (0x01)
+#define PL_STATE_READY                  (0x02)
+#define PL_STATE_DATA_AVAILABLE         (0x03)
+#define PL_STATE_RXTX                   (0x04)
+#define PL_STATE_SOFT_RESET             (0x05)
+
+//Physical Layer negotiation constants
+#define PL_INIT_SET_DATA_REG_LEN        (0x11)
+#define PL_INIT_GET_DATA_REG_LEN        (0x22)
+#define PL_INIT_GET_FREQ_REG            (0x33)
+#define PL_INIT_SET_FREQ_REG            (0x44)
+#define PL_INIT_READ_FREQ               (0x55)
+#define PL_INIT_VERIFY_FREQ             (0x66)
+#define PL_INIT_AGREE_FREQ              (0x77)
+#define PL_INIT_VERIFY_DATA_REG         (0x88)
+#define PL_INIT_GET_STATUS_REG          (0x99)
+#define PL_INIT_DONE                    (0xAA)
+#define PL_INIT_SET_FREQ_DEFAULT        (0xBB)
+
+//Physical layer soft reset states
+#define PL_RESET_INIT                   (0xA1)
+#define PL_RESET_WRITE                  (0xA2)
+#define PL_RESET_STARTUP                (0xA3)
+
+#define PL_REG_I2C_MODE_PERSISTANT      (0x80)
+#define PL_REG_I2C_MODE_SM_FM           (0x03)
+#define PL_REG_I2C_MODE_FM_PLUS         (0x04)
+#define PL_SM_FM_MAX_FREQUENCY          (0x190)
+#define PL_DEFAULT_FREQUENCY            (0x64)
+#define PL_REG_BASE_ADDR_PERSISTANT     (0x80)
+#define PL_REG_BASE_ADDR_VOLATILE       (0x00)
+
+// Physical Layer Base Address Register mask
+#define PL_REG_I2C_BASE_ADDRESS_MASK    (0x7F)
+
+// Setup debug log statements
+#if IFX_I2C_LOG_PL == 1
+#define LOG_PL IFX_I2C_LOG
+#else
+#define LOG_PL(...) //printf(__VA_ARGS__)
+#endif
+
+_STATIC_H optiga_lib_status_t g_pal_event_status;
+
+
+/// Physical Layer low level interface function
+_STATIC_H void ifx_i2c_pl_read_register(ifx_i2c_context_t * p_ctx, uint8_t reg_addr, uint16_t reg_len);
+/// Physical Layer low level interface function
+_STATIC_H void ifx_i2c_pl_write_register(ifx_i2c_context_t * p_ctx,
+                                         uint8_t reg_addr,
+                                         uint16_t reg_len,
+                                         const uint8_t * p_content);
+/// Physical Layer high level interface timer callback (Status register polling)
+_STATIC_H void ifx_i2c_pl_status_poll_callback(void * p_ctx);
+/// Physical Layer intermediate state machine (Negotiation with slave)
+_STATIC_H void ifx_i2c_pl_negotiation_event_handler(void * p_input_ctx);
+/// Physical Layer intermediate state machine(Set bit rate)
+_STATIC_H optiga_lib_status_t ifx_i2c_pl_set_bit_rate(ifx_i2c_context_t * p_ctx, uint16_t bitrate);
+/// Physical Layer intermediate state machine (soft reset)
+_STATIC_H void ifx_i2c_pl_soft_reset(ifx_i2c_context_t * p_ctx);
+/// Physical Layer high level interface state machine (read/write frames)
+_STATIC_H void ifx_i2c_pl_frame_event_handler(ifx_i2c_context_t * p_ctx, optiga_lib_status_t event);
+/// Physical Layer low level interface timer callback (I2C Nack/Busy polling)
+_STATIC_H void ifx_i2c_pal_poll_callback(void * p_ctx);
+/// Physical Layer low level guard time callback
+_STATIC_H void ifx_i2c_pl_guard_time_callback(void * p_ctx);
+/// Physical Layer low level interface state machine (read/write registers)
+_STATIC_H void ifx_i2c_pl_pal_event_handler(void * p_ctx, optiga_lib_status_t event);
+/// Physical layer low level event handler for set slave address
+_STATIC_H void ifx_i2c_pl_pal_slave_addr_event_handler(void * p_input_ctx, optiga_lib_status_t event);
+
+/// @endcond
+
+optiga_lib_status_t ifx_i2c_pl_init(ifx_i2c_context_t * p_ctx, ifx_i2c_event_handler_t handler)
+{
+    LOG_PL("[IFX-PL]: Init\n");
+
+    p_ctx->pl.upper_layer_event_handler = handler;
+    p_ctx->pl.frame_state = PL_STATE_UNINIT;
+    p_ctx->pl.negotiate_state = PL_INIT_SET_FREQ_DEFAULT;
+    p_ctx->p_pal_i2c_ctx->slave_address = p_ctx->slave_address;
+    p_ctx->p_pal_i2c_ctx->upper_layer_event_handler = ifx_i2c_pl_pal_event_handler;
+    p_ctx->pl.retry_counter = PL_POLLING_MAX_CNT;
+    if (TRUE == p_ctx->do_pal_init)
+    {
+        // Initialize I2C driver
+        if (PAL_STATUS_SUCCESS != pal_i2c_init(p_ctx->p_pal_i2c_ctx))
+        {
+            return (IFX_I2C_STACK_ERROR);
+        }
+    }
+    // Set Physical Layer internal state
+    if ((uint8_t)TRUE == p_ctx->pl.request_soft_reset)
+    {
+        //Set the soft reset request to initial state to read register
+        p_ctx->pl.request_soft_reset = PL_INIT_GET_STATUS_REG;
+        p_ctx->pl.frame_state = PL_STATE_SOFT_RESET;
+    }
+    else
+    {
+        p_ctx->pl.frame_state = PL_STATE_INIT;
+    }
+
+    ifx_i2c_pl_frame_event_handler(p_ctx, IFX_I2C_STACK_SUCCESS);
+
+    return (IFX_I2C_STACK_SUCCESS);
+}
+
+optiga_lib_status_t ifx_i2c_pl_send_frame(ifx_i2c_context_t * p_ctx, uint8_t * p_frame, uint16_t frame_len)
+{
+    // Physical Layer must be idle, set requested action
+    if ((PL_STATE_INIT != p_ctx->pl.frame_state) && (PL_STATE_READY != p_ctx->pl.frame_state))
+    {
+        return (IFX_I2C_STACK_ERROR);
+    }
+    p_ctx->pl.frame_action = PL_ACTION_WRITE_FRAME;
+
+    // Store reference to frame for sending it later
+    p_ctx->pl.p_tx_frame   = p_frame;
+    p_ctx->pl.tx_frame_len = frame_len;
+
+    ifx_i2c_pl_frame_event_handler(p_ctx, IFX_I2C_STACK_SUCCESS);
+    return (IFX_I2C_STACK_SUCCESS);
+}
+
+optiga_lib_status_t ifx_i2c_pl_receive_frame(ifx_i2c_context_t * p_ctx)
+{
+    // Physical Layer must be idle, set requested action
+    if ((PL_STATE_INIT != p_ctx->pl.frame_state) && (PL_STATE_READY != p_ctx->pl.frame_state))
+    {
+        return (IFX_I2C_STACK_ERROR);
+    }
+    p_ctx->pl.frame_action = PL_ACTION_READ_FRAME;
+
+    ifx_i2c_pl_frame_event_handler(p_ctx, IFX_I2C_STACK_SUCCESS);
+    return (IFX_I2C_STACK_SUCCESS);
+}
+
+optiga_lib_status_t ifx_i2c_pl_write_slave_address(ifx_i2c_context_t * p_ctx, uint8_t slave_address, uint8_t persistent)
+{
+    optiga_lib_status_t status = IFX_I2C_STACK_ERROR;
+    upper_layer_callback_t * p_temp_upper_layer_event_handler;
+
+    /// @cond hidden
+    #define PAL_WRITE_INIT_STATUS       (0x00FF)
+    #define ADDRESS_OFFSET              (0x02)
+    #define BASE_ADDRESS_REG_OFFSET     (0x00)
+    #define MODE_OFFSET                 (0x01)
+    #define POLLING_INTERVAL            (0x01)
+    #define DELAY_FOR_COMPLETION        (0x0A)
+    /// @endcond
+
+    //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+    //ifx i2c wrapper api for setting slave address in synchronous. hence the event handler is backed up.
+    p_temp_upper_layer_event_handler = (upper_layer_callback_t * )(p_ctx->p_pal_i2c_ctx->upper_layer_event_handler);
+    //since the lower level APIs are asynchronous, a temporary event handler for set slave address is assigned
+    p_ctx->p_pal_i2c_ctx->upper_layer_event_handler = ifx_i2c_pl_pal_slave_addr_event_handler;
+
+    p_ctx->pl.buffer[BASE_ADDRESS_REG_OFFSET] = PL_REG_BASE_ADDR;
+    p_ctx->pl.buffer[MODE_OFFSET] = PL_REG_BASE_ADDR_VOLATILE;
+    //supported base addresses are 0x00 - 0x7F. Hence 8th bit is ignored
+    p_ctx->pl.buffer[ADDRESS_OFFSET] = slave_address & PL_REG_I2C_BASE_ADDRESS_MASK;
+    p_ctx->pl.buffer_tx_len = 1 + PL_REG_LEN_BASE_ADDR;
+
+    if (PL_REG_BASE_ADDR_VOLATILE != persistent)
+    {
+        p_ctx->pl.buffer[MODE_OFFSET] = PL_REG_BASE_ADDR_PERSISTANT;
+    }
+
+    p_ctx->pl.retry_counter   = PL_POLLING_MAX_CNT;
+
+    while (0 != p_ctx->pl.retry_counter)
+    {
+        g_pal_event_status = PAL_WRITE_INIT_STATUS;
+
+        //lint --e{534} suppress "Error handling is not required so return value is not checked"
+        pal_i2c_write(p_ctx->p_pal_i2c_ctx, p_ctx->pl.buffer, p_ctx->pl.buffer_tx_len);
+        while (PAL_WRITE_INIT_STATUS == g_pal_event_status){};
+        if (PAL_I2C_EVENT_SUCCESS == g_pal_event_status)
+        {
+            break;
+        }
+        p_ctx->pl.retry_counter--;
+        pal_os_timer_delay_in_milliseconds(POLLING_INTERVAL);
+    }
+
+    if (PAL_I2C_EVENT_SUCCESS == g_pal_event_status)
+    {
+        p_ctx->p_pal_i2c_ctx->slave_address = p_ctx->pl.buffer[ADDRESS_OFFSET];
+        if (PL_REG_BASE_ADDR_VOLATILE != persistent)
+        {
+            p_ctx->slave_address = p_ctx->pl.buffer[ADDRESS_OFFSET];
+        }
+        pal_os_timer_delay_in_milliseconds(DELAY_FOR_COMPLETION);
+        status = IFX_I2C_STACK_SUCCESS;
+    }
+    //restoring the backed up event handler
+    p_ctx->p_pal_i2c_ctx->upper_layer_event_handler = p_temp_upper_layer_event_handler;
+
+    /// @cond hidden
+    #undef PAL_WRITE_INIT_STATUS
+    #undef ADDRESS_OFFSET
+    #undef BASE_ADDRESS_REG_OFFSET
+    #undef MODE_OFFSET
+    #undef POLLING_INTERVAL
+    #undef DELAY_FOR_COMPLETION
+    /// @endcond
+
+    return (status);
+}
+
+_STATIC_H void ifx_i2c_pl_read_register(ifx_i2c_context_t * p_ctx, uint8_t reg_addr, uint16_t reg_len)
+{
+    LOG_PL("[IFX-PL]: Read register %x len %d\n", reg_addr, reg_len);
+
+    // Prepare transmit buffer to write register address
+    p_ctx->pl.buffer[0]     = reg_addr;
+    p_ctx->pl.buffer_tx_len = 1;
+
+    // Set low level interface variables and start transmission
+    p_ctx->pl.buffer_rx_len   = reg_len;
+    p_ctx->pl.register_action = PL_ACTION_READ_REGISTER;
+    p_ctx->pl.retry_counter   = PL_POLLING_MAX_CNT;
+    p_ctx->pl.i2c_cmd         = PL_I2C_CMD_WRITE;
+
+    //lint --e{534} suppress "This is the last statement of asynchronous function hence return value is not checked"
+    pal_i2c_write(p_ctx->p_pal_i2c_ctx, p_ctx->pl.buffer, p_ctx->pl.buffer_tx_len);
+}
+
+
+_STATIC_H void ifx_i2c_pl_write_register(ifx_i2c_context_t * p_ctx,
+                                         uint8_t reg_addr,
+                                         uint16_t reg_len,
+                                         const uint8_t * p_content)
+{
+    LOG_PL("[IFX-PL]: Write register %x len %d\n", reg_addr, reg_len);
+
+    // Prepare transmit buffer to write register address and content
+    p_ctx->pl.buffer[0] = reg_addr;
+    memcpy(p_ctx->pl.buffer + 1, p_content, reg_len);
+    p_ctx->pl.buffer_tx_len = 1 + reg_len;
+
+    // Set Physical Layer low level interface variables and start transmission
+    p_ctx->pl.register_action = PL_ACTION_WRITE_REGISTER;
+    p_ctx->pl.retry_counter   = PL_POLLING_MAX_CNT;
+    p_ctx->pl.i2c_cmd         = PL_I2C_CMD_WRITE;
+    //lint --e{534} suppress "This is the last statement of asynchronous function hence return value is not checked"
+    pal_i2c_write(p_ctx->p_pal_i2c_ctx, p_ctx->pl.buffer, p_ctx->pl.buffer_tx_len);
+}
+
+
+_STATIC_H void ifx_i2c_pl_status_poll_callback(void * p_ctx)
+{
+    LOG_PL("[IFX-PL]: Status poll Timer elapsed  -> Read STATUS register\n");
+    ifx_i2c_pl_read_register((ifx_i2c_context_t * )p_ctx, PL_REG_I2C_STATE, PL_REG_LEN_I2C_STATE);
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_pl_set_bit_rate(ifx_i2c_context_t * p_ctx, uint16_t bitrate)
+{
+    optiga_lib_status_t status;
+    void* p_pal_ctx_upper_layer_handler;
+    // Save upper layer context in pal
+    p_pal_ctx_upper_layer_handler = p_ctx->p_pal_i2c_ctx->upper_layer_event_handler;
+    // Pass context as NULL to avoid callback invocation
+    p_ctx->p_pal_i2c_ctx->upper_layer_event_handler  = NULL;
+    status = pal_i2c_set_bitrate(p_ctx->p_pal_i2c_ctx , bitrate);
+    // Restore callback
+    p_ctx->p_pal_i2c_ctx->upper_layer_event_handler  = p_pal_ctx_upper_layer_handler;
+    if (PAL_I2C_EVENT_SUCCESS != status)
+    {
+        if (0 != (p_ctx->pl.retry_counter--))
+        {
+            LOG_PL("[IFX-PL]: Set bit rate failed, Retry setting.\n");
+            pal_os_event_register_callback_oneshot( p_ctx->pal_os_event_ctx,
+                                                    ifx_i2c_pl_negotiation_event_handler,
+                                                   ((void * )p_ctx),
+                                                   PL_POLLING_INVERVAL_US);
+            status = IFX_I2C_STACK_BUSY;
+        }
+        else
+        {
+           status = IFX_I2C_STACK_ERROR;
+        }
+    }
+    else
+    {
+        status = IFX_I2C_STACK_SUCCESS;
+    }
+
+    return (status);
+
+}
+_STATIC_H void ifx_i2c_pl_negotiation_event_handler(void * p_input_ctx)
+{
+    optiga_lib_status_t event = (optiga_lib_status_t)IFX_I2C_STACK_ERROR;
+    uint8_t continue_negotiation;
+    ifx_i2c_context_t * p_ctx = (ifx_i2c_context_t * )p_input_ctx;
+    uint8_t i2c_mode_value[2];
+    uint8_t max_frame_size[2] = { (uint8_t)(p_ctx->frame_size >> 8), (uint8_t)(p_ctx->frame_size) };
+    uint16_t buffer_len = 0;
+    uint16_t slave_frequency;
+    uint16_t slave_frame_len;
+    uint8_t* p_buffer = NULL;
+
+    do
+    {
+        continue_negotiation = FALSE;
+        LOG_PL("[IFX-PL]: Negotiation started\n");
+        switch (p_ctx->pl.negotiate_state)
+        {
+            // Set initial frequency to PL_DEFAULT_FREQUENCY to be able to negotiate with slave
+            case PL_INIT_SET_FREQ_DEFAULT:
+            {
+                // Default frequency set to master
+                event = ifx_i2c_pl_set_bit_rate(p_input_ctx, PL_DEFAULT_FREQUENCY);
+                if (IFX_I2C_STACK_SUCCESS == event)
+                {
+                    p_ctx->pl.negotiate_state = PL_INIT_GET_FREQ_REG;
+                    continue_negotiation = TRUE;
+                }
+                else if (IFX_I2C_STACK_ERROR == event)
+                {
+                    p_ctx->pl.negotiate_state = PL_INIT_DONE;
+                    p_buffer = NULL;
+                    buffer_len = 0;
+                    pal_os_event_register_callback_oneshot(p_ctx->pal_os_event_ctx,(register_callback)ifx_i2c_pl_negotiation_event_handler,
+                                                           (void * )p_ctx,
+                                                           STARTUP_TIME_MSEC);
+                }
+            }
+            break;
+            // Read the current Max frequency supported by slave
+            case PL_INIT_GET_FREQ_REG:
+            {
+                p_ctx->pl.negotiate_state = PL_INIT_SET_FREQ_REG;
+                ifx_i2c_pl_read_register(p_ctx, PL_REG_MAX_SCL_FREQU, PL_REG_LEN_MAX_SCL_FREQU);
+            }
+            break;
+            // Set the I2C mode register
+            case PL_INIT_SET_FREQ_REG:
+            {
+                slave_frequency = (p_ctx->pl.buffer[2] << 8) | p_ctx->pl.buffer[3];
+
+                i2c_mode_value[0] = PL_REG_I2C_MODE_PERSISTANT;
+                if ((p_ctx->frequency > PL_SM_FM_MAX_FREQUENCY) && (slave_frequency <= PL_SM_FM_MAX_FREQUENCY))
+                {
+                    //Change to FM+ mode if slave's current supported frequency is below user's requested frequency
+                    i2c_mode_value[1] = PL_REG_I2C_MODE_FM_PLUS;
+                    p_ctx->pl.negotiate_state = PL_INIT_READ_FREQ;
+                    ifx_i2c_pl_write_register(p_ctx, PL_REG_I2C_MODE, PL_REG_LEN_I2C_MODE, i2c_mode_value);
+                }
+                else if ((p_ctx->frequency <= PL_SM_FM_MAX_FREQUENCY) && (slave_frequency > PL_SM_FM_MAX_FREQUENCY))
+                {
+                    //Change to SM&FM mode if slave's current supported frequency is above user's requested frequency
+                    i2c_mode_value[1] = PL_REG_I2C_MODE_SM_FM;
+                    p_ctx->pl.negotiate_state = PL_INIT_READ_FREQ;
+                    ifx_i2c_pl_write_register(p_ctx, PL_REG_I2C_MODE, PL_REG_LEN_I2C_MODE, i2c_mode_value);
+                }
+                else
+                {
+                    p_ctx->pl.negotiate_state = PL_INIT_VERIFY_FREQ;
+                    continue_negotiation = TRUE;
+                }
+            }
+            break;
+            // After setting I2C mode register, read the slave's supported frequency
+            case PL_INIT_READ_FREQ:
+            {
+                p_ctx->pl.negotiate_state = PL_INIT_VERIFY_FREQ;
+                ifx_i2c_pl_read_register(p_ctx, PL_REG_MAX_SCL_FREQU, PL_REG_LEN_MAX_SCL_FREQU);
+            }
+            break;
+            // Verify the requested frequency and slave's supported frequency
+            case PL_INIT_VERIFY_FREQ:
+            {
+                slave_frequency = (p_ctx->pl.buffer[2] << 8) | p_ctx->pl.buffer[3];
+                if (p_ctx->frequency > slave_frequency)
+                {
+                    LOG_PL("[IFX-PL]: Unexpected frequency in MAX_SCL_FREQU\n");
+                    p_buffer = NULL;
+                    buffer_len = 0;
+                    p_ctx->pl.negotiate_state = PL_INIT_DONE;
+                }
+                else
+                {
+                    p_ctx->pl.negotiate_state = PL_INIT_AGREE_FREQ;
+                }
+                continue_negotiation = TRUE;
+            }
+            break;
+            // Frequency negotiated, Set frequency at master
+            case PL_INIT_AGREE_FREQ:
+            {
+                // Frequency negotiation between master and slave is complete
+                event = ifx_i2c_pl_set_bit_rate(p_input_ctx, p_ctx->frequency);
+                if (IFX_I2C_STACK_SUCCESS == event)
+                {
+                    p_ctx->pl.negotiate_state = PL_INIT_SET_DATA_REG_LEN;
+                    continue_negotiation = TRUE;
+                }
+                else if (IFX_I2C_STACK_ERROR == event)
+                {
+                    p_ctx->pl.negotiate_state = PL_INIT_DONE;
+                    p_buffer = NULL;
+                    buffer_len = 0;
+                }
+            }
+            break;
+            // Start frame length negotiation by writing the requested frame length
+            case PL_INIT_SET_DATA_REG_LEN:
+            {
+                p_ctx->pl.negotiate_state = PL_INIT_GET_DATA_REG_LEN;
+                ifx_i2c_pl_write_register(p_ctx, PL_REG_DATA_REG_LEN, sizeof(max_frame_size), max_frame_size);
+            }
+            break;
+            // Read the frame length to verify
+            case PL_INIT_GET_DATA_REG_LEN:
+            {
+                p_ctx->pl.negotiate_state = PL_INIT_VERIFY_DATA_REG;
+                ifx_i2c_pl_read_register(p_ctx, PL_REG_DATA_REG_LEN, PL_REG_LEN_DATA_REG_LEN);
+            }
+            break;
+            // Check is slave accepted the new frame length
+            case PL_INIT_VERIFY_DATA_REG:
+            {
+                p_ctx->pl.negotiate_state = PL_INIT_DONE;
+                slave_frame_len = (p_ctx->pl.buffer[0] << 8) | p_ctx->pl.buffer[1];
+                // Error if slave's frame length is more than requested frame length
+                if (p_ctx->frame_size >= slave_frame_len)
+                {
+                    p_ctx->frame_size = slave_frame_len;
+                    event = IFX_I2C_STACK_SUCCESS;
+                }
+                p_buffer = NULL;
+                buffer_len = 0;
+                continue_negotiation = TRUE;
+            }
+            break;
+            case PL_INIT_DONE:
+            {
+                if (IFX_I2C_STACK_SUCCESS == event)
+                {
+                    p_ctx->pl.frame_state = PL_STATE_READY;
+                }
+                else
+                {
+                    p_ctx->pl.frame_state = PL_STATE_UNINIT;
+                }
+                // Negotiation between master and slave is complete
+                p_ctx->pl.upper_layer_event_handler(p_ctx,event, p_buffer, buffer_len);
+            }
+            break;
+            default:
+                break;
+        }
+    } while (FALSE != continue_negotiation);
+}
+
+
+_STATIC_H void ifx_i2c_pl_frame_event_handler(ifx_i2c_context_t * p_ctx, optiga_lib_status_t event)
+{
+    uint32_t time_stamp_diff;
+    uint32_t current_time;
+    uint16_t frame_size;
+    if (IFX_I2C_STACK_SUCCESS != event)
+    {
+        p_ctx->pl.frame_state = PL_STATE_READY;
+        // I2C read or write failed, report to upper layer
+        p_ctx->pl.upper_layer_event_handler(p_ctx, event, 0, 0);
+    }
+    else
+    {
+        switch (p_ctx->pl.frame_state)
+        {
+            // Perform soft reset
+            case PL_STATE_SOFT_RESET:
+            {
+                ifx_i2c_pl_soft_reset(p_ctx);
+            }
+            break;
+            // Negotiate frame and frequency with slave
+            case PL_STATE_INIT:
+            {
+                ifx_i2c_pl_negotiation_event_handler(p_ctx);
+            }
+            break;
+            // Check status of slave data
+            case PL_STATE_READY:
+            {
+                // Start polling status register
+                p_ctx->pl.frame_state            = PL_STATE_DATA_AVAILABLE;
+                if (PL_ACTION_READ_FRAME == p_ctx->pl.frame_action)
+                {
+                    ifx_i2c_pl_read_register(p_ctx, PL_REG_I2C_STATE, PL_REG_LEN_I2C_STATE);
+                    break;
+                }
+            }
+            //lint -fallthrough "For write frame, polling of i2c status register is skipped"
+            // Do read/write frame
+            case PL_STATE_DATA_AVAILABLE:
+            {
+                // Read frame, if response is ready. Ignore busy flag
+                if ((PL_ACTION_READ_FRAME == p_ctx->pl.frame_action)
+                && (0 != (p_ctx->pl.buffer[0] & PL_REG_I2C_STATE_RESPONSE_READY)))
+                {
+                    frame_size = (p_ctx->pl.buffer[2] << 8) | p_ctx->pl.buffer[3];
+                    if ((frame_size > 0) && (frame_size <= p_ctx->frame_size))
+                    {
+                        p_ctx->pl.frame_state = PL_STATE_RXTX;
+                        ifx_i2c_pl_read_register(p_ctx,PL_REG_DATA, frame_size);
+                    }
+                    else
+                    {
+                        current_time = pal_os_timer_get_time_in_milliseconds();
+                        time_stamp_diff = (current_time - p_ctx->dl.frame_start_time);
+                        if (p_ctx->dl.frame_start_time > current_time)
+                        {
+                            time_stamp_diff = (0xFFFFFFFF + (current_time -
+                                               p_ctx->dl.frame_start_time)) + 0x01;
+                        }
+                        // Continue polling STATUS register if retry limit is not reached
+                        if (time_stamp_diff < p_ctx->dl.data_poll_timeout)
+                        {
+                            pal_os_event_register_callback_oneshot(p_ctx->pal_os_event_ctx,
+                                                                    ifx_i2c_pl_status_poll_callback,
+                                                                   (void * )p_ctx,
+                                                                   PL_DATA_POLLING_INVERVAL_US);
+                        }
+                        else
+                        {
+                            p_ctx->pl.frame_state = PL_STATE_READY;
+                            p_ctx->pl.upper_layer_event_handler(p_ctx, IFX_I2C_STACK_ERROR, 0, 0);
+                        }
+                    }
+                }
+                // Write frame is slave is not busy
+                else if (PL_ACTION_WRITE_FRAME == p_ctx->pl.frame_action)
+                {
+                    // Write frame if device is not busy, otherwise wait and poll STATUS again later
+                    p_ctx->pl.frame_state = PL_STATE_RXTX;
+                    ifx_i2c_pl_write_register(p_ctx,
+                                              PL_REG_DATA,
+                                              p_ctx->pl.tx_frame_len,
+                                              (uint8_t * )p_ctx->pl.p_tx_frame);
+                }
+                // Continue checking the slave status register
+                else
+                {
+                    current_time = pal_os_timer_get_time_in_milliseconds();
+                    time_stamp_diff = (current_time - p_ctx->dl.frame_start_time);
+                    if (p_ctx->dl.frame_start_time > current_time)
+                    {
+                        time_stamp_diff = (0xFFFFFFFF + (current_time -
+                                           p_ctx->dl.frame_start_time)) + 0x01;
+                    }
+                    // Continue polling STATUS register if retry limit is not reached
+                    if (time_stamp_diff < p_ctx->dl.data_poll_timeout)
+                    {
+                        pal_os_event_register_callback_oneshot(p_ctx->pal_os_event_ctx,
+                                                               ifx_i2c_pl_status_poll_callback,
+                                                               (void * )p_ctx,
+                                                               PL_DATA_POLLING_INVERVAL_US);
+                    }
+                    else
+                    {
+                        p_ctx->pl.frame_state = PL_STATE_READY;
+                        p_ctx->pl.upper_layer_event_handler(p_ctx, IFX_I2C_STACK_ERROR, 0, 0);
+                    }
+                }
+            }
+            break;
+            // Frame reading is complete
+            case PL_STATE_RXTX:
+            {
+                // Writing/reading of frame to/from DATA register complete
+                p_ctx->pl.frame_state = PL_STATE_READY;
+                p_ctx->pl.upper_layer_event_handler(p_ctx,IFX_I2C_STACK_SUCCESS,
+                                                    p_ctx->pl.buffer,
+                                                    p_ctx->pl.buffer_rx_len);
+            }
+            break;
+            default:
+            {
+                // Default condition occurred
+                p_ctx->pl.frame_state = PL_STATE_INIT;
+                p_ctx->pl.upper_layer_event_handler(p_ctx, IFX_I2C_STACK_ERROR, 0, 0);
+            }
+            break;
+        }
+    }
+}
+
+_STATIC_H void ifx_i2c_pal_poll_callback(void * p_ctx)
+{
+    ifx_i2c_context_t * p_local_ctx = (ifx_i2c_context_t * )p_ctx;
+    if (PL_I2C_CMD_WRITE == p_local_ctx->pl.i2c_cmd)
+    {
+        LOG_PL("[IFX-PL]: Poll Timer elapsed -> Restart TX\n");
+        //lint --e{534} suppress "This is the last statement of asynchronous function hence return value is not checked"
+        pal_i2c_write(p_local_ctx->p_pal_i2c_ctx, p_local_ctx->pl.buffer, p_local_ctx->pl.buffer_tx_len);
+    }
+    else if (PL_I2C_CMD_READ == p_local_ctx->pl.i2c_cmd)
+    {
+        LOG_PL("[IFX-PL]: Poll Timer elapsed  -> Restart Read Register -> Start TX\n");
+        //lint --e{534} suppress "This is the last statement of asynchronous function hence return value is not checked"
+        pal_i2c_read(p_local_ctx->p_pal_i2c_ctx, p_local_ctx->pl.buffer, p_local_ctx->pl.buffer_rx_len);
+    }
+}
+
+
+_STATIC_H void ifx_i2c_pl_guard_time_callback(void * p_ctx)
+{
+    ifx_i2c_context_t * p_local_ctx = (ifx_i2c_context_t * )p_ctx;
+    if (PL_ACTION_READ_REGISTER == p_local_ctx->pl.register_action)
+    {
+        if (PL_I2C_CMD_WRITE == p_local_ctx->pl.i2c_cmd)
+        {
+            LOG_PL("[IFX-PL]: GT done-> Start RX\n");
+            p_local_ctx->pl.i2c_cmd = PL_I2C_CMD_READ;
+            //lint --e{534} suppress "This is the last statement of asynchronous function hence return value is not checked"
+            pal_i2c_read(p_local_ctx->p_pal_i2c_ctx, p_local_ctx->pl.buffer, p_local_ctx->pl.buffer_rx_len);
+        }
+        else if (PL_I2C_CMD_READ == p_local_ctx->pl.i2c_cmd)
+        {
+            LOG_PL("[IFX-PL]: GT done -> REG is read\n");
+            ifx_i2c_pl_frame_event_handler(p_local_ctx,IFX_I2C_STACK_SUCCESS);
+        }
+    }
+    else if (PL_ACTION_WRITE_REGISTER == p_local_ctx->pl.register_action)
+    {
+        LOG_PL("[IFX-PL]: GT done -> REG written\n");
+        ifx_i2c_pl_frame_event_handler(p_local_ctx,IFX_I2C_STACK_SUCCESS);
+    }
+}
+
+_STATIC_H void ifx_i2c_pl_pal_event_handler(void * p_ctx, optiga_lib_status_t event)
+{
+    ifx_i2c_context_t * p_local_ctx = (ifx_i2c_context_t * )p_ctx;
+    switch (event)
+    {
+        case PAL_I2C_EVENT_ERROR:
+        case PAL_I2C_EVENT_BUSY:
+            // Error event usually occurs when the device is in sleep mode and needs time to wake up
+            if (p_local_ctx->pl.retry_counter--)
+            {
+                LOG_PL("[IFX-PL]: PAL Error -> Continue polling\n");
+                pal_os_event_register_callback_oneshot(p_local_ctx->pal_os_event_ctx,
+                                                        ifx_i2c_pal_poll_callback, p_local_ctx, PL_POLLING_INVERVAL_US);
+            }
+            else
+            {
+                LOG_PL("[IFX-PL]: PAL Error -> Stop\n");
+                ifx_i2c_pl_frame_event_handler(p_local_ctx, IFX_I2C_FATAL_ERROR);
+            }
+            break;
+
+        case PAL_I2C_EVENT_SUCCESS:
+            LOG_PL("[IFX-PL]: PAL Success -> Wait Guard Time\n");
+            pal_os_event_register_callback_oneshot(p_local_ctx->pal_os_event_ctx, ifx_i2c_pl_guard_time_callback,
+                                                    p_local_ctx,PL_GUARD_TIME_INTERVAL_US);
+            break;
+        default:
+            break;
+    }
+}
+
+
+_STATIC_H void ifx_i2c_pl_soft_reset(ifx_i2c_context_t * p_ctx)
+{
+    uint8_t i2c_mode_value[2] = {0};
+    switch (p_ctx->pl.request_soft_reset)
+    {
+        case PL_INIT_GET_STATUS_REG:
+        {
+            p_ctx->pl.request_soft_reset = PL_RESET_WRITE;
+            //Read the status register to check if soft reset is supported
+            ifx_i2c_pl_read_register(p_ctx, PL_REG_I2C_STATE, PL_REG_LEN_I2C_STATE);
+            break;
+        }
+        case PL_RESET_WRITE:
+        {
+            //Mask for soft reset bit(5th bit) from the 1st byte of status register
+            p_ctx->pl.buffer[0] &= PL_REG_I2C_STATE_SOFT_RESET;
+            if (PL_REG_I2C_STATE_SOFT_RESET == p_ctx->pl.buffer[0])
+            {
+                p_ctx->pl.request_soft_reset = PL_RESET_STARTUP;
+                //Write 88 register with 0 value
+                ifx_i2c_pl_write_register(p_ctx, PL_REG_SOFT_RESET, PL_REG_LEN_SOFT_RESET, i2c_mode_value);
+            }
+            else
+            {
+                //Soft reset is not supported by the slave
+                p_ctx->pl.frame_state = PL_STATE_UNINIT;
+                ifx_i2c_pl_frame_event_handler(p_ctx, IFX_I2C_STACK_ERROR);
+            }
+            break;
+        }
+        case PL_RESET_STARTUP:
+        {
+            p_ctx->pl.request_soft_reset= PL_RESET_INIT;
+            pal_os_event_register_callback_oneshot(p_ctx->pal_os_event_ctx,(register_callback)ifx_i2c_pl_soft_reset,
+                                                   (void * )p_ctx,
+                                                   STARTUP_TIME_MSEC);
+            break;
+        }
+        case PL_RESET_INIT:
+        {
+            p_ctx->pl.frame_state = PL_STATE_INIT;
+            ifx_i2c_pl_frame_event_handler(p_ctx, IFX_I2C_STACK_SUCCESS);
+            break;
+        }
+        default:
+            break;
+    }
+}
+
+//lint --e{715} suppress "This is used for synchromous implementation, hence p_ctx not used"
+//lint --e{818} suppress "This is ignored as upper layer handler function prototype requires this argument"
+_STATIC_H void ifx_i2c_pl_pal_slave_addr_event_handler(void * p_ctx, optiga_lib_status_t event)
+{
+    g_pal_event_status = event;
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_presentation_layer.c b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_presentation_layer.c
new file mode 100644
index 000000000..a14eab6b2
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_presentation_layer.c
@@ -0,0 +1,1173 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_presentation_layer.c
+*
+* \brief   This file implements the IFX I2C Presentation Layer of the Infineon I2C Protocol Stack library.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+#include "optiga/ifx_i2c/ifx_i2c_presentation_layer.h"
+#include "optiga/ifx_i2c/ifx_i2c_transport_layer.h"
+#include "optiga/pal/pal_crypt.h"
+#include "optiga/common/optiga_lib_common.h"
+#include "optiga/pal/pal_ifx_i2c_config.h"
+// include lower layer header
+/// @cond hidden
+
+// Setup debug log statements
+#if IFX_I2C_LOG_PRL == 1
+#define LOG_PRL IFX_I2C_LOG
+#else
+#define LOG_PRL(...)  //printf(__VA_ARGS__);
+#endif
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION        
+
+/// @cond hidden
+
+// Presentation Layer states
+#define PRL_STATE_UNINIT                     (0x00)
+#define PRL_STATE_IDLE                       (0x01)
+#define PRL_STATE_START                      (0x02)
+#define PRL_STATE_VERIFY                     (0x03)
+#define PRL_STATE_TXRX                       (0x04)
+#define PRL_STATE_HANDSHAKE                  (0x05)
+#define PRL_STATE_ALERT                      (0x06)
+#define PRL_STATE_ERROR                      (0x07)
+#define PRL_STATE_MANAGE_CONTEXT             (0x08)
+
+///Manage context state
+#define PRL_MANAGE_CONTEXT_TX_STATE          (0x01)
+#define PRL_MANAGE_CONTEXT_RX_STATE          (0x02)
+
+/// Handshake status
+#define PRL_HS_SEND_HELLO                    (0x11)
+#define PRL_HS_VERIFY_HELLO                  (0x22)
+#define PRL_HS_SEND_FINISHED                 (0x33)
+#define PRL_HS_VERIFY_FINISHED               (0x44)
+#define PRL_HS_ERROR                         (0x55)
+
+/// Handshake type
+#define PRL_MASTER_HELLO_MSG                 (0x00)
+#define PRL_MASTER_FINISHED_MSG              (0x08)
+
+///Protocol type
+#define PRL_HANDSHAKE_PROTOCOL               (0x00)
+#define PRL_RECORD_EXCHANGE_PROTOCOL         (0x20)
+#define PRL_ALERT_PROTOCOL                   (0x40)
+
+///Message type
+#define PRL_FATAL_ALERT_MSG                  (0x00)
+#define PRL_INTEGRITY_VIOLATED_ALERT_MSG     (0x04)
+#define PRL_INVALID_ALERT                    (0xFF)
+#define PRL_DEFAULT_ALERT                    (0x11)
+
+///Handshake completion state
+#define PRL_NEGOTIATION_NOT_DONE             (0x00)
+#define PRL_NEGOTIATION_DONE                 (0x01)
+
+///Offset calculation values
+#define PRL_MASTER_ENCRYPTION_KEY_OFFSET     (0x00)
+#define PRL_MASTER_ENCRYPTION_NONCE_OFFSET   (0x20)
+#define PRL_MASTER_DECRYPTION_KEY_OFFSET     (0x10)
+#define PRL_MASTER_DECRYPTION_NONCE_OFFSET   (0x24)
+#define PRL_SLAVE_HELLO_SEQ_NUMBER_OFFSET    (0x22)
+#define PRL_PLAIN_TEST_OFFSET                (0x04)
+#define PRL_SCTR_OFFSET                      (0x00)
+#define PRL_PROTOCOL_VERSION_OFFSET          (0x01)
+#define PRL_RANDOM_DATAOFFSET                (0x02)
+
+///Length calculation values
+#define PRL_RANDOM_DATA_LENGTH               (0x20)
+#define PRL_MASTER_NONCE_LENGTH              (0x04)
+#define PRL_FINISHED_DATA_LENGTH             (0x30)
+#define PRL_SEQ_NUMBER_LENGTH                (0x04)
+#define PRL_SLAVE_HELLO_LENGTH               (0x26)
+#define PRL_NONCE_LENGTH                     (0x08)
+
+///Manage context message type
+#define PRL_SAVE_CONTEXT_MSG                 (0x60)
+#define PRL_CONTEXT_SAVED_MSG                (0x64)
+#define PRL_RESTORE_CONTEXT_MSG              (0x68)
+#define PRL_CONTEXT_RESTORED_MSG             (0x6C)
+
+///Restore operation state
+#define PRL_RESTORE_NOT_DONE                 (0x00)
+#define PRL_RESTORE_DONE                     (0x01)
+
+///Mask values
+#define PRL_MANAGE_CONTEXT_MASK              (0xFC)
+#define PRL_PROTECTION_MASK                  (0x03)
+
+#define PRL_SEQUENCE_THRESHOLD               (0xFFFFFFF0)
+#define PRL_TRANS_REPEAT                     (DL_TRANS_REPEAT)
+
+#define PRL_LABEL                            "Platform Binding"
+
+#define FORM_SCTR_HEADER(ctx, protocol, msg, protection){\
+                         p_ctx->prl.sctr = (protocol | msg | protection);}\
+
+#define ERROR_STATE_PREPARATION(ctx, exit_machine){\
+                                ctx->prl.alert_type = PRL_INVALID_ALERT;\
+                                ctx->prl.state = PRL_STATE_ERROR;\
+                                ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;\
+                                ctx->prl.return_status = IFX_I2C_SESSION_ERROR;\
+                                ctx->prl.trans_repeat_status = FALSE;\
+                                exit_machine = TRUE;}\
+
+#define CLEAR_SESSION_CONTEXT(ctx){\
+                              memset(ctx->prl.session_key,0,sizeof(ctx->prl.session_key));\
+                              ctx->prl.master_sequence_number = 0;\
+                              ctx->prl.slave_sequence_number = 0;\
+                              ctx->prl.save_slave_sequence_number = 0;\
+                              ctx->prl.decryption_failure_counter = 0;\
+                              ctx->prl.data_retransmit_counter = 0;\
+                              ctx->prl.trans_repeat_status = FALSE;\
+                              ctx->prl.state = PRL_STATE_IDLE;}\
+
+#define CLEAR_SAVED_SESSION_CONTEXT(ctx){\
+                                    memset(ctx.session_key,0,sizeof(ctx.session_key));\
+                                    ctx.master_sequence_number = 0;\
+                                    ctx.negotiation_state = 0;\
+                                    ctx.save_slave_sequence_number = 0;\
+                                    ctx.decryption_failure_counter = 0;\
+                                    ctx.data_retransmit_counter = 0;\
+                                    ctx.stored_context_flag = FALSE;}\
+
+#define COPY_MANAGE_CONTEXT_DATA(source, destination){\
+                                 memcpy(destination.session_key,source.session_key,sizeof(source.session_key));\
+                                 destination.master_sequence_number = source.master_sequence_number;\
+                                 destination.save_slave_sequence_number = source.save_slave_sequence_number;\
+                                 destination.decryption_failure_counter = source.decryption_failure_counter;\
+                                 destination.data_retransmit_counter = source.data_retransmit_counter;\
+                                 destination.negotiation_state = source.negotiation_state;}\
+
+#define DO_NEGOTIATION(ctx, exit_machine){\
+                       ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;\
+                       ctx->prl.state = PRL_STATE_HANDSHAKE;\
+                       exit_machine = TRUE;\
+                       ctx->prl.hs_state = PRL_HS_SEND_HELLO;}\
+
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_do_handshake(ifx_i2c_context_t * p_ctx,
+                                                       const uint8_t * p_data);
+_STATIC_H void ifx_i2c_prl_event_handler(ifx_i2c_context_t * p_ctx,
+                                         optiga_lib_status_t event,
+                                         const uint8_t * p_data,
+                                         uint16_t data_len);
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_prf(ifx_i2c_context_t * p_ctx);
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_send_alert(ifx_i2c_context_t * p_ctx);
+/// @endcond
+
+optiga_lib_status_t ifx_i2c_prl_init(ifx_i2c_context_t * p_ctx,
+                                     ifx_i2c_event_handler_t handler)
+{
+    optiga_lib_status_t return_status = IFX_I2C_STACK_ERROR;
+    LOG_PRL("[IFX-PRL]: Init\n");
+
+    p_ctx->tl.state = PRL_STATE_UNINIT;
+
+    do
+    {
+        // Initialize transport layer (and register event handler)
+        if (IFX_I2C_STACK_SUCCESS != ifx_i2c_tl_init(p_ctx, ifx_i2c_prl_event_handler))
+        {
+            break;
+        }
+
+        p_ctx->prl.upper_layer_event_handler = handler;
+        if (IFX_I2C_SESSION_CONTEXT_RESTORE == p_ctx->manage_context_operation)
+        {
+            p_ctx->prl.restore_context_flag = PRL_RESTORE_NOT_DONE;
+        }
+        else
+        {
+            p_ctx->prl.restore_context_flag = PRL_RESTORE_DONE;
+        }
+        p_ctx->prl.state = PRL_STATE_IDLE;
+
+        p_ctx->protocol_version = PROTOCOL_VERSION_PRE_SHARED_SECRET;
+        p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+        p_ctx->prl.return_status = IFX_I2C_STACK_SUCCESS;
+        p_ctx->prl.hs_state = PRL_HS_SEND_HELLO;
+        p_ctx->prl.alert_type = PRL_DEFAULT_ALERT;
+        return_status = IFX_I2C_STACK_SUCCESS;
+    } while (FALSE);
+    
+    return (return_status);
+}
+
+optiga_lib_status_t ifx_i2c_prl_close(ifx_i2c_context_t * p_ctx, ifx_i2c_event_handler_t handler)
+{
+    optiga_lib_status_t return_status = IFX_I2C_STACK_ERROR;
+    LOG_PRL("[IFX-PRL]: Close\n");
+    do
+    {
+        // Presentation Layer must be idle
+        if (PRL_STATE_IDLE != p_ctx->prl.state)
+        {
+            break;
+        }
+        p_ctx->prl.upper_layer_event_handler = handler;
+        if (IFX_I2C_SESSION_CONTEXT_NONE == p_ctx->manage_context_operation)
+        {
+            p_ctx->prl.upper_layer_event_handler(p_ctx, IFX_I2C_STACK_SUCCESS, 0, 0);
+            return_status = IFX_I2C_STACK_SUCCESS;
+            break;
+        }
+
+        if ((PRL_NEGOTIATION_DONE == p_ctx->prl.negotiation_state) &&
+            (IFX_I2C_SESSION_CONTEXT_SAVE == p_ctx->manage_context_operation))
+        {
+            p_ctx->prl.state = PRL_STATE_MANAGE_CONTEXT;
+            p_ctx->prl.mc_state = PRL_MANAGE_CONTEXT_TX_STATE;
+            ifx_i2c_prl_event_handler(p_ctx, IFX_I2C_STACK_SUCCESS, p_ctx->prl.prl_txrx_buffer, 1);
+            return_status = IFX_I2C_STACK_SUCCESS;
+            break;
+        }
+    } while (FALSE);
+    return (return_status);
+}
+
+optiga_lib_status_t ifx_i2c_prl_transceive(ifx_i2c_context_t * p_ctx,
+                                           uint8_t * p_tx_data,
+                                           uint16_t tx_data_len,
+                                           uint8_t * p_rx_data,
+                                           uint16_t * p_rx_data_len)
+{
+    optiga_lib_status_t return_status = IFX_I2C_STACK_ERROR;
+    LOG_PRL("[IFX-PRL]: Transceive txlen %d\n", tx_data_len);
+
+    do
+    {
+        // Check function arguments and presentation Layer must be idle
+        if ((NULL == p_tx_data) || (0 == tx_data_len) || (PRL_STATE_IDLE != p_ctx->prl.state))
+        {
+            break;
+        }
+
+        if ((IFX_I2C_SESSION_CONTEXT_RESTORE == p_ctx->manage_context_operation) && 
+            (PRL_RESTORE_NOT_DONE == p_ctx->prl.restore_context_flag))
+        {
+            p_ctx->prl.state = PRL_STATE_MANAGE_CONTEXT;
+            p_ctx->prl.mc_state = PRL_MANAGE_CONTEXT_TX_STATE;
+        }
+        else
+        {
+            p_ctx->prl.state = PRL_STATE_START;
+        }
+        p_ctx->prl.p_actual_payload = p_tx_data;
+        p_ctx->prl.actual_payload_length = tx_data_len;
+
+        if ((SLAVE_PROTECTION == (p_ctx->protection_level & PRL_PROTECTION_MASK)) ||
+            (FULL_PROTECTION == (p_ctx->protection_level & PRL_PROTECTION_MASK)))
+        {
+            p_ctx->prl.p_recv_payload_buffer = p_rx_data;
+        }
+        else
+        {
+            p_ctx->prl.p_recv_payload_buffer = &p_rx_data[PRL_PLAIN_TEST_OFFSET];
+        }
+        p_ctx->prl.p_recv_payload_buffer_length = p_rx_data_len;
+        p_ctx->prl.data_retransmit_counter = 0;
+        p_ctx->prl.trans_repeat_status = FALSE;
+        p_ctx->prl.decryption_failure_counter = 0;
+        p_ctx->prl.return_status = IFX_I2C_STACK_SUCCESS;
+        p_ctx->prl.alert_type = PRL_DEFAULT_ALERT;
+
+        ifx_i2c_prl_event_handler(p_ctx,
+                                  IFX_I2C_STACK_SUCCESS,
+                                  p_tx_data, tx_data_len);
+        return_status = IFX_I2C_STACK_SUCCESS;
+
+    } while (FALSE);
+    return (return_status);
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_prf(ifx_i2c_context_t * p_ctx)
+{
+    optiga_lib_status_t return_status = IFX_I2C_HANDSHAKE_ERROR;
+    uint8_t label_input[] = PRL_LABEL;
+    uint8_t secret_input[OPTIGA_SHARED_SECRET_MAX_LENGTH];
+    uint16_t shared_secret_length;
+    do
+    {
+        //Reading pre-shared secret from datastore
+        return_status = pal_os_datastore_read(p_ctx->ifx_i2c_datastore_config->datastore_shared_secret_id,
+                                              secret_input,
+                                              &shared_secret_length);
+        if (PAL_STATUS_SUCCESS != return_status)
+        {
+            return_status = IFX_I2C_HANDSHAKE_ERROR;
+            break;
+        }
+        if (PAL_STATUS_SUCCESS != pal_crypt_tls_prf_sha256(NULL, secret_input,
+                                                           shared_secret_length,
+                                                           label_input,
+                                                           sizeof(label_input) - 1,
+                                                           p_ctx->prl.random,
+                                                           sizeof(p_ctx->prl.random),
+                                                           p_ctx->prl.session_key,
+                                                           sizeof(p_ctx->prl.session_key)))
+        {
+            return_status = IFX_I2C_HANDSHAKE_ERROR;
+        }
+        memset(secret_input, 0, shared_secret_length);
+
+    } while (FALSE);
+    return (return_status);
+}
+
+_STATIC_H void ifx_i2c_prl_form_associated_data(ifx_i2c_context_t * p_ctx,
+                                                uint16_t data_len,
+                                                uint32_t seq_number,
+                                                uint8_t sctr)
+{
+    p_ctx->prl.associate_data[0] = sctr;
+    optiga_common_set_uint32(&p_ctx->prl.associate_data[1], seq_number);
+    p_ctx->prl.associate_data[5] = p_ctx->protocol_version;
+    optiga_common_set_uint16(&p_ctx->prl.associate_data[6], data_len);
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_encrypt_msg(ifx_i2c_context_t * p_ctx,
+                                                      uint8_t * p_data,
+                                                      uint16_t data_len,
+                                                      uint32_t seq_number,
+                                                      uint8_t sctr)
+{
+    optiga_lib_status_t return_status = IFX_I2C_STACK_ERROR;
+    uint8_t nonce_data[PRL_NONCE_LENGTH];
+    do
+    {
+        //Form associated data
+        ifx_i2c_prl_form_associated_data(p_ctx, data_len,seq_number,sctr);
+        //Prepare nonce data
+        memcpy(nonce_data, &p_ctx->prl.session_key[PRL_MASTER_ENCRYPTION_NONCE_OFFSET], PRL_MASTER_NONCE_LENGTH);
+        optiga_common_set_uint32(&nonce_data[PRL_MASTER_NONCE_LENGTH], seq_number);
+
+        if (PAL_STATUS_SUCCESS != (pal_crypt_encrypt_aes128_ccm(NULL,
+                                                                p_data,
+                                                                data_len,
+                                                                &p_ctx->prl.
+                                                                session_key[PRL_MASTER_ENCRYPTION_KEY_OFFSET],
+                                                                nonce_data, PRL_MASTER_NONCE_LENGTH + 
+                                                                PRL_SEQ_NUMBER_LENGTH,
+                                                                p_ctx->prl.associate_data,
+                                                                sizeof(p_ctx->prl.associate_data),
+                                                                IFX_I2C_PRL_MAC_SIZE,
+                                                                p_data)))
+        {
+            break;
+        }
+        return_status = IFX_I2C_STACK_SUCCESS;
+    } while (FALSE);
+    return (return_status);
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_decrypt_msg(ifx_i2c_context_t * p_ctx,
+                                                      const uint8_t * p_data,
+                                                      uint16_t data_len,
+                                                      uint32_t seq_number,
+                                                      uint8_t * out_data,
+                                                      uint8_t decrypt_key_offset,
+                                                      uint8_t decrypt_nonce_offset,
+                                                      uint8_t sctr)
+{
+    optiga_lib_status_t return_status = IFX_I2C_STACK_ERROR;
+    uint8_t nonce_data[PRL_NONCE_LENGTH];
+    do
+    {
+        //Form associated data
+        ifx_i2c_prl_form_associated_data(p_ctx, data_len, seq_number, sctr);
+        //Prepare nonce data
+        memcpy(nonce_data, &p_ctx->prl.session_key[decrypt_nonce_offset], PRL_MASTER_NONCE_LENGTH);
+        optiga_common_set_uint32(&nonce_data[PRL_MASTER_NONCE_LENGTH], seq_number);
+
+        if (PAL_STATUS_SUCCESS != (pal_crypt_decrypt_aes128_ccm(NULL,
+                                                                p_data,
+                                                                (data_len + IFX_I2C_PRL_MAC_SIZE),
+                                                                &p_ctx->prl.session_key[decrypt_key_offset],
+                                                                nonce_data,
+                                                                PRL_MASTER_NONCE_LENGTH + PRL_SEQ_NUMBER_LENGTH,
+                                                                p_ctx->prl.associate_data,
+                                                                sizeof(p_ctx->prl.associate_data),
+                                                                IFX_I2C_PRL_MAC_SIZE,
+                                                                out_data)))
+        {
+            break;
+        }
+        return_status = IFX_I2C_STACK_SUCCESS;
+    } while (FALSE);
+    return (return_status);
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_send_alert(ifx_i2c_context_t * p_ctx)
+{
+    optiga_lib_status_t return_status = IFX_I2C_STACK_SUCCESS;
+    do
+    {
+        p_ctx->prl.state = PRL_STATE_IDLE;
+        if (PRL_INTEGRITY_VIOLATED_ALERT_MSG == p_ctx->prl.alert_type)
+        {
+            p_ctx->prl.decryption_failure_counter++;
+            p_ctx->prl.state = PRL_STATE_VERIFY;
+            p_ctx->prl.return_status = IFX_I2C_STACK_SUCCESS;
+            //lint --e{835} suppress "Protection bits in SCTR is set to 0 for alert message"
+            FORM_SCTR_HEADER(p_ctx, PRL_ALERT_PROTOCOL, p_ctx->prl.alert_type, 0);
+            p_ctx->prl.prl_txrx_buffer[0] = p_ctx->prl.sctr;
+            return_status = ifx_i2c_tl_transceive(p_ctx,
+                                                  p_ctx->prl.prl_txrx_buffer,
+                                                  1,
+                                                  p_ctx->prl.p_recv_payload_buffer,
+                                                  &p_ctx->prl.prl_receive_length);
+            *p_ctx->prl.p_recv_payload_buffer_length = p_ctx->prl.prl_receive_length;
+        }
+        else
+        {
+            p_ctx->prl.return_status = IFX_I2C_SESSION_ERROR;
+            p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+            p_ctx->prl.alert_type = PRL_INVALID_ALERT;
+            break;
+        }
+
+    } while (FALSE);
+    return (return_status);
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_do_handshake(ifx_i2c_context_t * p_ctx, const uint8_t * p_data)
+{
+    uint8_t sseq[4];
+    optiga_lib_status_t return_status = IFX_I2C_STACK_ERROR;
+    uint32_t exit_machine = FALSE;
+    LOG_PRL("[IFX-PRL]: Do Handshake \n");
+
+    do
+    {
+        switch (p_ctx->prl.hs_state)
+        {
+            case PRL_HS_SEND_HELLO:
+            {
+                //Preparing hello message
+                //lint --e{835} suppress "Protection bits in SCTR is set to 0 for hello message"
+                FORM_SCTR_HEADER(p_ctx,PRL_HANDSHAKE_PROTOCOL, PRL_MASTER_HELLO_MSG, 0);
+                p_ctx->prl.prl_txrx_buffer[PRL_SCTR_OFFSET] = p_ctx->prl.sctr;
+                p_ctx->prl.prl_txrx_buffer[PRL_PROTOCOL_VERSION_OFFSET] = p_ctx->protocol_version;
+                p_ctx->prl.prl_receive_length = PRL_SLAVE_HELLO_LENGTH;
+                //Sending hello message
+                return_status = ifx_i2c_tl_transceive(p_ctx,
+                                                      p_ctx->prl.prl_txrx_buffer,
+                                                      2,
+                                                      p_ctx->prl.prl_txrx_buffer,
+                                                      &p_ctx->prl.prl_receive_length);
+                if (IFX_I2C_STACK_ERROR == return_status)
+                {
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    exit_machine = TRUE;
+                    break;
+                }
+                p_ctx->prl.hs_state = PRL_HS_VERIFY_HELLO;
+            }
+            break;
+            case PRL_HS_VERIFY_HELLO:
+            {
+                exit_machine = TRUE;
+                 //lint --e{835} suppress "Macros are defined as 0x00 and is kept for future enhancements"
+                if ((((p_data[PRL_SCTR_OFFSET] & (PRL_ALERT_PROTOCOL | PRL_FATAL_ALERT_MSG)) ||
+                    (p_data[PRL_SCTR_OFFSET] & (PRL_ALERT_PROTOCOL | PRL_INTEGRITY_VIOLATED_ALERT_MSG))) &&
+                    (1 == p_ctx->prl.prl_receive_length)))
+                {
+                    return_status = IFX_I2C_HANDSHAKE_ERROR;
+                    p_ctx->prl.alert_type = PRL_INVALID_ALERT;
+                    exit_machine = FALSE;
+                    break;
+                }
+                //Check valid message type and protocol version
+                if ((PRL_SLAVE_HELLO_LENGTH != p_ctx->prl.prl_receive_length) || (0 != p_data[PRL_SCTR_OFFSET]) ||
+                    (PROTOCOL_VERSION_PRE_SHARED_SECRET != p_data[PRL_PROTOCOL_VERSION_OFFSET]))
+                {
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    break;
+                }
+                //Store slave sequence number and random number
+                p_ctx->prl.slave_sequence_number = optiga_common_get_uint32(&p_data[PRL_SLAVE_HELLO_SEQ_NUMBER_OFFSET]);
+                p_ctx->prl.save_slave_sequence_number = p_ctx->prl.slave_sequence_number;
+                memcpy(p_ctx->prl.random, &p_data[PRL_RANDOM_DATAOFFSET], PRL_RANDOM_DATA_LENGTH);
+
+                //Generating session key
+                return_status = ifx_i2c_prl_prf(p_ctx);
+                if (IFX_I2C_HANDSHAKE_ERROR == return_status)
+                {
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    break;
+                }
+                p_ctx->prl.hs_state = PRL_HS_SEND_FINISHED;
+
+            }
+            break;
+            case PRL_HS_SEND_FINISHED:
+            {
+                //lint --e{835} suppress "Protection bits in SCTR is set to 0 for hello finished message"
+                FORM_SCTR_HEADER(p_ctx, PRL_HANDSHAKE_PROTOCOL, PRL_MASTER_FINISHED_MSG,0);
+                exit_machine = FALSE;
+                //Creating payload for encryption
+                memcpy(&p_ctx->prl.prl_txrx_buffer[IFX_I2C_PRL_HEADER_SIZE] ,p_ctx->prl.random, PRL_RANDOM_DATA_LENGTH);
+                optiga_common_set_uint32(&p_ctx->prl.prl_txrx_buffer[PRL_RANDOM_DATA_LENGTH + IFX_I2C_PRL_HEADER_SIZE],
+                                         p_ctx->prl.slave_sequence_number);
+
+                //Preparing encryption data
+                return_status = ifx_i2c_prl_encrypt_msg(p_ctx,
+                                                        &p_ctx->prl.prl_txrx_buffer[IFX_I2C_PRL_HEADER_SIZE],
+                                                        PRL_RANDOM_DATA_LENGTH + PRL_SEQ_NUMBER_LENGTH,
+                                                        p_ctx->prl.slave_sequence_number,
+                                                        p_ctx->prl.sctr);
+                if (IFX_I2C_STACK_ERROR == return_status)
+                {
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    exit_machine = TRUE;
+                    break;
+                }
+
+                //Append presentation layer header
+                p_ctx->prl.prl_txrx_buffer[PRL_SCTR_OFFSET] = p_ctx->prl.sctr;
+                optiga_common_set_uint32(&p_ctx->prl.prl_txrx_buffer[1], p_ctx->prl.slave_sequence_number);
+
+                p_ctx->prl.prl_receive_length = PRL_FINISHED_DATA_LENGTH + 1;
+                return_status = ifx_i2c_tl_transceive(p_ctx,
+                                                      p_ctx->prl.prl_txrx_buffer,
+                                                      PRL_FINISHED_DATA_LENGTH + 1,
+                                                      p_ctx->prl.prl_txrx_buffer,
+                                                      &p_ctx->prl.prl_receive_length);
+                if (IFX_I2C_STACK_SUCCESS != return_status)
+                {
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    exit_machine = TRUE;
+                    break;
+                }
+                p_ctx->prl.hs_state = PRL_HS_VERIFY_FINISHED;
+            }
+            break;
+            case PRL_HS_VERIFY_FINISHED:
+            {
+                if ((PRL_MASTER_FINISHED_MSG != p_data[PRL_SCTR_OFFSET]) ||
+                    ((PRL_FINISHED_DATA_LENGTH + 1) != p_ctx->prl.prl_receive_length))
+                {
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    exit_machine = TRUE;
+                    break;
+                }
+                p_ctx->prl.master_sequence_number = optiga_common_get_uint32(&p_data[1]);
+                return_status = ifx_i2c_prl_decrypt_msg(p_ctx,
+                                                        &p_data[IFX_I2C_PRL_HEADER_SIZE],
+                                                        PRL_RANDOM_DATA_LENGTH + PRL_SEQ_NUMBER_LENGTH,
+                                                        p_ctx->prl.master_sequence_number,
+                                                        p_ctx->prl.prl_txrx_buffer,
+                                                        PRL_MASTER_DECRYPTION_KEY_OFFSET,
+                                                        PRL_MASTER_DECRYPTION_NONCE_OFFSET,
+                                                        p_ctx->prl.sctr);
+                if (IFX_I2C_STACK_ERROR == return_status)
+                {
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    exit_machine = TRUE;
+                    break;
+                }
+                optiga_common_set_uint32(sseq, p_ctx->prl.master_sequence_number);
+                ///Validating decrpt data
+                if (0 != (memcmp(p_ctx->prl.random, p_ctx->prl.prl_txrx_buffer, PRL_RANDOM_DATA_LENGTH)))
+                {
+                    return_status = IFX_I2C_HANDSHAKE_ERROR;
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    exit_machine = TRUE;
+                    break;
+                }
+                ///Validating sequence number
+                if (0 != (memcmp(sseq, &p_ctx->prl.prl_txrx_buffer[PRL_RANDOM_DATA_LENGTH], PRL_SEQ_NUMBER_LENGTH)))
+                {
+                    return_status = IFX_I2C_HANDSHAKE_ERROR;
+                    p_ctx->prl.hs_state = PRL_HS_ERROR;
+                    exit_machine = TRUE;
+                    break;
+                }
+                p_ctx->prl.negotiation_state = PRL_NEGOTIATION_DONE;
+            }
+            break;
+            case PRL_HS_ERROR:
+            {
+                return_status = IFX_I2C_HANDSHAKE_ERROR;
+                p_ctx->prl.alert_type = PRL_INVALID_ALERT;
+                exit_machine = FALSE;
+            }
+            break;
+            default:
+            break;
+        }
+
+    } while (TRUE == exit_machine);
+
+    return (return_status);
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_prl_do_manage_context(ifx_i2c_context_t * p_ctx,
+                                                            const uint8_t * p_data,
+                                                            uint16_t data_len,
+                                                            uint8_t * exit_machine)
+{
+    ifx_i2c_prl_manage_context_t prl_saved_ctx;
+    optiga_lib_status_t return_status = IFX_I2C_STACK_ERROR;
+    uint8_t sctr;
+
+    switch (p_ctx->prl.mc_state)
+    {
+        case PRL_MANAGE_CONTEXT_TX_STATE:
+        {
+            LOG_PRL("[IFX-PRL]: PRL_STATE_MANAGE_CONTEXT \n");
+            if (0 != (p_ctx->protection_level & RE_ESTABLISH))
+            {
+                p_ctx->prl.state = PRL_STATE_START;
+                return_status = IFX_I2C_STACK_SUCCESS;
+                break;
+            }
+
+            if (IFX_I2C_SESSION_CONTEXT_SAVE == p_ctx->manage_context_operation)
+            {
+                p_ctx->prl.prl_txrx_buffer[0] = PRL_SAVE_CONTEXT_MSG;
+                p_ctx->prl.prl_receive_length = 1;
+                p_ctx->prl.prl_txrx_receive_length = 1;
+            }
+            else if (IFX_I2C_SESSION_CONTEXT_RESTORE == p_ctx->manage_context_operation)
+            {
+                /// Restoring saved context from data store
+                if (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id)
+                {
+                    p_ctx->prl.prl_receive_length = sizeof(p_ctx->prl.prl_saved_ctx);
+                    return_status = pal_os_datastore_read(p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id,
+                                                          (uint8_t * )&p_ctx->prl.prl_saved_ctx,
+                                                          &p_ctx->prl.prl_receive_length);
+                    if (PAL_STATUS_FAILURE == return_status)
+                    {
+                        break;
+                    }
+                    p_ctx->prl.negotiation_state = p_ctx->prl.prl_saved_ctx.negotiation_state;
+                    if (p_ctx->prl.prl_saved_ctx.stored_context_flag == FALSE)
+                    {
+                        p_ctx->prl.state = PRL_STATE_START;
+                        p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+                        p_ctx->prl.restore_context_flag = PRL_RESTORE_DONE;
+                        *exit_machine = TRUE;
+                        return_status = IFX_I2C_STACK_SUCCESS;
+                        break;
+                    }
+                }
+                else
+                {
+                    if (p_ctx->prl.prl_saved_ctx.stored_context_flag == FALSE)
+                    {
+                        p_ctx->prl.state = PRL_STATE_START;
+                        p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+                        p_ctx->prl.restore_context_flag = PRL_RESTORE_DONE;
+                        *exit_machine = TRUE;
+                        return_status = IFX_I2C_STACK_SUCCESS;
+                        break;
+                    }
+                    else
+                    {
+                        p_ctx->prl.negotiation_state = p_ctx->prl.prl_saved_ctx.negotiation_state;
+                    }
+                }
+                ///Prepare restore message
+                p_ctx->prl.prl_txrx_buffer[PRL_SCTR_OFFSET] = PRL_RESTORE_CONTEXT_MSG;
+                optiga_common_set_uint32(&p_ctx->prl.prl_txrx_buffer[1], 
+                                         p_ctx->prl.prl_saved_ctx.save_slave_sequence_number);
+                p_ctx->prl.prl_txrx_receive_length = 5;
+                prl_saved_ctx.stored_context_flag = FALSE;
+                p_ctx->prl.prl_receive_length = 5;
+                p_ctx->prl.prl_saved_ctx.stored_context_flag = FALSE;
+                ///Clearing the saved context in data store
+                if (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id)
+                {
+                    memset((uint8_t * )&prl_saved_ctx,0,sizeof(prl_saved_ctx));
+                    return_status = pal_os_datastore_write(p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id,
+                                                           (uint8_t * )&prl_saved_ctx,
+                                                           sizeof(prl_saved_ctx));
+                    if (PAL_STATUS_FAILURE == return_status)
+                    {
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                /// Message type invalid
+                p_ctx->prl.alert_type = PRL_INVALID_ALERT;
+                p_ctx->prl.state = PRL_STATE_ERROR;
+                p_ctx->prl.return_status = IFX_I2C_STACK_ERROR;
+                break;
+            }
+            return_status = ifx_i2c_tl_transceive(p_ctx,
+                                                  p_ctx->prl.prl_txrx_buffer,
+                                                  p_ctx->prl.prl_txrx_receive_length,
+                                                  p_ctx->prl.prl_txrx_buffer,
+                                                  &p_ctx->prl.prl_receive_length);
+            if (IFX_I2C_STACK_SUCCESS != return_status)
+            {
+                break;
+            }
+            p_ctx->prl.mc_state = PRL_MANAGE_CONTEXT_RX_STATE;
+            return_status = IFX_I2C_STACK_SUCCESS;
+            *exit_machine = FALSE;
+        }
+        break;
+        case PRL_MANAGE_CONTEXT_RX_STATE:
+        {
+            *exit_machine = TRUE;
+            sctr = p_data[PRL_SCTR_OFFSET] & PRL_MANAGE_CONTEXT_MASK;
+            if ((PRL_CONTEXT_RESTORED_MSG == sctr) &&
+                (IFX_I2C_SESSION_CONTEXT_RESTORE == p_ctx->manage_context_operation) && (5 == data_len))
+            {
+                ///Restore the saved context to active context structure
+                COPY_MANAGE_CONTEXT_DATA(p_ctx->prl.prl_saved_ctx,p_ctx->prl);
+                p_ctx->prl.restore_context_flag = PRL_RESTORE_DONE;
+                p_ctx->prl.state = PRL_STATE_TXRX;
+            }
+            else if ((PRL_CONTEXT_SAVED_MSG == sctr) &&
+                     (IFX_I2C_SESSION_CONTEXT_SAVE == p_ctx->manage_context_operation) && (1 == data_len))
+            {
+                p_ctx->prl.prl_saved_ctx.stored_context_flag = TRUE;
+                COPY_MANAGE_CONTEXT_DATA(p_ctx->prl, p_ctx->prl.prl_saved_ctx);
+                
+                if (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id)
+                {
+                    ///Store active session to data store
+                    p_ctx->prl.prl_receive_length = sizeof(p_ctx->prl.prl_saved_ctx);
+                    return_status = pal_os_datastore_write(p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id,
+                                                           (uint8_t * )&p_ctx->prl.prl_saved_ctx,
+                                                           p_ctx->prl.prl_receive_length);
+                    if (PAL_STATUS_SUCCESS != return_status)
+                    {
+                        ERROR_STATE_PREPARATION(p_ctx,*exit_machine);
+                        break;
+                    }
+                }
+                ///Clearing the active session
+                CLEAR_SESSION_CONTEXT(p_ctx);
+                p_ctx->prl.state = PRL_STATE_IDLE;
+            }
+            else
+            {
+                memset((uint8_t * )&p_ctx->prl.prl_saved_ctx,0,sizeof(p_ctx->prl.prl_saved_ctx));
+                if (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id)
+                {
+                    return_status = pal_os_datastore_write(p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id,
+                                                           (uint8_t * )&p_ctx->prl.prl_saved_ctx,
+                                                           sizeof(p_ctx->prl.prl_saved_ctx));
+                }
+                //lint --e{838} suppress "return_status is ignored for pal_os_datastore_write as it's an error scenario"
+                return_status = IFX_I2C_STACK_ERROR;
+                break;
+            }
+            p_ctx->prl.return_status = IFX_I2C_STACK_SUCCESS;
+            return_status = IFX_I2C_STACK_SUCCESS;
+        }
+        break;
+        default:
+        {
+            ERROR_STATE_PREPARATION(p_ctx,*exit_machine);
+        }
+        break;
+    }
+  return (return_status);
+}
+
+_STATIC_H void ifx_i2c_prl_event_handler(ifx_i2c_context_t * p_ctx,
+                                         optiga_lib_status_t event,
+                                         const uint8_t * p_data,
+                                         uint16_t data_len)
+{
+    //if handshake
+    uint8_t exit_machine = TRUE;
+    ifx_i2c_prl_manage_context_t prl_saved_ctx;
+    optiga_lib_status_t return_status = IFX_I2C_STACK_ERROR;
+
+    LOG_PRL("[IFX-PRL]: ifx_i2c_prl_event_handler %d\n", data_len);
+    if ((0 != (event & IFX_I2C_STACK_MEM_ERROR)) || (0 != (event & IFX_I2C_STACK_ERROR)))
+    {
+        p_ctx->prl.alert_type = PRL_INVALID_ALERT;
+        if (PRL_STATE_HANDSHAKE == p_ctx->prl.state)
+        {
+            p_ctx->prl.return_status = IFX_I2C_HANDSHAKE_ERROR;
+        }
+        else if ((PRL_NEGOTIATION_DONE == p_ctx->prl.negotiation_state) && (IFX_I2C_STACK_MEM_ERROR != event))
+        {
+            p_ctx->prl.return_status = IFX_I2C_SESSION_ERROR;
+            p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+        }
+        else
+        {
+            p_ctx->prl.return_status = event;
+        }
+        p_ctx->prl.state = PRL_STATE_ERROR;
+    }
+
+    do
+    {
+        //exit_machine = FALSE;
+        switch (p_ctx->prl.state)
+        {
+            case PRL_STATE_IDLE:
+            {
+                LOG_PRL("[IFX-PRL]: PRL_STATE_IDLE %d\n", p_ctx->prl.return_status);
+                p_ctx->prl.upper_layer_event_handler(p_ctx, p_ctx->prl.return_status, 0, 0);
+                exit_machine = FALSE;
+            }
+            break;
+            case PRL_STATE_MANAGE_CONTEXT:
+            {
+                LOG_PRL("[IFX-PRL]: PRL_STATE_MANAGE_CONTEXT \n");
+                return_status = ifx_i2c_prl_do_manage_context(p_ctx, p_data,data_len,&exit_machine);
+                if (IFX_I2C_STACK_SUCCESS != return_status)
+                {
+                  ERROR_STATE_PREPARATION(p_ctx,exit_machine);
+                }
+            }
+            break;
+            case PRL_STATE_START:
+            {
+                if (((p_ctx->protection_level & RE_ESTABLISH) ||
+                    ((p_ctx->protection_level != NO_PROTECTION ) &&
+                    (PRL_NEGOTIATION_NOT_DONE == p_ctx->prl.negotiation_state))))
+                {
+                    p_ctx->prl.state =  PRL_STATE_HANDSHAKE;
+                    p_ctx->prl.hs_state = PRL_HS_SEND_HELLO;
+                    p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+                }
+                else
+                {
+                    p_ctx->prl.state =  PRL_STATE_TXRX;
+                }
+            }
+            break;
+            case PRL_STATE_HANDSHAKE:
+            {
+                ///Clearing the saved context in data store
+                CLEAR_SAVED_SESSION_CONTEXT(p_ctx->prl.prl_saved_ctx);
+                memset((uint8_t * )&prl_saved_ctx,0,sizeof(prl_saved_ctx));
+                if (OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED != p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id)
+                {
+                    return_status = pal_os_datastore_write(p_ctx->ifx_i2c_datastore_config->datastore_manage_context_id,
+                                                           (uint8_t * )&prl_saved_ctx,
+                                                           sizeof(prl_saved_ctx));
+                    if (PAL_STATUS_SUCCESS != return_status)
+                    {
+                        ERROR_STATE_PREPARATION(p_ctx,exit_machine);
+                        p_ctx->prl.return_status = IFX_I2C_HANDSHAKE_ERROR;
+                        break;
+                    }
+                }
+                return_status = ifx_i2c_prl_do_handshake(p_ctx,p_data);
+                if (IFX_I2C_HANDSHAKE_ERROR == return_status)
+                {
+                    p_ctx->prl.return_status = return_status;
+                    p_ctx->prl.state = PRL_STATE_ERROR;
+                    break;
+                }
+
+                if (PRL_NEGOTIATION_DONE == p_ctx->prl.negotiation_state)
+                {
+                    p_ctx->prl.state = PRL_STATE_TXRX;
+                }
+                else
+                {
+                    exit_machine = FALSE;
+                }
+            }
+            break;
+            case PRL_STATE_TXRX:
+            {
+                //lint --e{835} suppress "Message bits in SCTR is set to 0 for record transaction"
+                FORM_SCTR_HEADER(p_ctx,
+                                 PRL_RECORD_EXCHANGE_PROTOCOL,
+                                 0,
+                                 (p_ctx->protection_level & PRL_PROTECTION_MASK));
+                ///Preparing receive length based on the protection level
+                if ((SLAVE_PROTECTION == (p_ctx->protection_level & PRL_PROTECTION_MASK)) ||
+                    (FULL_PROTECTION == (p_ctx->protection_level & PRL_PROTECTION_MASK)))
+                {
+                    if ((PRL_SEQUENCE_THRESHOLD < (p_ctx->prl.save_slave_sequence_number + 1)) &&
+                        (FALSE == p_ctx->prl.trans_repeat_status))
+                    {
+                        DO_NEGOTIATION(p_ctx,exit_machine);
+                        break;
+                    }
+                    *p_ctx->prl.p_recv_payload_buffer_length += (IFX_I2C_PRL_MAC_SIZE + IFX_I2C_PRL_HEADER_SIZE);
+                }
+                p_ctx->prl.saved_sctr = p_ctx->prl.sctr;
+
+                if ((MASTER_PROTECTION == (p_ctx->protection_level & PRL_PROTECTION_MASK)) ||
+                    (FULL_PROTECTION == (p_ctx->protection_level & PRL_PROTECTION_MASK)))
+                {
+                    if ((PRL_SEQUENCE_THRESHOLD < (p_ctx->prl.master_sequence_number + 1)) &&
+                        (FALSE == p_ctx->prl.trans_repeat_status))
+                    {
+                        DO_NEGOTIATION(p_ctx,exit_machine);
+                        break;
+                    }
+                    ///Decrypt messag to use for retansmit
+                    if (PRL_INTEGRITY_VIOLATED_ALERT_MSG == p_ctx->prl.alert_type)
+                    {
+                        return_status = ifx_i2c_prl_decrypt_msg(p_ctx,
+                                                                &p_ctx->prl.p_actual_payload[IFX_I2C_PRL_HEADER_SIZE],
+                                                                p_ctx->prl.actual_payload_length,
+                                                                p_ctx->prl.master_sequence_number,
+                                                                &p_ctx->prl.p_actual_payload[IFX_I2C_PRL_HEADER_SIZE],
+                                                                PRL_MASTER_ENCRYPTION_KEY_OFFSET,
+                                                                PRL_MASTER_ENCRYPTION_NONCE_OFFSET,
+                                                                p_ctx->prl.saved_sctr);
+                        if (IFX_I2C_STACK_ERROR == return_status)
+                        {
+                            ERROR_STATE_PREPARATION(p_ctx,exit_machine);
+                            break;
+                        }
+                        *p_ctx->prl.p_recv_payload_buffer_length = p_ctx->prl.prl_receive_length;
+                    }
+
+                    p_ctx->prl.master_sequence_number += 1;
+                    p_ctx->prl.prl_header_offset = IFX_I2C_PRL_HEADER_SIZE;
+                    optiga_common_set_uint32(&p_ctx->prl.p_actual_payload[1], p_ctx->prl.master_sequence_number);
+                    //Preparing encription data
+                    return_status = ifx_i2c_prl_encrypt_msg(p_ctx,
+                                                            &p_ctx->prl.p_actual_payload[IFX_I2C_PRL_HEADER_SIZE],
+                                                            p_ctx->prl.actual_payload_length,
+                                                            p_ctx->prl.master_sequence_number,
+                                                            p_ctx->prl.saved_sctr);
+                    if (IFX_I2C_STACK_ERROR == return_status)
+                    {
+                        ERROR_STATE_PREPARATION(p_ctx,exit_machine);
+                        break;
+                    }
+                    p_ctx->prl.p_actual_payload[PRL_SCTR_OFFSET] = p_ctx->prl.sctr;
+                    return_status = ifx_i2c_tl_transceive(p_ctx,
+                                                          p_ctx->prl.p_actual_payload,
+                                                          p_ctx->prl.actual_payload_length + 
+                                                          p_ctx->prl.prl_header_offset + IFX_I2C_PRL_MAC_SIZE,
+                                                          p_ctx->prl.p_recv_payload_buffer,
+                                                          p_ctx->prl.p_recv_payload_buffer_length);
+                }
+                else
+                {
+                    ///Sending plan data
+                    p_ctx->prl.prl_header_offset = 1;
+                    p_ctx->prl.p_actual_payload[4] = p_ctx->prl.sctr;
+                    return_status = ifx_i2c_tl_transceive(p_ctx,
+                                                          &p_ctx->prl.p_actual_payload[4],
+                                                          p_ctx->prl.actual_payload_length + 
+                                                          p_ctx->prl.prl_header_offset,
+                                                          p_ctx->prl.p_recv_payload_buffer,
+                                                          p_ctx->prl.p_recv_payload_buffer_length);
+                }
+                if (IFX_I2C_STACK_ERROR == return_status)
+                {
+                    ERROR_STATE_PREPARATION(p_ctx,  exit_machine);
+                    p_ctx->prl.return_status = IFX_I2C_STACK_ERROR;
+                    break;
+                }
+                p_ctx->prl.prl_receive_length = *p_ctx->prl.p_recv_payload_buffer_length;
+                p_ctx->prl.state = PRL_STATE_VERIFY;
+                exit_machine = FALSE;
+            }
+            break;
+            case PRL_STATE_VERIFY:
+            {
+                p_ctx->prl.slave_sequence_number = optiga_common_get_uint32(&p_ctx->prl.p_recv_payload_buffer[1]);
+                if (0 == data_len)
+                {
+                    ERROR_STATE_PREPARATION(p_ctx,exit_machine);
+                    break;
+                }
+                else if (0 != (p_data[PRL_SCTR_OFFSET] & PRL_ALERT_PROTOCOL))
+                {
+                    //Check invalid message
+                    //lint --e{835} suppress "Macros are defined as 0x00 and is kept for future enhancements"
+                    if (((p_data[PRL_SCTR_OFFSET] != (PRL_ALERT_PROTOCOL | PRL_FATAL_ALERT_MSG)) &&
+                        (p_data[PRL_SCTR_OFFSET] != (PRL_ALERT_PROTOCOL | PRL_INTEGRITY_VIOLATED_ALERT_MSG))) ||
+                        ((1 != data_len) && (PRL_NEGOTIATION_DONE == p_ctx->prl.negotiation_state)) ||
+                        (PRL_TRANS_REPEAT == p_ctx->prl.data_retransmit_counter))
+                    {
+                        p_ctx->prl.return_status = IFX_I2C_SESSION_ERROR;
+                        p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+                    }
+                    //After restore operation if invalid message received
+                    else if ((PRL_RESTORE_DONE == p_ctx->prl.restore_context_flag) &&
+                             (IFX_I2C_SESSION_CONTEXT_RESTORE == p_ctx->manage_context_operation))
+                    {
+                        p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+                        p_ctx->prl.return_status = IFX_I2C_SESSION_ERROR;
+                    }
+                    else
+                    {
+                        p_ctx->prl.return_status = IFX_I2C_STACK_ERROR;
+                    }
+                    p_ctx->prl.state = PRL_STATE_ALERT;
+                    p_ctx->prl.alert_type = PRL_INVALID_ALERT;
+                }
+                ///Sctr value mismatch
+                else if (p_data[PRL_SCTR_OFFSET] != p_ctx->prl.saved_sctr)
+                {
+                    ERROR_STATE_PREPARATION(p_ctx, exit_machine);
+                    break;
+                }
+                ///For slave encrypted message
+                else if (((uint8_t)SLAVE_PROTECTION == (p_data[PRL_SCTR_OFFSET] & PRL_PROTECTION_MASK)) ||
+                         ((uint8_t)FULL_PROTECTION == (p_data[PRL_SCTR_OFFSET] & PRL_PROTECTION_MASK)))
+                {
+                    if (data_len <= (IFX_I2C_PRL_HEADER_SIZE + IFX_I2C_PRL_MAC_SIZE))
+                    {
+                        ERROR_STATE_PREPARATION(p_ctx, exit_machine);
+                        break;
+                    }
+                    //Check invalid sequence number
+                    else if ((p_ctx->prl.slave_sequence_number > (p_ctx->prl.save_slave_sequence_number + PRL_TRANS_REPEAT))
+                             || (p_ctx->prl.slave_sequence_number <= p_ctx->prl.save_slave_sequence_number ))
+                    {
+                        ERROR_STATE_PREPARATION(p_ctx,exit_machine);
+                        break;
+                    }
+
+                    p_ctx->prl.save_slave_sequence_number = p_ctx->prl.slave_sequence_number;
+                    *p_ctx->prl.p_recv_payload_buffer_length = *p_ctx->prl.p_recv_payload_buffer_length -
+                                                               (IFX_I2C_PRL_MAC_SIZE + IFX_I2C_PRL_HEADER_SIZE);
+                    return_status = ifx_i2c_prl_decrypt_msg(p_ctx,
+                                                            &p_ctx->prl.p_recv_payload_buffer[IFX_I2C_PRL_HEADER_SIZE],
+                                                            (*p_ctx->prl.p_recv_payload_buffer_length),
+                                                            p_ctx->prl.slave_sequence_number,
+                                                            &p_ctx->prl.p_recv_payload_buffer[IFX_I2C_PRL_HEADER_SIZE],
+                                                            PRL_MASTER_DECRYPTION_KEY_OFFSET,
+                                                            PRL_MASTER_DECRYPTION_NONCE_OFFSET,
+                                                            p_ctx->prl.saved_sctr);
+                    if (IFX_I2C_STACK_ERROR == return_status)
+                    {
+                        p_ctx->prl.state = PRL_STATE_ALERT;
+                        p_ctx->prl.alert_type = PRL_INTEGRITY_VIOLATED_ALERT_MSG;
+                        break;
+                    }
+                    else
+                    {
+                        p_ctx->prl.return_status = IFX_I2C_STACK_SUCCESS;
+                        p_ctx->prl.state = PRL_STATE_IDLE;
+                    }
+                }
+                else if (data_len <= 1)
+                {
+                    p_ctx->prl.state = PRL_STATE_ERROR;
+                    p_ctx->prl.alert_type = PRL_INVALID_ALERT;
+                    if (PRL_NEGOTIATION_NOT_DONE == p_ctx->prl.negotiation_state)
+                    {
+                        p_ctx->prl.return_status = IFX_I2C_STACK_ERROR;
+                    }
+                    else
+                    {
+                        p_ctx->prl.return_status = IFX_I2C_SESSION_ERROR;
+                        p_ctx->prl.negotiation_state = PRL_NEGOTIATION_NOT_DONE;
+                    }
+                }
+                else
+                {
+                    *p_ctx->prl.p_recv_payload_buffer_length -= 1;
+                    p_ctx->prl.return_status = IFX_I2C_STACK_SUCCESS;
+                    p_ctx->prl.state = PRL_STATE_IDLE;
+                }
+            }
+            break;
+            case PRL_STATE_ALERT:
+            {
+                if ((PRL_INTEGRITY_VIOLATED_ALERT_MSG | PRL_ALERT_PROTOCOL) == p_data[PRL_SCTR_OFFSET])
+                {
+                    if ((1 !=  data_len) || (p_ctx->prl.data_retransmit_counter >= PRL_TRANS_REPEAT))
+                    {
+                        ERROR_STATE_PREPARATION(p_ctx,exit_machine);
+                        break;
+                    }
+                    else if ((MASTER_PROTECTION == p_ctx->protection_level) ||
+                             (FULL_PROTECTION == p_ctx->protection_level))
+                    {
+                        p_ctx->prl.data_retransmit_counter++;
+                        p_ctx->prl.trans_repeat_status = TRUE;
+                        if (p_ctx->prl.data_retransmit_counter > PRL_TRANS_REPEAT)
+                        {
+                            ERROR_STATE_PREPARATION(p_ctx, exit_machine);
+                            p_ctx->prl.state = PRL_STATE_IDLE;
+                            break;
+                        }
+                        p_ctx->prl.alert_type = PRL_INTEGRITY_VIOLATED_ALERT_MSG;
+                        p_ctx->prl.state = PRL_STATE_TXRX;
+                    }
+                    else
+                    {
+                      p_ctx->prl.state = PRL_STATE_ERROR;
+                    }
+                }
+                else
+                {
+                    if (PRL_TRANS_REPEAT == p_ctx->prl.decryption_failure_counter)
+                    {
+                      ERROR_STATE_PREPARATION(p_ctx, exit_machine);
+                    }
+                    p_ctx->prl.state = PRL_STATE_ERROR;
+                }
+            }
+            break;
+            case PRL_STATE_ERROR:
+            {
+                if (PRL_INVALID_ALERT != p_ctx->prl.alert_type)
+                {
+                    return_status = ifx_i2c_prl_send_alert(p_ctx);
+                    p_ctx->prl.alert_type = (uint8_t)PRL_INVALID_ALERT;
+                    exit_machine = FALSE;
+                }
+                else
+                {
+                    p_ctx->prl.state = PRL_STATE_IDLE;
+                }
+            }
+            break;
+            default:
+            {
+                p_ctx->prl.state = PRL_STATE_IDLE;
+                p_ctx->prl.upper_layer_event_handler(p_ctx, IFX_I2C_STACK_ERROR, 0, 0);
+                exit_machine = FALSE;
+            }
+            break;
+        }
+    } while (TRUE == exit_machine);
+}
+#endif
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_transport_layer.c b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_transport_layer.c
new file mode 100644
index 000000000..a171cf3a9
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/comms/ifx_i2c/ifx_i2c_transport_layer.c
@@ -0,0 +1,569 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_transport_layer.c
+*
+* \brief   This file implements the APIs for transport layer of the Infineon I2C Protocol Stack library.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+#include "optiga/ifx_i2c/ifx_i2c_transport_layer.h"
+#include "optiga/ifx_i2c/ifx_i2c_data_link_layer.h" // include lower layer header
+
+/// @cond hidden
+
+// Transport Layer states
+#define TL_STATE_UNINIT                     (0x00)
+#define TL_STATE_IDLE                       (0x01)
+#define TL_STATE_TX                         (0x02)
+#define TL_STATE_RX                         (0x04)
+#define TL_STATE_CHAINING                   (0x05)
+#define TL_STATE_ERROR                      (0x06)
+#define TL_STATE_CHAINING_ERROR             (0x07)
+#define TL_STATE_RESEND                     (0x08)
+
+
+// Transport Layer chaining values
+#define TL_CHAINING_NO                      (0x00)
+#define TL_CHAINING_FIRST                   (0x01)
+#define TL_CHAINING_INTERMEDIATE            (0x02)
+#define TL_CHAINING_LAST                    (0x04)
+#define TL_CHAINING_ERROR                   (0x07)
+
+#define TL_PCTR_CHANNEL_MASK                (0xF8)
+#define TL_PCTR_CHAIN_MASK                  (0x07)
+#define TL_PCTR_INVALID                     (0xFF)
+#define TL_PREVIOUS_CHAINING_STATUS         (0x02)
+#define TL_CURRENT_CHAINING_STATUS          (0x08)
+// Setup debug log statements
+#if IFX_I2C_LOG_TL == 1
+#define LOG_TL IFX_I2C_LOG
+#else
+#define LOG_TL(...)    //printf(__VA_ARGS__);
+#endif
+
+static const uint8_t g_pctr_states_table[TL_CURRENT_CHAINING_STATUS][TL_PREVIOUS_CHAINING_STATUS] = {
+                                                                                              {TL_CHAINING_NO, TL_CHAINING_LAST},
+                                                                                              {TL_CHAINING_NO, TL_CHAINING_LAST},
+                                                                                              {TL_CHAINING_FIRST, TL_CHAINING_INTERMEDIATE},
+                                                                                              {TL_PCTR_INVALID, TL_PCTR_INVALID},
+                                                                                              {TL_CHAINING_FIRST, TL_CHAINING_INTERMEDIATE},
+                                                                                              {TL_PCTR_INVALID, TL_PCTR_INVALID},
+                                                                                              {TL_PCTR_INVALID, TL_PCTR_INVALID},
+                                                                                              {TL_CHAINING_ERROR, TL_CHAINING_ERROR},
+                                                                                              };
+
+_STATIC_H optiga_lib_status_t ifx_i2c_tl_send_next_fragment(ifx_i2c_context_t * p_ctx);
+_STATIC_H void ifx_i2c_dl_event_handler(ifx_i2c_context_t * p_ctx,
+                                        optiga_lib_status_t event,
+                                        const uint8_t * p_data,
+                                        uint16_t data_len);
+_STATIC_H optiga_lib_status_t ifx_i2c_tl_resend_packets(ifx_i2c_context_t * p_ctx);
+_STATIC_H optiga_lib_status_t ifx_i2c_tl_send_chaining_error(ifx_i2c_context_t * p_ctx);
+_STATIC_H uint8_t ifx_i2c_tl_calculate_pctr(const ifx_i2c_context_t * p_ctx);
+_STATIC_H optiga_lib_status_t ifx_i2c_tl_check_chaining_error(uint8_t current_chaning, uint8_t previous_chaining);
+/// @endcond
+
+optiga_lib_status_t ifx_i2c_tl_init(ifx_i2c_context_t * p_ctx, ifx_i2c_event_handler_t handler)
+{
+    LOG_TL("[IFX-TL]: Init\n");
+
+    p_ctx->tl.state = TL_STATE_UNINIT;
+
+    // Initialize Data Link layer (and register event handler)
+    if (IFX_I2C_STACK_SUCCESS != ifx_i2c_dl_init(p_ctx, ifx_i2c_dl_event_handler))
+    {
+        return (IFX_I2C_STACK_ERROR);
+    }
+    p_ctx->tl.initialization_state = TRUE;
+    p_ctx->tl.upper_layer_event_handler = handler;
+    p_ctx->tl.state = TL_STATE_IDLE;
+    p_ctx->tl.max_packet_length = p_ctx->frame_size - (DL_HEADER_SIZE + TL_HEADER_SIZE);
+
+    return (IFX_I2C_STACK_SUCCESS);
+}
+
+
+optiga_lib_status_t ifx_i2c_tl_transceive(ifx_i2c_context_t * p_ctx,
+                                          uint8_t * p_packet,
+                                          uint16_t packet_len,
+                                          uint8_t * p_recv_packet,
+                                          uint16_t * p_recv_packet_len)
+{
+    optiga_lib_status_t status = IFX_I2C_STACK_ERROR;
+    LOG_TL("[IFX-TL]: Transceive txlen %d\n", packet_len);
+
+    do
+    {
+        // Check function arguments
+        if ((NULL == p_packet) || (0 == packet_len))
+        {
+            break;
+        }
+        // Transport Layer must be idle
+        if (TL_STATE_IDLE != p_ctx->tl.state)
+        {
+            break;
+        }
+        p_ctx->tl.state = TL_STATE_TX;
+        p_ctx->tl.api_start_time = pal_os_timer_get_time_in_milliseconds();
+        p_ctx->tl.p_actual_packet = p_packet;
+        p_ctx->tl.actual_packet_length = packet_len;
+        p_ctx->tl.packet_offset = 0;
+        p_ctx->tl.p_recv_packet_buffer = p_recv_packet;
+        p_ctx->tl.p_recv_packet_buffer_length = p_recv_packet_len;
+        p_ctx->tl.total_recv_length = 0;
+        p_ctx->tl.chaining_error_count = 0;
+        p_ctx->tl.master_chaining_error_count = 0;
+        p_ctx->tl.transmission_completed = 0;
+        p_ctx->tl.error_event = IFX_I2C_STACK_ERROR;
+        status = ifx_i2c_tl_send_next_fragment(p_ctx);
+    } while (FALSE);
+    return (status);
+}
+
+
+_STATIC_H optiga_lib_status_t ifx_i2c_tl_resend_packets(ifx_i2c_context_t * p_ctx)
+{
+    // Transport Layer must be idle
+    if (TL_STATE_IDLE != p_ctx->tl.state)
+    {
+        return (IFX_I2C_STACK_ERROR);
+    }
+
+    p_ctx->tl.packet_offset = 0;
+    p_ctx->tl.total_recv_length = 0;
+    p_ctx->tl.state = TL_STATE_TX;
+    return (ifx_i2c_tl_send_next_fragment(p_ctx));
+}
+
+_STATIC_H uint8_t ifx_i2c_tl_calculate_pctr(const ifx_i2c_context_t * p_ctx)
+{
+    uint8_t pctr;
+    uint16_t fragment_size = p_ctx->tl.max_packet_length;
+    uint16_t remaining_data = p_ctx->tl.actual_packet_length - p_ctx->tl.packet_offset;
+    // No chain
+    if ((0 == p_ctx->tl.packet_offset) && (remaining_data <= fragment_size))
+    {
+        pctr = TL_CHAINING_NO;
+    }
+    // First chain
+    else if ((0 == p_ctx->tl.packet_offset) && (remaining_data > fragment_size))
+    {
+        pctr = TL_CHAINING_FIRST;
+    }
+    // Intermediate chain
+    else if ((0 != p_ctx->tl.packet_offset) && (remaining_data > fragment_size))
+    {
+        pctr = TL_CHAINING_INTERMEDIATE;
+    }
+    // Last chain
+    else
+    {
+        pctr = TL_CHAINING_LAST;
+    }
+
+    return (pctr);
+}
+_STATIC_H optiga_lib_status_t ifx_i2c_tl_send_next_fragment(ifx_i2c_context_t * p_ctx)
+{
+    uint8_t pctr;
+    // Calculate size of fragment (last one might be shorter)
+    uint16_t tl_fragment_size = p_ctx->tl.max_packet_length;
+    pctr = ifx_i2c_tl_calculate_pctr(p_ctx);
+    if ((p_ctx->tl.actual_packet_length - p_ctx->tl.packet_offset) < tl_fragment_size)
+    {
+        tl_fragment_size = p_ctx->tl.actual_packet_length - p_ctx->tl.packet_offset;
+    }
+    // Assign the pctr
+    //lint --e{835} suppress "IFX_I2C_DL_HEADER_OFFSET macro is defined as 0x00 and is kept for future enhancements"
+    p_ctx->tx_frame_buffer[IFX_I2C_TL_HEADER_OFFSET] = (pctr | IFX_I2C_PRESENCE_BIT);
+    //copy the data
+    //lint --e{835} suppress "IFX_I2C_DL_HEADER_OFFSET macro is defined as 0x00 and is kept for future enhancements"
+    memcpy(p_ctx->tx_frame_buffer+IFX_I2C_TL_HEADER_OFFSET + 1,
+           p_ctx->tl.p_actual_packet + p_ctx->tl.packet_offset,
+           tl_fragment_size);
+    p_ctx->tl.packet_offset += tl_fragment_size;
+    //send the fragment to dl layer
+    return (ifx_i2c_dl_send_frame(p_ctx,tl_fragment_size + 1));
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_tl_send_chaining_error(ifx_i2c_context_t * p_ctx)
+{
+    uint16_t tl_fragment_size = 1;
+    //lint --e{835} suppress "IFX_I2C_DL_HEADER_OFFSET macro is defined as 0x00 and is kept for future enhancements"
+    p_ctx->tx_frame_buffer[IFX_I2C_TL_HEADER_OFFSET] = 0x07;
+    p_ctx->tl.total_recv_length = 0;
+    //send the fragment to dl layer
+    return (ifx_i2c_dl_send_frame(p_ctx,tl_fragment_size));
+}
+
+_STATIC_H optiga_lib_status_t ifx_i2c_tl_check_chaining_error(uint8_t current_chaning,
+                                                              uint8_t previous_chaining)
+{
+    optiga_lib_status_t status = IFX_I2C_STACK_ERROR;
+    if (((TL_CHAINING_ERROR == current_chaning) || (TL_CHAINING_NO == current_chaning) ||
+        (TL_CHAINING_LAST == current_chaning) || (TL_CHAINING_INTERMEDIATE == current_chaning) ||
+        (TL_CHAINING_FIRST == current_chaning)))
+    {
+        if ((g_pctr_states_table[current_chaning][0] == previous_chaining) ||
+            (g_pctr_states_table[current_chaning][1] == previous_chaining))
+        {
+            status =  IFX_I2C_STACK_SUCCESS;
+        }
+    }
+
+    return (status);
+}
+// This functionality checks for the present bit in the pctr register
+_STATIC_H  optiga_lib_status_t presence_bit_check(const ifx_i2c_context_t * p_ctx,
+                                                  uint8_t pctr)
+{
+    optiga_lib_status_t return_status= IFX_I2C_STACK_SUCCESS;
+    uint8_t pctr_value;
+
+    pctr_value = (pctr & TL_PCTR_CHANNEL_MASK);
+    //lint --e{774} suppress "This value changes based on presentation layer macro"
+    if (0 != IFX_I2C_PRESENCE_BIT_CHECK)
+    {
+        if ((FALSE == p_ctx->tl.initialization_state) && ((TL_CHAINING_NO == (pctr & TL_PCTR_CHAIN_MASK))
+            || (TL_CHAINING_FIRST == (pctr & TL_PCTR_CHAIN_MASK))))
+        {
+            if (IFX_I2C_PRESENCE_BIT_CHECK != pctr_value)
+            {
+                return_status = IFX_I2C_STACK_ERROR;
+            }
+        }
+    }
+    else 
+    {
+        if ((FALSE == p_ctx->tl.initialization_state))
+        {
+            if (IFX_I2C_PRESENCE_BIT_CHECK != pctr_value)
+            {
+                return_status = IFX_I2C_STACK_ERROR;
+            }
+        }
+    }
+    return (return_status);
+}
+_STATIC_H void ifx_i2c_dl_event_handler(ifx_i2c_context_t * p_ctx,
+                                        optiga_lib_status_t event,
+                                        const uint8_t * p_data,
+                                        uint16_t data_len)
+{
+    uint8_t pctr = 0;
+    uint8_t chaining = 0;
+    uint8_t exit_machine = TRUE;
+    do
+    {
+        if (NULL != p_data)
+        {
+            pctr = p_data[0];
+            chaining = pctr & TL_PCTR_CHAIN_MASK;
+        }
+        // Propagate errors to upper layer
+        if (0 != (event & IFX_I2C_DL_EVENT_ERROR))
+        {
+            p_ctx->tl.state = TL_STATE_ERROR;
+            p_ctx->tl.error_event = IFX_I2C_STACK_ERROR;
+        }
+        if (0 != data_len)
+        {
+            if (0 != (presence_bit_check(p_ctx,pctr)))
+            {
+                p_ctx->tl.state = TL_STATE_ERROR;
+                p_ctx->tl.error_event = IFX_I2C_STACK_ERROR;
+            }
+        }
+        p_ctx->tl.initialization_state = FALSE;
+        switch (p_ctx->tl.state)
+        {
+            case TL_STATE_IDLE:
+            {
+                exit_machine = FALSE;
+                p_ctx->tl.upper_layer_event_handler(p_ctx, IFX_I2C_STACK_SUCCESS, 0, 0);
+            }
+            break;
+            case TL_STATE_TX:
+            {
+                // Frame transmission in Data Link layer complete, start receiving frames
+                if (0 != (event & IFX_I2C_DL_EVENT_TX_SUCCESS))
+                {
+                    if (p_ctx->tl.packet_offset < p_ctx->tl.actual_packet_length)
+                    {
+                        // Transmission of one fragment complete, send next fragment
+                        LOG_TL("[IFX-TL]: Tx:Fragment sent,now send next\n");
+                        // Chaining error from slave
+                        if (TL_CHAINING_ERROR == chaining)
+                        {
+                            LOG_TL("[IFX-TL]: Tx:Chaining error received while Tx\n");
+                            p_ctx->tl.state = TL_STATE_RESEND;
+                            break;
+                        }
+                        // Any fragment received before complete transmission is error
+                        if (0 != data_len)
+                        {
+                            LOG_TL("[IFX-TL]: Tx:Data received while Tx\n");
+                            p_ctx->tl.state = TL_STATE_ERROR;
+                            break;
+                        }
+                        exit_machine = FALSE;
+                        //lint --e{534} suppress "Error handling is not required so return value is not checked"
+                        ifx_i2c_tl_send_next_fragment(p_ctx);
+                    }
+                    else
+                    {
+                        // Transmission of all fragments complete, start receiving fragments
+                        LOG_TL("[IFX-TL]: Tx:All fragment sent\n");
+                        p_ctx->tl.state = TL_STATE_RX;
+                        p_ctx->tl.total_recv_length = 0;
+                        p_ctx->tl.previous_chaining = TL_CHAINING_NO;
+                        p_ctx->tl.transmission_completed = 1;
+                        // if data is received after sending last frame
+                        if (!(event & IFX_I2C_DL_EVENT_RX_SUCCESS))
+                        {
+                            LOG_TL("[IFX-TL]: Tx:Data already received after Tx\n");
+                            // Received CTRL frame, trigger reception in Data Link layer
+                            if (0 != ifx_i2c_dl_receive_frame(p_ctx))
+                            {
+                                LOG_TL("[IFX-TL]: Tx:RX Received CTRL frame fail -> Inform UL\n");
+                                p_ctx->tl.state = TL_STATE_ERROR;
+                            }
+                            exit_machine = FALSE;
+                        }
+                    }
+                }
+                else
+                {
+                    LOG_TL("[IFX-TL]: Tx:IFX_I2C_DL_EVENT_TX_SUCCESS is not satisfied Tx\n");
+                    p_ctx->tl.state = TL_STATE_ERROR;
+                    break;
+                }
+            }
+            break;
+            case TL_STATE_RX:
+            {
+                // Reception of frame from Data Link layer
+                if (0 != (event & IFX_I2C_DL_EVENT_RX_SUCCESS))
+                {
+                    // Message must contain at least the transport layer header
+                    if (data_len < TL_HEADER_SIZE)
+                    {
+                        LOG_TL("[IFX-TL]: Rx : Data received is more than header len\n");
+                        p_ctx->tl.state = TL_STATE_ERROR;
+                        break;
+                    }
+
+                    if (IFX_I2C_STACK_MEM_ERROR == p_ctx->tl.error_event)
+                    {
+                        if ((TL_CHAINING_LAST == chaining) || (0 != ifx_i2c_dl_receive_frame(p_ctx)))
+                        {
+                            p_ctx->tl.state = TL_STATE_ERROR;
+                            break;
+                        }
+                        p_ctx->tl.state = TL_STATE_RX;
+                        exit_machine = FALSE;
+                        break;
+                    }
+
+                    // If chaining error detected
+                    if (IFX_I2C_STACK_SUCCESS != ifx_i2c_tl_check_chaining_error(chaining,p_ctx->tl.previous_chaining))
+                    {
+                        LOG_TL("[IFX-TL]: Rx : Chaining state is not correct\n");
+                        p_ctx->tl.state = TL_STATE_RESEND;
+                        break;
+                    }
+
+                    p_ctx->tl.previous_chaining = chaining & 0x07;
+                    if (NULL == p_data)
+                    {
+                        p_ctx->tl.state = TL_STATE_ERROR;
+                        break;
+                    }
+
+                    // No chaining and Last
+                    if ((TL_CHAINING_NO == chaining) || (TL_CHAINING_LAST == chaining))
+                    {
+                        LOG_TL("[IFX-TL]: Rx : No chain/Last chain received, Inform UL\n");
+                        // Check for possible receive buffer overflow
+                        if ((p_ctx->tl.total_recv_length + data_len - 1) > (*p_ctx->tl.p_recv_packet_buffer_length))
+                        {
+                            LOG_TL("[IFX-TL]: Chain : Buffer overflow\n");
+                            p_ctx->tl.error_event = IFX_I2C_STACK_MEM_ERROR;
+                            p_ctx->tl.state = TL_STATE_ERROR;
+                            break;
+                        }
+                        exit_machine = FALSE;
+                        // Copy frame payload to transport layer receive buffer
+                        memcpy(p_ctx->tl.p_recv_packet_buffer + p_ctx->tl.total_recv_length, p_data + 1, data_len - 1);
+                        p_ctx->tl.total_recv_length += (data_len - 1);
+                        // Inform upper layer that a packet has arrived
+                        p_ctx->tl.state = TL_STATE_IDLE;
+                        *p_ctx->tl.p_recv_packet_buffer_length = p_ctx->tl.total_recv_length;
+                        p_ctx->tl.upper_layer_event_handler(p_ctx,IFX_I2C_STACK_SUCCESS,
+                                                            p_ctx->tl.p_recv_packet_buffer,
+                                                            *p_ctx->tl.p_recv_packet_buffer_length);
+                    }
+                    else
+                    {
+                        p_ctx->tl.state = TL_STATE_CHAINING;
+                    }
+                }
+                else
+                {
+                    LOG_TL("[IFX-TL]: Tx:IFX_I2C_DL_EVENT_TX_SUCCESS is not satisfied Tx\n");
+                    p_ctx->tl.state = TL_STATE_ERROR;
+                    break;
+                }
+            }
+            break;
+            case TL_STATE_CHAINING:
+            {
+                LOG_TL("[IFX-TL]: Chain : Chaining mode entered\n");
+                // When receiving a starting fragment, fragment length must be max frame size for intermediate and last 
+                // frame the buffer should not be empty
+                if (data_len != (p_ctx->tl.max_packet_length + 1))
+                {
+                    LOG_TL("[IFX-TL]: Chain : Data len not equal to max frame size\n");
+                    p_ctx->tl.state = TL_STATE_CHAINING_ERROR;
+                    break;
+                }
+                // Check for possible receive buffer overflow
+                if ((p_ctx->tl.total_recv_length + data_len - 1) > (*p_ctx->tl.p_recv_packet_buffer_length))
+                {
+                    LOG_TL("[IFX-TL]: Chain : Buffer overflow\n");
+                    p_ctx->tl.error_event = IFX_I2C_STACK_MEM_ERROR;
+                    p_ctx->tl.state = TL_STATE_RX;
+                    break;
+                }
+                if (NULL == p_data)
+                {
+                    p_ctx->tl.state = TL_STATE_ERROR;
+                    break;
+                }
+                // Copy frame payload to transport layer receive buffer
+                memcpy(p_ctx->tl.p_recv_packet_buffer + p_ctx->tl.total_recv_length, p_data + 1, data_len - 1);
+                p_ctx->tl.total_recv_length += (data_len - 1);
+
+                p_ctx->tl.previous_chaining = pctr & 0x07;
+                LOG_TL("[IFX-TL]: Chain : Continue  in receive mode\n");
+                p_ctx->tl.state = TL_STATE_RX;
+                // Continue receiving frames until packet is complete
+                if (0 != ifx_i2c_dl_receive_frame(p_ctx))
+                {
+                    p_ctx->tl.state = TL_STATE_ERROR;
+                }
+                exit_machine = FALSE;
+            }
+            break;
+            case TL_STATE_RESEND:
+            {
+                LOG_TL("[IFX-TL]: Resend Enter\n");
+                // In received mode , for wrong pctr with data
+                if ((data_len > 1) && (p_ctx->tl.transmission_completed == 1))
+                {
+                    LOG_TL("[IFX-TL]: Resend : Send chaining error\n");
+                    p_ctx->tl.state = TL_STATE_CHAINING_ERROR;
+                    break;
+                }
+                // Master Resend the packets,Resend only once, otherwise exit with error
+                if (0 == (p_ctx->tl.chaining_error_count++))
+                {
+                    LOG_TL("[IFX-TL]: Resend : Resending\n");
+                    p_ctx->tl.state = TL_STATE_IDLE;
+                    if (0 != ifx_i2c_tl_resend_packets(p_ctx))
+                    {
+                        p_ctx->tl.state = TL_STATE_ERROR;
+                    }
+                    else
+                    {
+                        exit_machine = FALSE;
+                    }
+                }
+                else
+                {
+                    LOG_TL("[IFX-TL]: Resend : chaining_error_count exceeded\n");
+                    p_ctx->tl.state = TL_STATE_ERROR;
+                }
+            }
+            break;
+            case TL_STATE_CHAINING_ERROR:
+            {
+                // Send chaining error to slave
+                p_ctx->tl.state = TL_STATE_TX;
+                if (0 == (p_ctx->tl.master_chaining_error_count++))
+                {
+                    LOG_TL("[IFX-TL]: Chain error : Sending chain error\n");
+                    // Send chaining error only once
+                    if (0 != ifx_i2c_tl_send_chaining_error(p_ctx))
+                    {
+                        p_ctx->tl.state = TL_STATE_ERROR;
+                    }
+                    else
+                    {
+                        exit_machine = FALSE;
+                    }
+                }
+                else
+                {
+                    LOG_TL("[IFX-TL]: Chain error : master_chaining_error_count exceeded\n");
+                    p_ctx->tl.state = TL_STATE_ERROR;
+                }
+            }
+            break;
+            case TL_STATE_ERROR:
+            {
+                LOG_TL("[IFX-TL]: Error\n");
+                exit_machine = FALSE;
+                if ((0 != (event & IFX_I2C_DL_EVENT_ERROR)) || (0 != data_len))
+                {
+                    p_ctx->tl.state = TL_STATE_IDLE;
+                }
+                p_ctx->tl.upper_layer_event_handler(p_ctx, p_ctx->tl.error_event, 0u, 0u);
+            }
+            break;
+            default:
+            {
+                LOG_TL("[IFX-TL]: Exit from default case\n");
+                p_ctx->tl.state = TL_STATE_IDLE;
+                exit_machine = FALSE;
+                p_ctx->tl.upper_layer_event_handler(p_ctx, p_ctx->tl.error_event, 0u, 0u);
+            }
+            break;
+        }
+    } while (TRUE == exit_machine);
+}
+
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/comms/optiga_comms_ifx_i2c.c b/3rdparty/experimental/optiga/optiga/comms/optiga_comms_ifx_i2c.c
new file mode 100644
index 000000000..cd7635bd9
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/comms/optiga_comms_ifx_i2c.c
@@ -0,0 +1,222 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_comms_ifx_i2c.c
+*
+* \brief   This file implements optiga comms abstraction layer for IFX I2C Protocol.
+*
+* \ingroup  grOptigaComms
+*
+* @{
+*/
+
+#include "optiga/comms/optiga_comms.h"
+#include "optiga/common/optiga_lib_logger.h"
+#include "optiga/ifx_i2c/ifx_i2c.h"
+#include "optiga/pal/pal_os_event.h"
+
+/// @cond hidden
+
+ /// Optiga comms is in use
+ #define OPTIGA_COMMS_INUSE     (0x01)
+ /// Optiga comms is free
+ #define OPTIGA_COMMS_FREE      (0x00)
+
+optiga_comms_t optiga_comms = {
+                               (void *)&ifx_i2c_context_0,
+                               NULL,
+                               NULL,
+                               0,
+                               0,
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                               0,
+                               0,
+                               0,
+#endif
+                               NULL};
+
+_STATIC_H optiga_lib_status_t check_optiga_comms_state(optiga_comms_t *p_ctx);
+_STATIC_H void ifx_i2c_event_handler(void* p_ctx, optiga_lib_status_t event);
+
+optiga_comms_t * optiga_comms_create(callback_handler_t callback, void * context)
+{
+    optiga_comms_t * p_optiga_comms = NULL;
+
+    do
+    {
+        p_optiga_comms = &optiga_comms;
+
+        if (FALSE == p_optiga_comms->instance_init_state)
+        {
+#ifdef OPTIGA_PAL_INIT_ENABLED
+            if (PAL_STATUS_SUCCESS != pal_init())
+            {
+                p_optiga_comms = NULL;
+                break;
+            }
+#endif
+            p_optiga_comms->upper_layer_handler = callback;
+            p_optiga_comms->p_upper_layer_ctx = context;
+            p_optiga_comms->instance_init_state = TRUE;
+        }
+    } while (FALSE);
+    return (p_optiga_comms);
+}
+
+//lint --e{715} suppress "p_optiga_cmd is not used here as it is placeholder for future."
+//lint --e{818} suppress "Not declared as pointer as nothing needs to be updated in the pointer."
+void optiga_comms_destroy(optiga_comms_t * p_optiga_cmd)
+{
+}
+
+optiga_lib_status_t optiga_comms_set_callback_handler(optiga_comms_t * p_optiga_comms, callback_handler_t handler)
+{
+    p_optiga_comms->upper_layer_handler = handler;
+    return (0);
+}
+
+optiga_lib_status_t optiga_comms_set_callback_context(optiga_comms_t * p_optiga_comms, void * context)
+{
+    p_optiga_comms->p_upper_layer_ctx = context;
+    return (0);
+}
+
+
+/// @endcond
+
+optiga_lib_status_t optiga_comms_open(optiga_comms_t * p_ctx)
+{
+    optiga_lib_status_t status = OPTIGA_COMMS_ERROR;
+    if (OPTIGA_COMMS_SUCCESS == check_optiga_comms_state(p_ctx))
+    {
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->p_upper_layer_ctx = (void * )p_ctx;
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->upper_layer_event_handler = ifx_i2c_event_handler;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->manage_context_operation = p_ctx->manage_context_operation;
+#endif
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->pal_os_event_ctx = p_ctx->p_pal_os_event_ctx;
+
+        status = ifx_i2c_open((ifx_i2c_context_t * )(p_ctx->p_comms_ctx));
+        if (IFX_I2C_STACK_SUCCESS != status)
+        {
+            p_ctx->state = OPTIGA_COMMS_FREE;
+        }
+    }
+    return (status);
+}
+
+optiga_lib_status_t optiga_comms_reset(optiga_comms_t * p_ctx, uint8_t reset_type)
+{
+    optiga_lib_status_t status = OPTIGA_COMMS_ERROR;
+    if (OPTIGA_COMMS_SUCCESS == check_optiga_comms_state(p_ctx))
+    {
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->p_upper_layer_ctx = (void * )p_ctx;
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->upper_layer_event_handler = ifx_i2c_event_handler;
+        status = ifx_i2c_reset((ifx_i2c_context_t * )(p_ctx->p_comms_ctx), (ifx_i2c_reset_type_t)reset_type);
+        if (IFX_I2C_STACK_SUCCESS != status)
+        {
+            p_ctx->state = OPTIGA_COMMS_FREE;
+        }
+    }
+    return (status);
+}
+
+
+optiga_lib_status_t optiga_comms_transceive(optiga_comms_t * p_ctx,
+                                            const uint8_t * p_tx_data,
+                                            uint16_t tx_data_length,
+                                            uint8_t * p_rx_data,
+                                            uint16_t * p_rx_data_len)
+{
+    optiga_lib_status_t status = OPTIGA_COMMS_ERROR;
+    if (OPTIGA_COMMS_SUCCESS == check_optiga_comms_state(p_ctx))
+    {
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->p_upper_layer_ctx = (void * )p_ctx;
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->upper_layer_event_handler = ifx_i2c_event_handler;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->protection_level = p_ctx->protection_level;
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->protocol_version = p_ctx->protocol_version;
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->manage_context_operation = p_ctx->manage_context_operation;
+#endif
+        status = (ifx_i2c_transceive((ifx_i2c_context_t * )(p_ctx->p_comms_ctx),
+                                     p_tx_data,
+                                     tx_data_length,
+                                     p_rx_data,
+                                     p_rx_data_len));
+        if (IFX_I2C_STACK_SUCCESS != status)
+        {
+            p_ctx->state = OPTIGA_COMMS_FREE;
+        }
+    }
+    return (status);
+}
+
+
+optiga_lib_status_t optiga_comms_close(optiga_comms_t * p_ctx)
+{
+    optiga_lib_status_t status = OPTIGA_COMMS_ERROR;
+    if (OPTIGA_COMMS_SUCCESS == check_optiga_comms_state(p_ctx))
+    {
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->p_upper_layer_ctx = (void * )p_ctx;
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->upper_layer_event_handler = ifx_i2c_event_handler;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        ((ifx_i2c_context_t * )(p_ctx->p_comms_ctx))->manage_context_operation = p_ctx->manage_context_operation;
+#endif
+        status = ifx_i2c_close((ifx_i2c_context_t * )(p_ctx->p_comms_ctx));
+        if (IFX_I2C_STACK_SUCCESS != status)
+        {
+            p_ctx->state = OPTIGA_COMMS_FREE;
+        }
+    }
+    return (status);
+}
+
+/// @cond hidden
+_STATIC_H optiga_lib_status_t check_optiga_comms_state(optiga_comms_t * p_ctx)
+{
+    optiga_lib_status_t status = OPTIGA_COMMS_ERROR;
+    if ((NULL != p_ctx) && (OPTIGA_COMMS_INUSE != p_ctx->state))
+    {
+        p_ctx->state = OPTIGA_COMMS_INUSE;
+        status = OPTIGA_COMMS_SUCCESS;
+    }
+    return (status);
+}
+
+//lint --e{818} suppress "This is ignored as upper layer handler function prototype requires this argument"
+_STATIC_H void ifx_i2c_event_handler(void * p_upper_layer_ctx, optiga_lib_status_t event)
+{
+    void * ctx = ((optiga_comms_t * )p_upper_layer_ctx)->p_upper_layer_ctx;
+    ((optiga_comms_t * )p_upper_layer_ctx)->upper_layer_handler(ctx, event);
+    ((optiga_comms_t * )p_upper_layer_ctx)->state = OPTIGA_COMMS_FREE;
+}
+
+/// @endcond
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/crypt/optiga_crypt.c b/3rdparty/experimental/optiga/optiga/crypt/optiga_crypt.c
new file mode 100644
index 000000000..0d2e2c477
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/crypt/optiga_crypt.c
@@ -0,0 +1,2052 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_crypt.c
+*
+* \brief   This file implements the OPTIGA Crypt module.
+*
+* \ingroup  grOptigaCrypt
+*
+* @{
+*/
+
+
+#include "optiga/optiga_crypt.h"
+#include "optiga/common/optiga_lib_logger.h"
+#include "optiga/common/optiga_lib_common_internal.h"
+#include "optiga/pal/pal_os_memory.h"
+
+/// Minimum length of random data
+#define OPTIGA_CRYPT_MINIMUM_RANDOM_DATA_LENGTH                     (0x08)
+/// Param type for optiga pre-master secret
+#define OPTIGA_CRYTP_RANDOM_PARAM_PRE_MASTER_SECRET                 (0x04)
+/// Minimum optional data length
+#define OPTIGA_CRYPT_MINIMUM_OPTIONAL_DATA_LENGTH                   (0x3A)
+/// Symmetric Encryption 
+#define OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION                           (0x01)
+/// Symmetric Decryption 
+#define OPTIGA_CRYPT_SYMMETRIC_DECRYPTION                           (0x00)
+/// MAC generation using HMAC operation
+#define OPTIGA_CRYPT_HMAC                                           (0x02)
+/// Clearing AUTOREF state using clear auto ref operation
+#define OPTIGA_CRYPT_CLEAR_AUTO_STATE                               (0x03)
+
+#if defined (OPTIGA_LIB_ENABLE_LOGGING) && defined (OPTIGA_LIB_ENABLE_CRYPT_LOGGING)
+
+// Logs the message provided from Crypt layer
+#define OPTIGA_CRYPT_LOG_MESSAGE(msg) \
+{\
+    optiga_lib_print_message(msg,OPTIGA_CRYPT_SERVICE,OPTIGA_CRYPT_SERVICE_COLOR);\
+}
+
+// Logs the byte array buffer provided from Crypt layer in hexadecimal format
+//lint --e{750} suppress "The unused OPTIGA_CRYPT_LOG_HEX_DATA macro is kept for future enhancements"
+#define OPTIGA_CRYPT_LOG_HEX_DATA(array,array_len) \
+{\
+    optiga_lib_print_array_hex_format(array,array_len,OPTIGA_UNPROTECTED_DATA_COLOR);\
+}
+
+//Logs the status info provided from Crypt layer
+//lint --e{750} suppress "The unused OPTIGA_CRYPT_LOG_STATUS macro is kept for future enhancements"
+#define OPTIGA_CRYPT_LOG_STATUS(return_value) \
+{ \
+    if (OPTIGA_LIB_SUCCESS != return_value) \
+    { \
+        optiga_lib_print_status(OPTIGA_CRYPT_SERVICE,OPTIGA_ERROR_COLOR,return_value); \
+    } \
+    else\
+    { \
+        optiga_lib_print_status(OPTIGA_CRYPT_SERVICE,OPTIGA_CRYPT_SERVICE_COLOR,return_value); \
+    } \
+}
+#else
+
+#define OPTIGA_CRYPT_LOG_MESSAGE(msg) {}
+//lint --e{750} suppress "The unused OPTIGA_CRYPT_LOG_HEX_DATA macro is kept for future enhancements"
+#define OPTIGA_CRYPT_LOG_HEX_DATA(array, array_len) {}
+//lint --e{750} suppress "The unused OPTIGA_CRYPT_LOG_STATUS macro is kept for future enhancements"
+#define OPTIGA_CRYPT_LOG_STATUS(return_value) {}
+
+#endif
+
+_STATIC_H void optiga_crypt_generic_event_handler(void * p_ctx,
+                                                  optiga_lib_status_t event)
+{
+    optiga_crypt_t * me = (optiga_crypt_t *)p_ctx;
+
+    me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+    me->handler(me->caller_context, event);
+}
+
+_STATIC_H void optiga_crypt_reset_protection_level(optiga_crypt_t * me)
+{
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+    if (NULL != me)
+#endif
+    {
+        OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL(me, OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL);
+    }
+}
+
+extern void optiga_cmd_set_shielded_connection_option(optiga_cmd_t * me,
+                                                      uint8_t value,
+                                                      uint8_t shielded_connection_option);
+
+#ifdef OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED
+_STATIC_H optiga_lib_status_t optiga_crypt_generate_keypair(optiga_crypt_t * me,
+                                                            uint8_t cmd_param,
+                                                            uint8_t key_usage,
+                                                            bool_t export_private_key,
+                                                            void * p_private_key,
+                                                            uint8_t * p_public_key,
+                                                            uint16_t * p_public_key_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    optiga_gen_keypair_params_t * p_params;
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) ||
+            (NULL == p_public_key) || (NULL == p_private_key) || (NULL == p_public_key_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_gen_keypair_params_t *)&(me->params.optiga_gen_keypair_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+
+        p_params->key_usage = key_usage;
+        p_params->export_private_key = export_private_key;
+        p_params->public_key_length = p_public_key_length;
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+        if (export_private_key)
+        {
+            p_params->private_key = (uint8_t *)p_private_key;
+        }
+        else
+        {
+            p_params->private_key_oid = (optiga_key_id_t)(* ((uint16_t* )p_private_key));
+        }
+
+        p_params->public_key = p_public_key;
+        p_params->public_key_length = p_public_key_length;
+
+        return_value = optiga_cmd_gen_keypair(me->my_cmd,
+                                              (uint8_t )cmd_param,
+                                              (optiga_gen_keypair_params_t *)p_params);
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+
+    return (return_value);
+}
+#endif // OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_SIGN_ENABLED
+//lint --e{715} suppress "The salt_length argument is kept for future use"
+_STATIC_H optiga_lib_status_t optiga_crypt_sign(optiga_crypt_t * me,
+                                                uint8_t signature_scheme,
+                                                const uint8_t * p_digest,
+                                                uint8_t digest_length,
+                                                optiga_key_id_t private_key,
+                                                uint8_t * p_signature,
+                                                uint16_t * p_signature_length,
+                                                uint16_t salt_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    optiga_calc_sign_params_t * p_params;
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == p_digest) ||
+            (NULL == p_signature) || (NULL == p_signature_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+
+        p_params = (optiga_calc_sign_params_t *)&(me->params.optiga_calc_sign_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+
+        p_params->p_digest = p_digest;
+        p_params->digest_length = digest_length;
+        p_params->private_key_oid = private_key;
+        p_params->p_signature = p_signature;
+        p_params->p_signature_length = p_signature_length;
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+        return_value = optiga_cmd_calc_sign(me->my_cmd,
+                                            signature_scheme,
+                                            (optiga_calc_sign_params_t *)p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+
+    return (return_value);
+}
+#endif // OPTIGA_CRYPT_RSA_SIGN_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+//lint --e{715} suppress "The salt_length argument is kept for future use"
+_STATIC_H optiga_lib_status_t optiga_crypt_verify(optiga_crypt_t * me,
+                                                  uint8_t cmd_param,
+                                                  const uint8_t * p_digest,
+                                                  uint8_t digest_length,
+                                                  const uint8_t * p_signature,
+                                                  uint16_t signature_length,
+                                                  uint8_t public_key_source_type,
+                                                  const void * p_public_key,
+                                                  uint16_t salt_length)
+{
+    optiga_verify_sign_params_t * p_params;
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) ||
+            (NULL == p_digest) || (NULL == p_signature) || (NULL == p_public_key))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_verify_sign_params_t *)&(me->params.optiga_verify_sign_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+        p_params->p_digest = p_digest;
+        p_params->digest_length = digest_length;
+        p_params->p_signature = p_signature;
+        p_params->signature_length = signature_length;
+        p_params->public_key_source_type = public_key_source_type;
+
+        if (OPTIGA_CRYPT_OID_DATA == public_key_source_type)
+        {
+            p_params->certificate_oid = *((uint16_t *)p_public_key);
+        }
+        else
+        {
+            p_params->public_key = (public_key_from_host_t *)p_public_key;
+        }
+
+        return_value = optiga_cmd_verify_sign(me->my_cmd,
+                                             (uint8_t)cmd_param,
+                                             (optiga_verify_sign_params_t *)p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+
+    return (return_value);
+}
+#endif //OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+
+#if defined (OPTIGA_CRYPT_RSA_DECRYPT_ENABLED) || defined (OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED)
+//lint --e{715} suppress "label and label_length is RFU hence not used"
+_STATIC_H optiga_lib_status_t optiga_crypt_rsa_enc_dec(optiga_crypt_t * me,
+                                                       optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                       const uint8_t * p_message,
+                                                       uint16_t message_length,
+                                                       const uint8_t * p_label,
+                                                       uint16_t label_length,
+                                                       uint8_t public_key_source_type,
+                                                       const void * p_key,
+                                                       uint8_t * p_processed_message,
+                                                       uint16_t * p_processed_message_length,
+                                                       bool_t is_enc)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    optiga_encrypt_asym_params_t * p_params;
+
+    do
+    {
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;;
+
+        p_params = (optiga_encrypt_asym_params_t *)&(me->params.optiga_encrypt_asym_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+
+        p_params->message = p_message;
+        p_params->message_length = message_length;
+        p_params->processed_message = p_processed_message;
+        p_params->processed_message_length = p_processed_message_length;
+
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+
+        if (is_enc)
+        {
+            p_params->key = p_key;
+            p_params->public_key_source_type = public_key_source_type;
+#ifdef OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+            return_value = optiga_cmd_encrypt_asym(me->my_cmd, (uint8_t)encryption_scheme,
+                                                   (optiga_encrypt_asym_params_t *)p_params);
+#endif
+        }
+        else
+        {
+            p_params->private_key_id = (optiga_key_id_t)*(optiga_key_id_t *)p_key;
+            p_params->key = &p_params->private_key_id;
+            p_params->public_key_source_type = 0;
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+            return_value = optiga_cmd_decrypt_asym(me->my_cmd, (uint8_t)encryption_scheme,
+                                                   (optiga_encrypt_asym_params_t *)p_params);
+#endif
+        }
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+
+    return (return_value);
+}
+#endif //(OPTIGA_CRYPT_RSA_DECRYPT_ENABLED) || (OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED)
+#if defined (OPTIGA_CRYPT_RANDOM_ENABLED) || defined (OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED) || defined (OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED)
+_STATIC_H optiga_lib_status_t optiga_crypt_get_random(optiga_crypt_t * me,
+                                                      uint8_t cmd_param,
+                                                      uint8_t * p_random_data,
+                                                      uint16_t random_data_length,
+                                                      const uint8_t * p_optional_data,
+                                                      uint16_t optional_data_length,
+                                                      bool_t store_in_session)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    optiga_get_random_params_t * p_params;
+    do
+    {
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_get_random_params_t *)&(me->params.optiga_get_random_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+
+        p_params->optional_data = p_optional_data;
+        p_params->optional_data_length = optional_data_length;
+        p_params->random_data = p_random_data;
+        p_params->random_data_length = random_data_length;
+        p_params->store_in_session = store_in_session;
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+        return_value = optiga_cmd_get_random(me->my_cmd,
+                                             cmd_param,
+                                             (optiga_get_random_params_t *)p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+
+    return (return_value);
+}
+#endif //(OPTIGA_CRYPT_RANDOM_ENABLED) || (OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED)
+
+#if defined (OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || defined (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || defined (OPTIGA_CRYPT_HMAC_ENABLED) ||\
+    defined (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED) || defined (OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED)
+_STATIC_H optiga_lib_status_t optiga_crypt_symmetric_mode_generic(optiga_crypt_t * me,
+                                                                  uint8_t mode,
+                                                                  uint16_t symmetric_key_oid,
+                                                                  const uint8_t * in_data,
+                                                                  uint32_t in_data_length,
+                                                                  const uint8_t * iv,
+                                                                  uint16_t iv_length,
+                                                                  const uint8_t * associated_data,
+                                                                  uint16_t associated_data_length,
+                                                                  uint16_t total_plain_data_length,
+                                                                  uint8_t * out_data,
+                                                                  uint32_t * out_data_length,
+                                                                  const uint8_t * out_data_verify,
+                                                                  uint32_t out_data_verify_length,
+                                                                  uint8_t enc_dec_sequence,
+                                                                  uint8_t enc_dec_type,
+                                                                  uint8_t operation_mode)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+    optiga_encrypt_sym_params_t * p_params;
+
+    do
+    {
+        // Check if instance is in use
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+
+        p_params = (optiga_encrypt_sym_params_t *)&(me->params.optiga_symmetric_enc_dec_params);
+        if ((OPTIGA_CRYPT_SYM_START_FINAL == enc_dec_sequence) || \
+            (OPTIGA_CRYPT_SYM_START == enc_dec_sequence))
+        {
+            pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+
+            p_params->mode = mode;
+            p_params->symmetric_key_oid = symmetric_key_oid;
+        }
+
+        p_params->in_data = in_data;
+        p_params->in_data_length = in_data_length;
+        p_params->iv = iv;
+        p_params->iv_length = iv_length;
+        p_params->associated_data = associated_data;
+        p_params->associated_data_length = associated_data_length;
+        p_params->total_input_data_length = total_plain_data_length;
+        p_params->out_data = out_data;
+        p_params->out_data_length = out_data_length;
+        p_params->generated_hmac = out_data_verify;
+        p_params->generated_hmac_length = out_data_verify_length;        
+        p_params->original_sequence = enc_dec_sequence;
+        p_params->operation_mode = operation_mode;
+
+
+        switch(enc_dec_type)
+        {
+
+#ifdef OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED
+            case OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION:
+            {
+    #ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                me->protection_level |= OPTIGA_COMMS_COMMAND_PROTECTION;
+    #endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+                if ((OPTIGA_CRYPT_SYM_START_FINAL == enc_dec_sequence) || \
+                    (OPTIGA_CRYPT_SYM_START == enc_dec_sequence))
+                {
+                    OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+                    OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+                }
+                return_value = optiga_cmd_encrypt_sym(me->my_cmd,
+                                                     (uint8_t)p_params->mode,
+                                                     (optiga_encrypt_sym_params_t *)p_params);
+            }
+            break;
+#endif //OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED
+
+
+#ifdef OPTIGA_CRYPT_SYM_DECRYPT_ENABLED
+            case OPTIGA_CRYPT_SYMMETRIC_DECRYPTION:
+            {
+    #ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+                me->protection_level |= OPTIGA_COMMS_RESPONSE_PROTECTION;
+
+    #endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+
+                if ((OPTIGA_CRYPT_SYM_START_FINAL == enc_dec_sequence) || \
+                    (OPTIGA_CRYPT_SYM_START == enc_dec_sequence))
+                {
+                    OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+                    OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+                }
+                return_value = optiga_cmd_decrypt_sym(me->my_cmd,
+                                                     (uint8_t)p_params->mode,
+                                                     (optiga_decrypt_sym_params_t *)p_params);
+            }
+            break;
+#endif //OPTIGA_CRYPT_SYM_DECRYPT_ENABLED
+
+            default:
+            	break;
+        }
+
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+
+    return (return_value);
+}
+
+#endif //(OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || (OPTIGA_CRYPT_HMAC_ENABLED) || (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED)
+
+#if defined (OPTIGA_CRYPT_TLS_PRF_ENABLED) || defined (OPTIGA_CRYPT_HKDF_ENABLED)
+_STATIC_H optiga_lib_status_t optiga_crypt_derive_key_generic(optiga_crypt_t * me,
+                                                              uint8_t type,
+                                                              uint16_t secret,
+                                                              const uint8_t * random_data,
+                                                              uint16_t random_data_length,
+                                                              const uint8_t * label,
+                                                              uint16_t label_length,
+                                                              const uint8_t * info,
+                                                              uint16_t info_length,
+                                                              uint16_t derived_key_length,
+                                                              bool_t export_to_host,
+                                                              uint8_t * derived_key)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    optiga_derive_key_params_t * p_params;
+
+    do
+    {
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+
+        p_params = (optiga_derive_key_params_t *)&(me->params.optiga_derive_key_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+        
+        p_params->input_shared_secret_oid = secret;
+        p_params->random_data = random_data;
+        p_params->random_data_length = random_data_length;
+        p_params->label = label;
+        p_params->label_length = label_length;
+        p_params->info = info;
+        p_params->info_length = info_length;
+        p_params->derived_key_length = derived_key_length;
+
+        if (TRUE == export_to_host)
+        {
+            p_params->derived_key = (uint8_t *)derived_key;
+        }
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        if (OPTIGA_KEY_ID_SESSION_BASED == (optiga_key_id_t)secret)
+        {
+            me->protection_level |= OPTIGA_COMMS_COMMAND_PROTECTION;
+        }
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+        
+        return_value = optiga_cmd_derive_key(me->my_cmd,
+                                             type,
+                                             p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+
+    return (return_value);
+}
+#endif //(OPTIGA_CRYPT_TLS_PRF_ENABLED) || (OPTIGA_CRYPT_HKDF_ENABLED)
+
+#ifdef OPTIGA_CRYPT_HASH_ENABLED
+_STATIC_H optiga_lib_status_t optiga_crypt_hash_generic(optiga_crypt_t * me,
+                                                        uint8_t hash_algorithm,
+                                                        uint8_t hash_sequence,
+                                                        uint8_t source_of_data_to_hash,
+                                                        optiga_hash_context_t * hash_ctx,
+                                                        uint32_t context_length,                                                        
+                                                        const void * data_to_hash,
+                                                        bool_t export_intermediate_ctx,
+                                                        uint8_t * hash_output)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    optiga_calc_hash_params_t * p_params;
+    do
+    {
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_calc_hash_params_t *)&(me->params.optiga_calc_hash_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+        p_params->hash_sequence = hash_sequence;
+        p_params->p_hash_context = hash_ctx;
+        p_params->apparent_context_size = context_length;
+        p_params->p_hash_data = NULL;
+        p_params->p_hash_oid = NULL;
+        p_params->p_out_digest = hash_output;
+        p_params->export_hash_ctx = export_intermediate_ctx;
+        
+        if ((OPTIGA_CRYPT_HASH_CONTINUE == hash_sequence) || (OPTIGA_CRYPT_HASH_START_FINAL == hash_sequence))
+        {
+            if (source_of_data_to_hash)
+            {
+                p_params->p_hash_data = (hash_data_from_host_t *)data_to_hash;
+            }
+            else
+            {
+                p_params->hash_sequence |= OPTIGA_CRYPT_HASH_FOR_OID;
+                p_params->p_hash_oid = (hash_data_in_optiga_t *)data_to_hash;
+            }
+        }
+
+        return_value = optiga_cmd_calc_hash(me->my_cmd,
+                                            hash_algorithm,
+                                            (optiga_calc_hash_params_t *)p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+
+    return (return_value);
+}
+#endif //(OPTIGA_CRYPT_HASH_ENABLED)
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+void optiga_crypt_set_comms_params(optiga_crypt_t * me,
+                                   uint8_t parameter_type,
+                                   uint8_t value)
+{
+    switch (parameter_type)
+    {
+        case OPTIGA_COMMS_PROTECTION_LEVEL:
+        {
+            me->protection_level = value;
+            break;
+        }
+        case OPTIGA_COMMS_PROTOCOL_VERSION:
+        {
+            me->protocol_version = value;
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+#endif
+
+optiga_crypt_t * optiga_crypt_create(uint8_t optiga_instance_id,
+                                     callback_handler_t handler,
+                                     void * caller_context)
+{
+    optiga_crypt_t * me = NULL;
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if (NULL == handler)
+        {
+            break;
+        }
+#endif
+        me = (optiga_crypt_t *)pal_os_calloc(1, sizeof(optiga_crypt_t));
+        if (NULL == me)
+        {
+            break;
+        }
+
+        me->handler = handler;
+        me->caller_context = caller_context;
+        me->instance_state = OPTIGA_LIB_SUCCESS;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        me->protocol_version = OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET;
+        me->protection_level = OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL;
+#endif
+        me->my_cmd = optiga_cmd_create(optiga_instance_id,
+                                       optiga_crypt_generic_event_handler,
+                                       me);
+        if (NULL == me->my_cmd)
+        {
+            pal_os_free(me);
+            me = NULL;
+        }
+
+    } while (FALSE);
+
+    return (me);
+}
+
+optiga_lib_status_t optiga_crypt_destroy(optiga_crypt_t * me)
+{
+    optiga_lib_status_t return_value;
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if (NULL == me)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+        return_value = optiga_cmd_destroy(me->my_cmd);
+        pal_os_free(me);
+
+    } while (FALSE);
+    return (return_value);
+}
+
+#ifdef OPTIGA_CRYPT_RANDOM_ENABLED
+optiga_lib_status_t optiga_crypt_random(optiga_crypt_t * me,
+                                        optiga_rng_type_t rng_type,
+                                        uint8_t * random_data,
+                                        uint16_t random_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == random_data))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value = optiga_crypt_get_random(me,
+                                               (uint8_t)rng_type,
+                                               random_data,
+                                               random_data_length,
+                                               NULL,
+                                               0x00,
+                                               FALSE);
+    } while (FALSE);
+
+    return (return_value);
+}
+#endif //OPTIGA_CRYPT_RANDOM_ENABLED
+
+#ifdef OPTIGA_CRYPT_HASH_ENABLED
+optiga_lib_status_t optiga_crypt_hash_start(optiga_crypt_t * me,
+                                            optiga_hash_context_t * hash_ctx)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do  
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == hash_ctx))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value = optiga_crypt_hash_generic(me,
+                                                 hash_ctx->hash_algo,
+                                                 OPTIGA_CRYPT_HASH_START,
+                                                 0,
+                                                 hash_ctx,
+                                                 0,
+                                                 NULL,
+                                                 TRUE,
+                                                 NULL);
+    } while (FALSE);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_hash_update(optiga_crypt_t * me,
+                                             optiga_hash_context_t * hash_ctx,
+                                             uint8_t source_of_data_to_hash,
+                                             const void * data_to_hash)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) ||
+            (NULL == hash_ctx) || (NULL == data_to_hash))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value = optiga_crypt_hash_generic(me,
+                                                 hash_ctx->hash_algo,
+                                                 OPTIGA_CRYPT_HASH_CONTINUE,
+                                                 source_of_data_to_hash,
+                                                 hash_ctx,
+                                                 hash_ctx->context_buffer_length,
+                                                 data_to_hash,
+                                                 TRUE,
+                                                 NULL);
+    } while (FALSE);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_hash_finalize(optiga_crypt_t * me,
+                                               optiga_hash_context_t * hash_ctx,
+                                               uint8_t * hash_output)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) ||
+            (NULL == hash_ctx) || (NULL == hash_output))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value = optiga_crypt_hash_generic(me,
+                                                 hash_ctx->hash_algo,
+                                                 OPTIGA_CRYPT_HASH_FINAL,
+                                                 0,
+                                                 hash_ctx,
+                                                 hash_ctx->context_buffer_length,
+                                                 NULL,
+                                                 FALSE,
+                                                 hash_output);
+    } while (FALSE);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_hash(optiga_crypt_t * me,
+                                      optiga_hash_type_t hash_algorithm,
+                                      uint8_t source_of_data_to_hash,
+                                      const void * data_to_hash, 
+                                      uint8_t * hash_output)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == data_to_hash) || (NULL == hash_output))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value = optiga_crypt_hash_generic(me,
+                                                 (uint8_t)hash_algorithm,
+                                                 OPTIGA_CRYPT_HASH_START_FINAL,
+                                                 source_of_data_to_hash,
+                                                 NULL,
+                                                 0,
+                                                 data_to_hash,
+                                                 FALSE,
+                                                 hash_output);
+    } while (FALSE);
+
+    return (return_value);
+}
+#endif //OPTIGA_CRYPT_HASH_ENABLED
+
+#ifdef OPTIGA_CRYPT_TLS_PRF_ENABLED
+optiga_lib_status_t optiga_crypt_tls_prf(optiga_crypt_t * me,
+                                         optiga_tls_prf_type_t type,
+                                         uint16_t secret,
+                                         const uint8_t * label,
+                                         uint16_t label_length,
+                                         const uint8_t * seed,
+                                         uint16_t seed_length,
+                                         uint16_t derived_key_length,
+                                         bool_t export_to_host,
+                                         uint8_t * derived_key)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == seed) ||
+           ((TRUE == export_to_host) && (NULL == derived_key)))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        return_value = optiga_crypt_derive_key_generic(me,
+                                                       (uint8_t)type,
+                                                       secret,
+                                                       seed,
+                                                       seed_length,
+                                                       label,
+                                                       label_length,
+                                                       NULL,
+                                                       0,
+                                                       derived_key_length,
+                                                       export_to_host,
+                                                       derived_key);
+        
+    } while (FALSE);
+
+    return (return_value);
+}
+#endif //OPTIGA_CRYPT_TLS_PRF_ENABLED
+
+
+#ifdef OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED
+optiga_lib_status_t optiga_crypt_rsa_generate_keypair(optiga_crypt_t * me,
+                                                      optiga_rsa_key_type_t key_type,
+                                                      uint8_t key_usage,
+                                                      bool_t export_private_key,
+                                                      void * private_key,
+                                                      uint8_t * public_key,
+                                                      uint16_t * public_key_length)
+{
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    return (optiga_crypt_generate_keypair(me,
+                                         (uint8_t)key_type,
+                                         key_usage,
+                                         export_private_key,
+                                         private_key,
+                                         public_key,
+                                         public_key_length));
+}
+#endif //OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED
+
+
+#ifdef OPTIGA_CRYPT_RSA_SIGN_ENABLED
+optiga_lib_status_t optiga_crypt_rsa_sign(optiga_crypt_t * me,
+                                          optiga_rsa_signature_scheme_t signature_scheme,
+                                          const uint8_t * digest,
+                                          uint8_t digest_length,
+                                          optiga_key_id_t private_key,
+                                          uint8_t * signature,
+                                          uint16_t * signature_length,
+                                          uint16_t salt_length)
+{
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    return (optiga_crypt_sign(me,
+                             (uint8_t)signature_scheme,
+                             digest,
+                             digest_length,
+                             private_key,
+                             signature,
+                             signature_length,
+                             salt_length));
+}
+
+#endif //OPTIGA_CRYPT_RSA_SIGN_ENABLED
+#ifdef OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+optiga_lib_status_t optiga_crypt_rsa_verify(optiga_crypt_t * me,
+                                            optiga_rsa_signature_scheme_t signature_scheme,
+                                            const uint8_t * digest,
+                                            uint8_t digest_length,
+                                            const uint8_t * signature,
+                                            uint16_t signature_length,
+                                            uint8_t public_key_source_type,
+                                            const void * public_key,
+                                            uint16_t salt_length)
+{
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    return (optiga_crypt_verify(me,
+                                (uint8_t)signature_scheme,
+                                digest,
+                                digest_length,
+                                signature,
+                                signature_length,
+                                public_key_source_type,
+                                public_key,
+                                salt_length));
+}
+#endif //OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+optiga_lib_status_t optiga_crypt_rsa_encrypt_message(optiga_crypt_t * me,
+                                                     optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                     const uint8_t * message,
+                                                     uint16_t message_length,
+                                                     const uint8_t * label,
+                                                     uint16_t label_length,
+                                                     uint8_t public_key_source_type,
+                                                     const void * public_key,
+                                                     uint8_t * encrypted_message,
+                                                     uint16_t * encrypted_message_length)
+{
+
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == message)||
+            (NULL == public_key) || (NULL == encrypted_message) || (NULL == encrypted_message_length))
+        {
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_rsa_enc_dec(me,
+                                                 encryption_scheme,
+                                                 message,
+                                                 message_length,
+                                                 label,
+                                                 label_length,
+                                                 public_key_source_type,
+                                                 public_key,
+                                                 encrypted_message,
+                                                 encrypted_message_length,
+                                                 TRUE);
+    } while (FALSE);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_rsa_encrypt_session(optiga_crypt_t * me,
+                                                     optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                     const uint8_t * label,
+                                                     uint16_t label_length,
+                                                     uint8_t public_key_source_type,
+                                                     const void * public_key,
+                                                     uint8_t * encrypted_message,
+                                                     uint16_t * encrypted_message_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == encrypted_message)|| (NULL == encrypted_message_length) ||
+            (NULL == public_key))
+        {
+            break;
+        }
+#endif
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        me->protection_level |= OPTIGA_COMMS_COMMAND_PROTECTION;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+        return_value =  optiga_crypt_rsa_enc_dec(me,
+                                                 encryption_scheme,
+                                                 NULL,
+                                                 0,
+                                                 label,
+                                                 label_length,
+                                                 public_key_source_type,
+                                                 public_key,
+                                                 encrypted_message,
+                                                 encrypted_message_length,
+                                                 TRUE);
+    } while (FALSE);
+    return (return_value);
+}
+
+#endif //OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+optiga_lib_status_t optiga_crypt_rsa_decrypt_and_export(optiga_crypt_t * me,
+                                                        optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                        const uint8_t * encrypted_message,
+                                                        uint16_t encrypted_message_length,
+                                                        const uint8_t * label,
+                                                        uint16_t label_length,
+                                                        optiga_key_id_t private_key,
+                                                        uint8_t * message,
+                                                        uint16_t * message_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+    optiga_key_id_t private_key_id;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == message) || (NULL == message_length)||
+            (NULL == encrypted_message))
+        {
+            break;
+        }
+#endif
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        me->protection_level |= OPTIGA_COMMS_RESPONSE_PROTECTION;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+        private_key_id = private_key;
+        return_value = optiga_crypt_rsa_enc_dec(me,
+                                                encryption_scheme,
+                                                encrypted_message,
+                                                encrypted_message_length,
+                                                label,
+                                                label_length,
+                                                0,
+                                                (void *)&private_key_id,
+                                                message,
+                                                message_length,
+                                                FALSE);
+    } while (FALSE);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_rsa_decrypt_and_store(optiga_crypt_t * me,
+                                                       optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                       const uint8_t * encrypted_message,
+                                                       uint16_t encrypted_message_length,
+                                                       const uint8_t * label,
+                                                       uint16_t label_length,
+                                                       optiga_key_id_t private_key)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+    optiga_key_id_t private_key_id;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == encrypted_message))
+        {
+           break;
+        }
+#endif
+        private_key_id = private_key;
+        return_value = optiga_crypt_rsa_enc_dec(me,
+                                                encryption_scheme,
+                                                encrypted_message,
+                                                encrypted_message_length,
+                                                label,
+                                                label_length,
+                                                0,
+                                                (void *)&private_key_id,
+                                                NULL,
+                                                NULL,
+                                                FALSE);
+    } while (FALSE);
+
+    return (return_value);
+}
+#endif //OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+#ifdef OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED
+optiga_lib_status_t optiga_crypt_rsa_generate_pre_master_secret(optiga_crypt_t * me,
+                                                                const uint8_t * optional_data,
+                                                                uint16_t optional_data_length,
+                                                                uint16_t pre_master_secret_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        /// Maximum length of shared secret supported by OPTIGA is 48 bytes, minimum is 8 bytes.
+        if ((NULL == me) || (NULL == me->my_cmd))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        /// The minimum difference between shared secret length and optional data length should be 8 bytes,
+        /// since the minimum random length OPTIGA expects is 8 bytes (optional_data_length <= shared_length - 8 bytes).
+        if (((optional_data_length + OPTIGA_CRYPT_MINIMUM_RANDOM_DATA_LENGTH) > pre_master_secret_length) ||
+            (optional_data_length > OPTIGA_CRYPT_MINIMUM_OPTIONAL_DATA_LENGTH))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+
+        return_value = optiga_crypt_get_random(me,
+                                               OPTIGA_CRYTP_RANDOM_PARAM_PRE_MASTER_SECRET,
+                                               NULL,
+                                               (pre_master_secret_length - optional_data_length),
+                                               optional_data,
+                                               optional_data_length,
+                                               TRUE);
+    } while (FALSE);
+
+    return (return_value);
+}
+#endif //OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED
+
+#ifdef OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED
+
+optiga_lib_status_t optiga_crypt_symmetric_encrypt(optiga_crypt_t * me,
+                                                   optiga_symmetric_encryption_mode_t encryption_mode,
+                                                   optiga_key_id_t symmetric_key_oid,
+                                                   const uint8_t * plain_data,
+                                                   uint32_t plain_data_length,
+                                                   const uint8_t * iv,
+                                                   uint16_t iv_length,
+                                                   const uint8_t * associated_data,
+                                                   uint16_t associated_data_length,
+                                                   uint8_t * encrypted_data,
+                                                   uint32_t * encrypted_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == plain_data) || 
+            (NULL == encrypted_data) || (NULL == encrypted_data_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)encryption_mode,
+                                                            (uint16_t)symmetric_key_oid,
+                                                            plain_data,
+                                                            plain_data_length,
+                                                            iv,
+                                                            iv_length,
+                                                            associated_data,
+                                                            associated_data_length,
+                                                            0,
+                                                            encrypted_data,
+                                                            encrypted_data_length,
+                                                            NULL,
+                                                            0,
+                                                            OPTIGA_CRYPT_SYM_START_FINAL,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_symmetric_encrypt_start(optiga_crypt_t * me,
+                                                         optiga_symmetric_encryption_mode_t encryption_mode,
+                                                         optiga_key_id_t symmetric_key_oid,
+                                                         const uint8_t * plain_data,
+                                                         uint32_t plain_data_length,
+                                                         const uint8_t * iv,
+                                                         uint16_t iv_length,
+                                                         const uint8_t * associated_data,
+                                                         uint16_t associated_data_length,
+                                                         uint16_t total_plain_data_length,
+                                                         uint8_t * encrypted_data,
+                                                         uint32_t * encrypted_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == plain_data) ||
+           (((NULL == encrypted_data) || (NULL == encrypted_data_length)) && \
+           (OPTIGA_SYMMETRIC_CBC_MAC != encryption_mode)))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)encryption_mode,
+                                                            (uint16_t)symmetric_key_oid,
+                                                            plain_data,
+                                                            plain_data_length,
+                                                            iv,
+                                                            iv_length,
+                                                            associated_data,
+                                                            associated_data_length,
+                                                            total_plain_data_length,
+                                                            encrypted_data,
+                                                            encrypted_data_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_START,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+
+optiga_lib_status_t optiga_crypt_symmetric_encrypt_continue(optiga_crypt_t * me,
+                                                            const uint8_t * plain_data,
+                                                            uint32_t plain_data_length,
+                                                            uint8_t * encrypted_data,
+                                                            uint32_t * encrypted_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == plain_data) ||
+           (((NULL == encrypted_data) || (NULL == encrypted_data_length)) && (OPTIGA_SYMMETRIC_CBC_MAC != \
+           ((optiga_symmetric_encryption_mode_t)\
+           ((optiga_encrypt_sym_params_t *)&(me->params.optiga_symmetric_enc_dec_params))->mode))))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            0,
+                                                            0,
+                                                            plain_data,
+                                                            plain_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            encrypted_data,
+                                                            encrypted_data_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_CONTINUE,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION);
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_symmetric_encrypt_final(optiga_crypt_t * me,
+                                                         const uint8_t * plain_data,
+                                                         uint32_t plain_data_length,
+                                                         uint8_t * encrypted_data,
+                                                         uint32_t * encrypted_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) ||
+           (NULL == plain_data) || (NULL == encrypted_data) || (NULL == encrypted_data_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value = optiga_crypt_symmetric_mode_generic(me,
+                                                           0,
+                                                           0,
+                                                           plain_data,
+                                                           plain_data_length,
+                                                           NULL,
+                                                           0,
+                                                           NULL,
+                                                           0,
+                                                           0,
+                                                           encrypted_data,
+                                                           encrypted_data_length,
+                                                           NULL,
+                                                           0,        
+                                                           OPTIGA_CRYPT_SYM_FINAL,
+                                                           OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                           OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION);
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+
+optiga_lib_status_t optiga_crypt_symmetric_encrypt_ecb(optiga_crypt_t * me,
+                                                       optiga_key_id_t symmetric_key_oid,
+                                                       const uint8_t * plain_data,
+                                                       uint32_t plain_data_length,
+                                                       uint8_t * encrypted_data,
+                                                       uint32_t * encrypted_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) ||
+           (NULL == plain_data) || (NULL == encrypted_data) || (NULL == encrypted_data_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value = optiga_crypt_symmetric_mode_generic(me,
+                                                           (uint8_t)OPTIGA_SYMMETRIC_ECB,
+                                                           (uint16_t)symmetric_key_oid,
+                                                           plain_data,
+                                                           plain_data_length,
+                                                           NULL,
+                                                           0,
+                                                           NULL,
+                                                           0,
+                                                           0,
+                                                           encrypted_data,
+                                                           encrypted_data_length,
+                                                           NULL,
+                                                           0,        
+                                                           OPTIGA_CRYPT_SYM_START_FINAL,
+                                                           OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                           OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION);
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+#endif //OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED
+
+#ifdef OPTIGA_CRYPT_SYM_DECRYPT_ENABLED
+
+optiga_lib_status_t optiga_crypt_symmetric_decrypt(optiga_crypt_t * me,
+                                                   optiga_symmetric_encryption_mode_t encryption_mode,
+                                                   optiga_key_id_t symmetric_key_oid,
+                                                   const uint8_t * encrypted_data,
+                                                   uint32_t encrypted_data_length,
+                                                   const uint8_t * iv,
+                                                   uint16_t iv_length,
+                                                   const uint8_t * associated_data,
+                                                   uint16_t associated_data_length,
+                                                   uint8_t * plain_data,
+                                                   uint32_t * plain_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == encrypted_data) || 
+            (NULL == plain_data) || (NULL == plain_data_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)encryption_mode,
+                                                            (uint16_t)symmetric_key_oid,
+                                                            encrypted_data,
+                                                            encrypted_data_length,
+                                                            iv,
+                                                            iv_length,
+                                                            associated_data,
+                                                            associated_data_length,
+                                                            0,
+                                                            plain_data,
+                                                            plain_data_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_START_FINAL,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_symmetric_decrypt_ecb(optiga_crypt_t * me,
+                                                       optiga_key_id_t symmetric_key_oid,
+                                                       const uint8_t * encrypted_data,
+                                                       uint32_t encrypted_data_length,
+                                                       uint8_t * plain_data,
+                                                       uint32_t * plain_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == plain_data) ||
+            (NULL == encrypted_data) || (NULL == plain_data_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)OPTIGA_SYMMETRIC_ECB,
+                                                            (uint16_t)symmetric_key_oid,
+                                                            encrypted_data,
+                                                            encrypted_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            plain_data,
+                                                            plain_data_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_START_FINAL,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION);
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_symmetric_decrypt_start(optiga_crypt_t * me,
+                                                         optiga_symmetric_encryption_mode_t encryption_mode,
+                                                         optiga_key_id_t symmetric_key_oid,
+                                                         const uint8_t * encrypted_data,
+                                                         uint32_t encrypted_data_length,
+                                                         const uint8_t * iv,
+                                                         uint16_t iv_length,
+                                                         const uint8_t * associated_data,
+                                                         uint16_t associated_data_length,
+                                                         uint16_t total_encrypted_data_length,
+                                                         uint8_t * plain_data,
+                                                         uint32_t * plain_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == encrypted_data) || 
+            (NULL == plain_data) || (NULL == plain_data_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)encryption_mode,
+                                                            (uint16_t)symmetric_key_oid,
+                                                            encrypted_data,
+                                                            encrypted_data_length,
+                                                            iv,
+                                                            iv_length,
+                                                            associated_data,
+                                                            associated_data_length,
+                                                            total_encrypted_data_length,
+                                                            plain_data,
+                                                            plain_data_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_START,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_symmetric_decrypt_continue(optiga_crypt_t * me,
+                                                            const uint8_t * encrypted_data,
+                                                            uint32_t encrypted_data_length,
+                                                            uint8_t * plain_data,
+                                                            uint32_t * plain_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == encrypted_data) ||
+            (NULL == plain_data) || (NULL == plain_data_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            0,
+                                                            0,
+                                                            encrypted_data,
+                                                            encrypted_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            plain_data,
+                                                            plain_data_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_CONTINUE,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_symmetric_decrypt_final(optiga_crypt_t * me,
+                                                         const uint8_t * encrypted_data,
+                                                         uint32_t encrypted_data_length,
+                                                         uint8_t * plain_data,
+                                                         uint32_t * plain_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == encrypted_data) ||
+            (NULL == plain_data) || (NULL == plain_data_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            0,
+                                                            0,
+                                                            encrypted_data,
+                                                            encrypted_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            plain_data,
+                                                            plain_data_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_FINAL,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+#endif //OPTIGA_CRYPT_SYM_DECRYPT_ENABLED
+
+#ifdef OPTIGA_CRYPT_HMAC_ENABLED
+
+optiga_lib_status_t optiga_crypt_hmac(optiga_crypt_t * me, 
+                                      optiga_hmac_type_t type, 
+                                      uint16_t secret, 
+                                      const uint8_t * input_data, 
+                                      uint32_t input_data_length, 
+                                      uint8_t * mac, 
+                                      uint32_t * mac_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == input_data) || 
+            (NULL == mac) || (NULL == mac_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)type,
+                                                            secret,
+                                                            input_data,
+                                                            input_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            mac,
+                                                            mac_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_START_FINAL,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                            OPTIGA_CRYPT_HMAC);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_hmac_start(optiga_crypt_t * me, 
+                                            optiga_hmac_type_t type, 
+                                            uint16_t secret, 
+                                            const uint8_t * input_data, 
+                                            uint32_t input_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == input_data))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)type,
+                                                            secret,
+                                                            input_data,
+                                                            input_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            NULL,
+                                                            NULL,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_START,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                            OPTIGA_CRYPT_HMAC);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_hmac_update(optiga_crypt_t * me,
+                                             const uint8_t * input_data,
+                                             uint32_t input_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == input_data))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            0,
+                                                            0,
+                                                            input_data,
+                                                            input_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            NULL,
+                                                            NULL,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_CONTINUE,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                            OPTIGA_CRYPT_HMAC);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_crypt_hmac_finalize(optiga_crypt_t * me,
+                                               const uint8_t * input_data,
+                                               uint32_t input_data_length,
+                                               uint8_t * mac, 
+                                               uint32_t * mac_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == input_data) || 
+            (NULL == mac) || (NULL == mac_length))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            0,
+                                                            0,
+                                                            input_data,
+                                                            input_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            mac,
+                                                            mac_length,
+                                                            NULL,
+                                                            0,        
+                                                            OPTIGA_CRYPT_SYM_FINAL,
+                                                            OPTIGA_CRYPT_SYMMETRIC_ENCRYPTION,
+                                                            OPTIGA_CRYPT_HMAC);
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    return (return_value);
+}
+
+#endif //OPTIGA_CRYPT_HMAC_ENABLED
+
+#ifdef OPTIGA_CRYPT_HKDF_ENABLED
+optiga_lib_status_t optiga_crypt_hkdf(optiga_crypt_t * me,
+                                      optiga_hkdf_type_t type,
+                                      uint16_t secret,
+                                      const uint8_t * salt,
+                                      uint16_t salt_length,
+                                      const uint8_t * info,
+                                      uint16_t info_length,
+                                      uint16_t derived_key_length,
+                                      bool_t export_to_host,
+                                      uint8_t * derived_key)
+{
+    
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || \
+           ((TRUE == export_to_host) && (NULL == derived_key)))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        return_value =  optiga_crypt_derive_key_generic(me,
+                                                        (uint8_t)type,
+                                                        secret,
+                                                        salt,
+                                                        salt_length,
+                                                        NULL,
+                                                        0,
+                                                        info,
+                                                        info_length,
+                                                        derived_key_length,
+                                                        export_to_host,
+                                                        derived_key);
+    } while(FALSE);
+    return (return_value);
+}
+
+#endif //OPTIGA_CRYPT_HKDF_ENABLED
+#ifdef OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+optiga_lib_status_t optiga_crypt_symmetric_generate_key(optiga_crypt_t * me,
+                                                        optiga_symmetric_key_type_t key_type,
+                                                        uint8_t key_usage,
+                                                        bool_t export_symmetric_key,
+                                                        void * symmetric_key)
+{
+    
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    optiga_gen_symkey_params_t * p_params;    
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == symmetric_key))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        
+        p_params = (optiga_gen_symkey_params_t *)&(me->params.optiga_gen_sym_key_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_crypt_params_t));
+        
+        p_params->key_usage = key_usage;
+        p_params->export_symmetric_key = export_symmetric_key;
+        p_params->symmetric_key = symmetric_key;
+        
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+        
+        return_value = optiga_cmd_gen_symkey(me->my_cmd,
+                                             (uint8_t)key_type,
+                                             p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+        
+    } while(FALSE);
+    optiga_crypt_reset_protection_level(me);
+    
+    return (return_value);
+}
+
+#endif //OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+
+#ifdef OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED
+optiga_lib_status_t optiga_crypt_generate_auth_code(optiga_crypt_t * me, 
+                                                    optiga_rng_type_t rng_type, 
+                                                    const uint8_t * optional_data, 
+                                                    uint16_t optional_data_length, 
+                                                    uint8_t * random_data, 
+                                                    uint16_t random_data_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+#define OPTIGA_CRYPT_MAX_AUTH_CODE_LENGTH   (0x42)
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == random_data))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        ///The minimum size of random stream is 8 bytes 
+        ///and the maximum size of (optional_data + random data) is 48 bytes.
+        if (( OPTIGA_CRYPT_MINIMUM_RANDOM_DATA_LENGTH > random_data_length) ||
+            ((optional_data_length + random_data_length) > OPTIGA_CRYPT_MAX_AUTH_CODE_LENGTH))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+
+        return_value = optiga_crypt_get_random(me,
+                                               (uint8_t)rng_type,
+                                               random_data,
+                                               random_data_length,
+                                               optional_data,
+                                               optional_data_length,
+                                               TRUE);
+    } while (FALSE);
+#undef OPTIGA_CRYPT_MAX_AUTH_CODE_LENGTH
+    return (return_value);
+}
+
+#endif //OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+
+#ifdef OPTIGA_CRYPT_HMAC_VERIFY_ENABLED
+optiga_lib_status_t optiga_crypt_hmac_verify(optiga_crypt_t * me,
+                                             optiga_hmac_type_t type,
+                                             uint16_t secret,
+                                             const uint8_t * input_data,
+                                             uint32_t input_data_length,
+                                             const uint8_t * hmac,
+                                             uint32_t hmac_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == input_data) || (NULL == hmac))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)type,
+                                                            secret,
+                                                            input_data,
+                                                            input_data_length,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            NULL,
+                                                            NULL,
+                                                            hmac,
+                                                            hmac_length,
+                                                            OPTIGA_CRYPT_SYM_START_FINAL,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION,
+                                                            OPTIGA_CRYPT_HMAC);
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+    
+    return (return_value);
+}
+#endif // OPTIGA_CRYPT_HMAC_VERIFY_ENABLED
+#ifdef OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED
+optiga_lib_status_t optiga_crypt_clear_auto_state(optiga_crypt_t * me,
+                                                  uint16_t secret)
+{
+    optiga_lib_status_t return_value = OPTIGA_CRYPT_ERROR;
+    OPTIGA_CRYPT_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd))
+        {
+            return_value = OPTIGA_CRYPT_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        return_value =  optiga_crypt_symmetric_mode_generic(me,
+                                                            (uint8_t)OPTIGA_HMAC_SHA_256,
+                                                            secret,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            NULL,
+                                                            0,
+                                                            0,
+                                                            NULL,
+                                                            NULL,
+                                                            NULL,
+                                                            0,
+                                                            OPTIGA_CRYPT_SYM_START_FINAL,
+                                                            OPTIGA_CRYPT_SYMMETRIC_DECRYPTION,
+                                                            OPTIGA_CRYPT_CLEAR_AUTO_STATE);
+    } while (FALSE);
+    optiga_crypt_reset_protection_level(me);
+    
+    return (return_value);
+}
+#endif // OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/cmd/optiga_cmd.h b/3rdparty/experimental/optiga/optiga/include/optiga/cmd/optiga_cmd.h
new file mode 100644
index 000000000..4d443bc18
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/cmd/optiga_cmd.h
@@ -0,0 +1,703 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_cmd.h
+*
+* \brief   This file defines APIs, types and data structures used in the Command (cmd) module implementation.
+*
+* \ingroup  grOptigaCmd
+*
+* @{
+*/
+
+#ifndef _OPTIGA_CMD_H_
+#define _OPTIGA_CMD_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/common/optiga_lib_common.h"
+
+/** \brief OPTIGA command instance structure type*/
+typedef struct optiga_cmd optiga_cmd_t;
+
+/** \brief OPTIGA comms instance structure type*/
+typedef struct optiga_context optiga_context_t;
+
+/**
+ * \brief Creates an instance of #optiga_cmd_t.
+ *
+ * \details
+ * Creates an instance of #optiga_cmd_t.
+ * - Stores the callers context and callback handler.<br>
+ * - Allocate memory for #optiga_cmd_t.<br>
+ * - Assigns OPTIGA structure based on the optiga instance.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] optiga_instance_id  Indicates the OPTIGA configuration to associate with instance.
+ * \param[in] handler             Pointer to callback function, must not be NULL.
+ * \param[in] caller_context      Pointer to upper layer context.
+ *
+ * \retval    #optiga_cmd_t *     On successful instance creation.
+ * \retval    NULL                Memory allocation failure.
+ *                                Already, OPTIGA_CMD_MAX_REGISTRATIONS number of instances is created.
+ */
+optiga_cmd_t * optiga_cmd_create(uint8_t optiga_instance_id,
+                                 callback_handler_t handler,
+                                 void * caller_context);
+
+/**
+ * \brief Destroys the instance of #optiga_cmd_t.
+ *
+ * \details
+ * Destroys the instance of #optiga_cmd_t.
+ * - Releases any OPTIGA cmd module lock utilized by the instance.<br>
+ * - Releases any OPTIGA session acquired by the instance.<br>
+ * - De-allocate the memory of the #optiga_cmd_t instance.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] me                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS     Successful destruction of instance.
+ */
+optiga_lib_status_t optiga_cmd_destroy(optiga_cmd_t * me);
+
+
+/**
+ * \brief Releases the OPTIGA cmd lock.
+ *
+ * \details
+ * Releases the OPTIGA cmd lock.
+ * - Release the OPTIGA lock acquired by the instance.<br>
+ * - If OPTIGA cmd lock request register in not empty, invoke the next registered caller handler with corresponding context.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] me                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *
+ * \retval    #OPTIGA_CMD_SUCCESS     Successful release of the access layer lock.
+ */
+optiga_lib_status_t optiga_cmd_release_lock(const optiga_cmd_t * me);
+
+
+/**
+ * \brief Opens the OPTIGA Application
+ *
+ * \details
+ * Opens the OPTIGA Application by issuing the OpenApplication command.
+ * - Acquires the OPTIGA lock for #optiga_util_open_application.<br>
+ * - Invokes #optiga_comms_open API to initialize OPTIGA and to establish the communication channel.<br>
+ * - Forms the OpenApplication commands based on inputs.<br>
+ * - Issues the OpenApplication command using #optiga_comms_transceive.<br>
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - This function must be mandatorily invoked before starting any interactions with OPTIGA after the reset.
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ * \param[in] me                                          Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ * \param[in] cmd_param                                   Param of Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ * \param[in] params                                      Secure connection related information, must not be NULL.
+ *
+ * \retval    #OPTIGA_CMD_SUCCESS                         Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                           Error occurred before invoking OpenApplication command.
+ *                                                        Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT       APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ */
+optiga_lib_status_t optiga_cmd_open_application(optiga_cmd_t * me,
+                                                uint8_t cmd_param,
+                                                void * params);
+
+/**
+ * \brief Closes the OPTIGA Application
+ *
+ * \details
+ * Closes the OPTIGA Application by issuing the CloseApplication command.
+ * - Acquires the OPTIGA lock for #optiga_util_close_application.<br>
+ * - Forms the CloseApplication commands based on inputs.<br>
+ * - Issues the CloseApplication command through #optiga_comms_transceive.<br>
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.<br>
+ *
+ * \note
+ * - This function must be mandatorily invoked before issuing a reset to OPTIGA, in case the context needs to be saved.
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ * \param[in] me                                          Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ * \param[in] cmd_param                                   Param of Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ * \param[in] params                                      Secure connection related information, must not be NULL.
+ *
+ * \retval    #OPTIGA_CMD_SUCCESS                         Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                           Error occurred before invoking CloseApplication command.
+ *                                                        Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT       APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ */
+optiga_lib_status_t optiga_cmd_close_application(optiga_cmd_t * me,
+                                                 uint8_t cmd_param,
+                                                 void * params);
+
+/**
+ * \brief Reads data or metadata of the specified data object
+ *
+ * \details
+ * Reads data or metadata of the specified data object, by issuing the GetDataObject command, based on input parameters.
+ * - Acquires the OPTIGA lock for #optiga_util_read_data/#optiga_util_read_metadata.<br>
+ * - Forms the ReadData/ReadMetaData commands based on inputs.<br>
+ * - Issues the ReadData/ReadMetaData command through #optiga_comms_transceive.<br>
+ * - In case the data to be read by the user is greater than the <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>,
+ *   the data is retrieved by internal chaining (by calling GetDataObject command multiple times).
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.<br>
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ *\param[in]  me                                          Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                                   Param of Get Data Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ *\param[in]  params                                      InData of Get Data Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_CMD_SUCCESS                         Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                           Error occurred before invoking GetDataObject command.
+ *                                                        Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT       Error due to insufficient buffer size.
+ *                                                        - APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ *                                                        - Data received from OPTIGA is greater than the buffer size provided by user.
+ */
+optiga_lib_status_t optiga_cmd_get_data_object(optiga_cmd_t * me,
+                                               uint8_t cmd_param,
+                                               optiga_get_data_object_params_t * params);
+
+/**
+ * \brief Writes data or metadata to the specified data object
+ *
+ * \details
+ * Writes data or metadata to the specified data object, by issuing the SetDataObject command, based on input parameters.
+ * - Acquires the OPTIGA lock for #optiga_util_write_data/#optiga_util_write_metadata.<br>
+ * - Forms the SetData/SetMetaData commands based on inputs.<br>
+ * - Issues the SetData/SetMetaData command through #optiga_comms_transceive.<br>
+ * - In case the data to be written by the user is greater than the <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>,
+ *   the data is written to the OPTIGA by internal chaining (by calling SetDataObject command multiple times).<br>
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.<br>
+ *
+ * \note
+ * - In case of failure, it is possible that partial data is written into the data object.<br>
+ *   In such a case, the user should decide if the data has to be re-written.
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ *\param[in]  me                                          Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                                   Param of Set Data Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ *\param[in]  params                                      InData of Set Data Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_CMD_SUCCESS                         Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                           Error occurred before invoking SetDataObject command.
+ *                                                        Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT       APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ */
+optiga_lib_status_t optiga_cmd_set_data_object(optiga_cmd_t * me,
+                                               uint8_t cmd_param,
+                                               optiga_set_data_object_params_t * params);
+
+#if defined (OPTIGA_CRYPT_RANDOM_ENABLED) || defined (OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED)
+/**
+ * \brief Generates random data or pre-master secret for RSA key exchange.
+ *
+ * \details
+ * Generates random data or pre-master secret for RSA key exchange, by issuing the GetRandom command to OPTIGA.
+ * - Acquires the OPTIGA session/lock for #optiga_crypt_rsa_generate_pre_master_secret/#optiga_crypt_random.<br>
+ * - For pre-master secret, it acquires a session, else acquires the lock.
+ * - Forms the GetRandom command based on inputs.<br>
+ * - Issues the GetRandom command through #optiga_comms_transceive.<br>
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.<br>
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ *\param[in] me                                           Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in] cmd_param                                    Param of Get Random Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ *\param[in] params                                       InData of Get Random Command APDU, must not be NULL.
+ *
+ * \retval   #OPTIGA_CMD_SUCCESS                          Successful invocation.
+ * \retval   #OPTIGA_CMD_ERROR                            Error occurred before invoking GetRandom command.
+ *                                                        Error in the asynchronous state machine.
+ * \retval   #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT        APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ */
+optiga_lib_status_t optiga_cmd_get_random(optiga_cmd_t * me,
+                                          uint8_t cmd_param,
+                                          optiga_get_random_params_t * params);
+#endif //OPTIGA_CRYPT_RANDOM_ENABLED || OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED
+
+#ifdef OPTIGA_CRYPT_HASH_ENABLED
+/**
+ * \brief Generates hash on external data or data in OID.
+ *
+ * \details
+ * Generates hash on external data or data in OID by issuing Calc Hash command to OPTIGA.
+ * - Acquires the OPTIGA lock for #optiga_crypt_hash_start/#optiga_crypt_hash_update/#optiga_crypt_hash_finalize.<br>
+ * - Forms the CalcHash command based on inputs.<br>
+ * - Issues the CalcHash command through #optiga_comms_transceive.<br>
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.
+ *
+ *\param[in] me                                           Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in] cmd_param                                    Param of CalcHash Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ *\param[in] params                                       InData of CalcHash Command APDU, must not be NULL.
+ *
+ * \retval   #OPTIGA_CMD_SUCCESS                          Successful invocation.
+ * \retval   #OPTIGA_CMD_ERROR                            Error occurred before invoking CalcHash command.<br>
+ *                                                        Error in the asynchronous state machine.
+ * \retval   #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT        Error due to insufficient buffer size.
+ *                                                        - APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ *                                                        - Data received from OPTIGA is greater than the buffer size provided by user.
+ */
+optiga_lib_status_t optiga_cmd_calc_hash(optiga_cmd_t * me,
+                                         uint8_t cmd_param,
+                                         optiga_calc_hash_params_t * params);
+#endif //OPTIGA_CRYPT_HASH_ENABLED
+
+#if defined (OPTIGA_CRYPT_ECDSA_SIGN_ENABLED) || defined (OPTIGA_CRYPT_RSA_SIGN_ENABLED)
+/**
+ * \brief Calculate signature on digest.
+ *
+ * \details
+ * Calculate signature on digest by issuing Calc Sign command to OPTIGA.
+ * - Acquires the OPTIGA session/lock for #optiga_crypt_rsa_sign.<br>
+ * - Forms the Generate KeyPair command based on inputs.<br>
+ * - Issues the Generate KeyPair command through #optiga_comms_transceive.
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ *\param[in]  me                                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                               Param of Calc Sign Command APDU.
+ *                                                    - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ *\param[in]  params                                  InData of Calc Sign Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_CMD_SUCCESS                     Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                       Error occurred before invoking Calc Sign command.<br>
+ *                                                    Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_INVALID_INPUT         Instance invoked for session oid, without acquiring the session (from #optiga_cmd_gen_keypair).
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT   Error due to insufficient buffer size.
+ *                                                    - APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ *                                                    - Length of the buffer to copy the signature is less than actual length of signature.
+ */
+optiga_lib_status_t optiga_cmd_calc_sign(optiga_cmd_t * me,
+                                         uint8_t cmd_param,
+                                         optiga_calc_sign_params_t * params);
+#endif //OPTIGA_CRYPT_ECDSA_SIGN_ENABLED || OPTIGA_CRYPT_RSA_SIGN_ENABLED
+
+#if defined (OPTIGA_CRYPT_ECDSA_VERIFY_ENABLED) || defined (OPTIGA_CRYPT_RSA_VERIFY_ENABLED)
+/**
+ * \brief Verifies the signature over the given digest.
+ *
+ * \details
+ * Verifies the signature over the given digest by issuing VerifySign command.
+ * - Acquires the OPTIGA lock for #optiga_crypt_rsa_verify.<br>
+ * - Forms the VerifySign command based on inputs and invokes the optiga_comms_transceive to send the same to OPTIGA.
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.<br>
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ *\param[in]  me                                          Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                                   Param of VerifySign Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ *\param[in]  params                                      Parameters for InData of VerifySign Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_CMD_SUCCESS                         Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                           Error occurred before invoking VerifySign command.<br>
+ *                                                        Error in the asynchronous state machine.
+ * \retval   #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT        APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ */
+optiga_lib_status_t optiga_cmd_verify_sign(optiga_cmd_t * me,
+                                           uint8_t cmd_param,
+                                           optiga_verify_sign_params_t * params);
+#endif //OPTIGA_CRYPT_ECDSA_VERIFY_ENABLED || OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+
+#ifdef OPTIGA_CRYPT_ECDH_ENABLED
+/**
+ * \brief Calculates shared secret.
+ *
+ * \details
+ * Calculates shared secret by issuing CalcSSec command to OPTIGA.
+ * - Acquires the OPTIGA session/lock for #optiga_crypt_ecdh.<br>
+ * - Forms the command apdu based on inputs.<br>
+ * - Issues the command through #optiga_comms_transceive.<br>
+ * - If the private key is session based or shared secret is to be stored in OPTIGA, it acquires a session if not already available.<br>
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application.
+ * - A key pair must be generated/available in the given private key ID.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ *\param[in] me                                           Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in] cmd_param                                    Param of Calc SSec Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ *\param[in] params                                       Pointer to input parameters, must not be NULL.
+ *
+ * \retval   #OPTIGA_LIB_SUCCESS                          Successful invocation of optiga_comms module.
+ * \retval   #OPTIGA_CMD_ERROR                            Error occurred before invoking CalcSSec command <br>
+ *                                                        #optiga_comms_transceive returned a failure <br>
+ *                                                        Error in the asynchronous state machine.
+ * \retval   #OPTIGA_CMD_ERROR_INVALID_INPUT              Instance invoked for session oid, without acquiring the session (from #optiga_cmd_gen_keypair).
+ * \retval   #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT        APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ */
+optiga_lib_status_t optiga_cmd_calc_ssec(optiga_cmd_t * me,
+                                         uint8_t cmd_param,
+                                         optiga_calc_ssec_params_t * params);
+#endif //OPTIGA_CRYPT_ECDH_ENABLED
+
+#if defined (OPTIGA_CRYPT_TLS_PRF_ENABLED) || defined (OPTIGA_CRYPT_HKDF_ENABLED)
+/**
+ * \brief Derives a key.
+ *
+ * \details
+ * Derives a key by issuing DeriveKey command to OPTIGA.
+ * - Acquires the OPTIGA session/lock for #optiga_crypt_ecdh.<br>
+ * - Issues the calculate shared secret command through #optiga_comms_transceive.
+ * - Based on the shared secret location in OPTIGA and target storage, it requests to acquire a session.
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ * - A key pair should be generated for the input object ID.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.
+ *
+ *\param[in]  me                                          Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                                   Param of Derive Key Command APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.
+ *\param[in]  params                                      InData of derive key Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS                         Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                           Error occurred before invoking derive key command <br>
+ *                                                        optiga comms transceive returned a failure <br>
+ *                                                        Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_INVALID_INPUT             Instance invoked for session oid, without acquiring the session(from #optiga_cmd_calc_ssec).
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT       APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ */
+optiga_lib_status_t optiga_cmd_derive_key(optiga_cmd_t * me,
+                                          uint8_t cmd_param,
+                                          optiga_derive_key_params_t * params);
+#endif //OPTIGA_CRYPT_TLS_PRF_ENABLED
+
+#if defined (OPTIGA_CRYPT_ECC_GENERATE_KEYPAIR_ENABLED) || defined (OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED)
+/**
+ * \brief Generates RSA key-pair.
+ *
+ * \details
+ * Generate RSA key-pair by issuing Generate KeyPair command to OPTIGA.
+ * - Acquires the OPTIGA session/lock for #optiga_crypt_rsa_generate_keypair.<br>
+ * - Forms the Generate KeyPair command based on inputs.
+ * - Issues the Generate KeyPair command through #optiga_comms_transceive.
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.
+ *
+ *\param[in]  me                                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                               Param of Generate KeyPair Command APDU.
+ *                                                    - Must be valid argument, otherwise OPTIGA returns an error.
+ *\param[in]  params                                  InData of Generate KeyPair Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS                     Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                       Error occurred before invoking Generate KeyPair command.<br>
+ *                                                    Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT   Error due to insufficient buffer size.
+ *                                                    - APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ *                                                    - Length of the buffer to copy the key is less than actual length of key.
+ */
+optiga_lib_status_t optiga_cmd_gen_keypair(optiga_cmd_t * me,
+                                           uint8_t cmd_param,
+                                           optiga_gen_keypair_params_t * params);
+#endif //(OPTIGA_CRYPT_ECC_GENERATE_KEYPAIR_ENABLED) || (OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED)
+
+#ifdef OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+/**
+ * \brief Encrypt data using RSA public key.
+ *
+ * \details
+ * Encrypts data using RSA public key by issuing Encrypt Asym command to OPTIGA.
+ * - Acquires the OPTIGA session/lock for #optiga_crypt_rsa_encrypt_message/#optiga_crypt_rsa_encrypt_session.<br>
+ * - Forms the Encrypt Asym command based on inputs.
+ * - Issues the Encrypt Asym command through #optiga_comms_transceive.
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.
+ *
+ *\param[in]  me                                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                               Param of Encrypt Asym Command APDU.
+ *                                                    - Must be valid argument, otherwise OPTIGA returns an error.
+ *\param[in]  params                                  InData of Encrypt Asym Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS                     Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                       Error occurred before invoking Encrypt Asym command.<br>
+ *                                                    Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_INVALID_INPUT         Instance invoked for encrypting session, without acquiring the session
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT   Error due to insufficient buffer size.
+ *                                                    - APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ *                                                    - Length of the buffer to copy the encrypted data is less than buffer to copy it into.
+ */
+optiga_lib_status_t optiga_cmd_encrypt_asym(optiga_cmd_t * me,
+                                            uint8_t cmd_param,
+                                            optiga_encrypt_asym_params_t * params);
+#endif // OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+/**
+ * \brief Decrypts data using OPTIGA RSA private key.
+ *
+ * \details
+ * Decrypts data using OPTIGA RSA private key by issuing Decrypt Asym command to OPTIGA.
+ * - Acquires the OPTIGA session/lock for #optiga_crypt_rsa_decrypt_and_export/#optiga_crypt_rsa_decrypt_and_store.<br>
+ * - Forms the Decrypt Asym command based on inputs.
+ * - Issues the Decrypt Asym command through #optiga_comms_transceive.
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.
+ *
+ *\param[in]  me                                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                               Param of Decrypt Asym Command APDU.
+ *                                                    - Must be valid argument, otherwise OPTIGA returns an error.
+ *\param[in]  params                                  InData of Decrypt Asym Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS                     Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                       Error occurred before invoking Decrypt Asym command.<br>
+ *                                                    Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT   Error due to insufficient buffer size.
+ *                                                    - APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ *                                                    - Length of the buffer to copy the decrypted data is less than buffer to copy it into.
+ */
+optiga_lib_status_t optiga_cmd_decrypt_asym(optiga_cmd_t * me,
+                                            uint8_t cmd_param,
+                                            optiga_decrypt_asym_params_t * params);
+#endif // OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+
+/**
+ * \brief Writes protected object fragments to OPTIGA.
+ *
+ * \details
+ * Writes manifest or data fragement(s) to the specified data object, by issuing the SetObjectProtected command, in a securely.
+ * - Acquires the strict sequence for #optiga_util_protected_update_start.<br>
+ * - Forms the SetObjectProtected commands based on inputs.<br>
+ * - Issues the SetObjectProtected command through #optiga_comms_transceive.<br>
+ * - Releases the strict sequence in case of an error or after #optiga_util_protected_update_final is successfully completed.
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.<br>
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ *\param[in]  me                                          Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                                   Param of Set Object Protected APDU.
+ *                                                        - Must be valid argument, otherwise OPTIGA returns an error.<br>
+ *\param[in]  params                                      InData of Set Object Protected APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_CMD_SUCCESS                         Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                           Error occurred before invoking SetObjectProtected command.
+ *                                                        Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT       APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ * \retval    #OPTIGA_CMD_ERROR_INVALID_INPUT             Continue and final APDU command invoked without strict lock acquired for the instance.
+ */
+optiga_lib_status_t optiga_cmd_set_object_protected(optiga_cmd_t * me,
+                                                    uint8_t cmd_param,
+                                                    optiga_set_object_protected_params_t * params);
+                                                    
+#if defined (OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED) || defined (OPTIGA_CRYPT_HMAC_ENABLED)
+/**
+ * \brief Encrypt data using #optiga_symmetric_encryption_mode_t encryption scheme.
+ *
+ * \details
+ * Encrypts data using selected encryption scheme by issuing Encrypt Sym command to OPTIGA.
+ * - Acquires the strict sequence.
+ * - Forms the Encrypt Sym command based on inputs.
+ * - Issues the Encrypt Sym command through #optiga_comms_transceive.
+ * - Releases the strict sequence in case of an error or after #optiga_crypt_symmetric_encrypt_final is successfully completed.
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.
+ *
+ *\param[in]  me                                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                               Param of Encrypt Sym Command APDU.
+ *                                                    - Must be valid argument, otherwise OPTIGA returns an error.
+ *\param[in]  params                                  InData of Encrypt Sym Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS                     Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                       Error occurred before invoking Encrypt Sym command.<br>
+ *                                                    Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_INVALID_INPUT         Continue and final APDU command invoked without strict lock acquired for the instance.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT   Error due to insufficient buffer size.
+ *                                                    - Length of the buffer to copy the encrypted data is less than buffer to copy it into.
+ */
+optiga_lib_status_t optiga_cmd_encrypt_sym(optiga_cmd_t * me,
+                                           uint8_t cmd_param,
+                                           optiga_encrypt_sym_params_t * params);
+#endif
+
+#if defined (OPTIGA_CRYPT_SYM_DECRYPT_ENABLED) || defined (OPTIGA_CRYPT_HMAC_VERIFY_ENABLED) ||\
+    defined (OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED)
+/**
+ * \brief Decrypt data using #optiga_symmetric_encryption_mode_t encryption scheme.
+ *
+ * \details
+ * Decrypts data using selected encryption scheme by issuing Decrypt Sym command to OPTIGA.
+ * - Acquires the strict sequence.
+ * - Forms the Decrypt Sym command based on inputs.
+ * - Issues the Decrypt Sym command through #optiga_comms_transceive.
+ * - Releases the strict sequence in case of an error or after #optiga_crypt_symmetric_decrypt_final is successfully completed.
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.
+ *
+ *\param[in]  me                                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                               Param of Decrypt Sym Command APDU.
+ *                                                    - Must be valid argument, otherwise OPTIGA returns an error.
+ *\param[in]  params                                  InData of Decrypt Sym Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS                     Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                       Error occurred before invoking Encrypt Sym command.<br>
+ *                                                    Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_INVALID_INPUT         Continue and final APDU command invoked without strict lock acquired for the instance.
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT   Error due to insufficient buffer size.
+ *                                                    - Length of the buffer to copy the encrypted data is less than buffer to copy it into.
+ */
+optiga_lib_status_t optiga_cmd_decrypt_sym(optiga_cmd_t * me,
+                                           uint8_t cmd_param,
+                                           optiga_decrypt_sym_params_t * params);
+#endif
+
+#ifdef OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+/**
+ * \brief Generate symmetric key using OPTIGA.
+ *
+ * \details
+ * Generate symmetric key by issuing Generate Symmetric Key command to OPTIGA.
+ * - Acquires the OPTIGA lock for #optiga_crypt_symmetric_generate_key.<br> 
+ * - Forms the Generate Symmetric Key command based on inputs.
+ * - Issues the Generate Symmetric Key command through #optiga_comms_transceive.
+ * - Releases the OPTIGA lock on successful completion of asynchronous operation.<br>
+ *
+ * \pre
+ * - Application on OPTIGA must be opened using #optiga_cmd_open_application before using this API.
+ *
+ * \note
+ * - Error codes from lower layers will be returned as it is.
+ *
+ *\param[in]  me                                      Valid instance of #optiga_cmd_t created using #optiga_cmd_create.
+ *\param[in]  cmd_param                               Param of Gen Sym Key Command APDU.
+ *                                                    - Must be valid argument, otherwise OPTIGA returns an error.
+ *\param[in]  params                                  InData of Gen Sym Key Command APDU, must not be NULL.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS                     Successful invocation.
+ * \retval    #OPTIGA_CMD_ERROR                       Error occurred before invoking Gen Sym Key command.<br>
+ *                                                    Error in the asynchronous state machine.
+ * \retval    #OPTIGA_CMD_ERROR_INVALID_INPUT         Instance invoked for encrypting session, without acquiring the session
+ * \retval    #OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT   Error due to insufficient buffer size.
+ *                                                    - APDU length formed is greater than <b>OPTIGA_MAX_COMMS_BUFFER_SIZE</b>.
+ */
+optiga_lib_status_t optiga_cmd_gen_symkey(optiga_cmd_t * me,
+                                          uint8_t cmd_param,
+                                          optiga_gen_symkey_params_t * params);
+#endif // OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_CMD_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_common.h b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_common.h
new file mode 100644
index 000000000..eee6002b2
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_common.h
@@ -0,0 +1,659 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_lib_common.h
+*
+* \brief   This file provides the prototypes for the commonly used functions and structures of OPTIGA Library.
+*
+* \ingroup  grOptigaLibCommon
+*
+* @{
+*/
+
+#ifndef _OPTIGA_LIB_COMMON_H_
+#define _OPTIGA_LIB_COMMON_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/optiga_lib_config.h"
+#include "optiga/common/optiga_lib_types.h"
+#include "optiga/common/optiga_lib_return_codes.h"
+
+///Instance id of OPTIGA slave
+#define OPTIGA_INSTANCE_ID_0                              (0x00)
+
+/** @brief When command data and response data is unprotected */
+#define OPTIGA_COMMS_NO_PROTECTION                        (0x00)
+/** @brief When command data is protected and response data is unprotected */
+#define OPTIGA_COMMS_COMMAND_PROTECTION                   (0x01)
+/** @brief When command data is unprotected and response data is protected */
+#define OPTIGA_COMMS_RESPONSE_PROTECTION                  (0x02)
+/** @brief Both command data and response data are protected */
+#define OPTIGA_COMMS_FULL_PROTECTION                      (0x03)
+/** @brief Re-establish shielded connection */
+#define OPTIGA_COMMS_RE_ESTABLISH                         (0x80)
+/** @brief Pre shared secret protocol version */
+#define OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET   (0x01)
+
+/** @brief Data is provided by host*/
+#define OPTIGA_CRYPT_HOST_DATA                            (0x01)
+/** @brief Data in internal to optiga OID */
+#define OPTIGA_CRYPT_OID_DATA                             (0x00)
+
+/** @brief OPTIGA instance is busy */
+#define OPTIGA_LIB_INSTANCE_BUSY                          (0x0001)
+/** @brief OPTIGA instance is free */
+#define OPTIGA_LIB_INSTANCE_FREE                          (0x0000)
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+/** @brief Configure shielded connection protection level for instance */
+#define OPTIGA_COMMS_PROTECTION_LEVEL                     (0x01)
+/** @brief Configure shielded connection protocol version for instance */
+#define OPTIGA_COMMS_PROTOCOL_VERSION                     (0x02)
+#endif
+
+/**
+ * \brief Specifies the key location in OPTIGA.
+ */
+typedef enum optiga_key_id
+{
+    /// Key from key store for RSA (non-volatile)
+    OPTIGA_KEY_ID_E0FC = 0xE0FC,
+    /// Key from key store for RSA (non-volatile)
+    OPTIGA_KEY_ID_E0FD = 0xE0FD,
+    /// Key from session (volatile)
+    OPTIGA_KEY_ID_SESSION_BASED = 0x0000,
+    /// Key from key store for symmetric operations
+    OPTIGA_KEY_ID_SECRET_BASED = 0xE200
+} optiga_key_id_t;
+
+/**
+ * \brief Specifies the key usage type in OPTIGA.
+ */
+typedef enum optiga_key_usage
+{
+    /// This enables the private key for the signature generation as part of authentication commands
+    OPTIGA_KEY_USAGE_AUTHENTICATION = 0x01,
+    /// This enables the private key for the signature generation
+    OPTIGA_KEY_USAGE_SIGN = 0x10,
+    /// This enables the private key for encrypt and decrypt
+    OPTIGA_KEY_USAGE_ENCRYPTION = 0x02,
+} optiga_key_usage_t;
+
+/**
+ * \brief Specifies the set protected object tag.
+ */
+typedef enum optiga_set_obj_protected_tag
+{
+    /// This enables to start of the protected update
+    OPTIGA_SET_PROTECTED_UPDATE_START = 0x00,
+    /// This enables to continue of the protected update
+    OPTIGA_SET_PROTECTED_UPDATE_CONTINUE = 0x02,
+    /// This enables to finish of the protected update
+    OPTIGA_SET_PROTECTED_UPDATE_FINAL = 0x01
+} optiga_set_obj_protected_tag_t;
+
+/**
+ * \brief Specifies the RSA encryption schemes.
+ */
+typedef enum optiga_rsa_encryption_scheme
+{
+    /// RSA PKCS1 v1.5 encryption scheme
+    OPTIGA_RSAES_PKCS1_V15 = 0x11
+} optiga_rsa_encryption_scheme_t;
+
+/**
+ * \brief Specifies the RSA key type in OPTIGA.
+ */
+typedef enum optiga_rsa_key_type
+{
+    /// Generate 1024 bit RSA key
+    OPTIGA_RSA_KEY_1024_BIT_EXPONENTIAL = 0x41,
+    /// Generate 2048 bit RSA key
+    OPTIGA_RSA_KEY_2048_BIT_EXPONENTIAL = 0x42
+} optiga_rsa_key_type_t;
+
+
+/**
+ * \brief Specifies the RSA signature schemes type in OPTIGA.
+ */
+typedef enum optiga_rsa_signature_scheme
+{
+    /// Signature schemes RSA SSA PKCS1-v1.5 with SHA256 digest
+    OPTIGA_RSASSA_PKCS1_V15_SHA256 = 0x01,
+    /// Signature schemes RSA SSA PKCS1-v1.5 with SHA384 digest
+    OPTIGA_RSASSA_PKCS1_V15_SHA384 = 0x02,
+    /// Signature schemes RSA SSA PKCS1-v1.5 with SHA512 digest
+    OPTIGA_RSASSA_PKCS1_V15_SHA512 = 0x03
+}optiga_rsa_signature_scheme_t;
+
+/**
+ * \brief Specifies the symmetric encryption schemes type in OPTIGA.
+ */
+typedef enum optiga_symmetric_encryption_mode
+{
+    /// Symmetric encryption mode with ECB mode
+    OPTIGA_SYMMETRIC_ECB = 0x08,
+    /// Symmetric encryption mode with CBC mode
+    OPTIGA_SYMMETRIC_CBC = 0x09,
+    /// Symmetric encryption mode with CBC_MAC mode
+    OPTIGA_SYMMETRIC_CBC_MAC = 0x0A,
+    /// Symmetric encryption mode with CMAC mode
+    OPTIGA_SYMMETRIC_CMAC = 0x0B
+}optiga_symmetric_encryption_mode_t;
+
+/**
+ * \brief Specifies the hashing algorithm type in OPTIGA.
+ */
+typedef enum optiga_hash_type
+{
+    /// Hash algorithm type SHA256
+    OPTIGA_HASH_TYPE_SHA_256 = 0xE2
+} optiga_hash_type_t;
+
+/**
+ * \brief Specifies the hash context length in bytes.
+ */
+typedef enum optiga_hash_context_length
+{
+    /// Hash context length (in bytes) in case of SHA256.
+    OPTIGA_HASH_CONTEXT_LENGTH_SHA_256 = 209 
+} optiga_hash_context_length_t; 
+
+/**
+ * \brief Specifies the random generation types
+ */
+typedef enum optiga_rng_type
+{
+    /// Generate Random data using TRNG
+    OPTIGA_RNG_TYPE_TRNG = 0x00,
+    /// Generate Random data using DRNG
+    OPTIGA_RNG_TYPE_DRNG = 0x01
+} optiga_rng_type_t;
+
+/**
+ * \brief Specifies the HMAC generation types in OPTIGA.
+ */
+typedef enum optiga_hmac_type
+{
+    /// Generated MAC using HMAC-SHA256
+    OPTIGA_HMAC_SHA_256 = 0x20,
+    /// Generated MAC using HMAC-SHA384
+    OPTIGA_HMAC_SHA_384 = 0x21,
+    /// Generated MAC using HMAC-SHA512
+    OPTIGA_HMAC_SHA_512 = 0x22
+}optiga_hmac_type_t;
+
+/**
+ * \brief Specifies the HKDF key derivation types in OPTIGA.
+ */
+typedef enum optiga_hkdf_type
+{
+    /// Key derivation using HKDF-SHA256
+    OPTIGA_HKDF_SHA_256 = 0x08,
+    /// Key derivation using HKDF-SHA384
+    OPTIGA_HKDF_SHA_384 = 0x09,
+    /// Key derivation using HKDF-SHA512
+    OPTIGA_HKDF_SHA_512 = 0x0A
+}optiga_hkdf_type_t;
+
+/**
+ * \brief Specifies the key derivation types.
+ */
+typedef enum optiga_tls_prf_type
+{
+    /// Key derivation using TLSv1.2 PRF SHA256
+    OPTIGA_TLS12_PRF_SHA_256 = 0x01,
+    /// Key derivation using TLSv1.2 PRF SHA384
+    OPTIGA_TLS12_PRF_SHA_384 = 0x02,
+    /// Key derivation using TLSv1.2 PRF SHA512
+    OPTIGA_TLS12_PRF_SHA_512 = 0x03
+}optiga_tls_prf_type_t;
+
+/**
+ * \brief Specifies the symmetric key types supported by OPTIGA.
+ */
+typedef enum optiga_symmetric_key_type
+{
+    /// Symmetric key type of AES-128
+    OPTIGA_SYMMETRIC_AES_128 = 0x81,
+    /// Symmetric key type of AES-192
+    OPTIGA_SYMMETRIC_AES_192 = 0x82,
+    /// Symmetric key type of AES-256
+    OPTIGA_SYMMETRIC_AES_256 = 0x83
+}optiga_symmetric_key_type_t;
+
+/**
+ * \brief Specifies the structure to the Hash context details managed by OPTIGA.
+ */
+typedef struct optiga_hash_context
+{
+    ///buffer to hold the hash context data
+    uint8_t *context_buffer;
+    ///context length
+    uint16_t context_buffer_length;
+    ///hashing algorithm
+    uint8_t hash_algo;
+} optiga_hash_context_t;
+
+/**
+ * \brief Specifies the structure to provide the details of data to be hashed from host.
+ */
+typedef struct hash_data_from_host
+{
+    /// data to hash
+    const uint8_t * buffer;
+    /// Length of data
+    uint32_t length;
+} hash_data_from_host_t;
+
+/**
+ * \brief Specifies the structure to provide the details of data to be hashed from OPTIGA.
+ */
+typedef struct hash_data_in_optiga
+{
+    ///OID of data object
+    uint16_t oid;
+    ///Offset within the data object
+    uint16_t offset;
+    ///Number of data bytes starting from the offset
+    uint16_t length;
+} hash_data_in_optiga_t;
+
+/**
+ * \brief Specifies the data structure of the Public Key details (key, size and type)
+ */
+typedef struct public_key_from_host
+{
+    /// Pointer to Public Key
+    uint8_t * public_key;
+    /// Length of public key buffer
+    uint16_t length;
+    /// Public key type details. For RSA key use #optiga_rsa_key_type_t
+    uint8_t key_type;
+} public_key_from_host_t;
+
+/**
+ * \brief Specifies the data structure for data to be read from OPTIGA
+ */
+typedef struct optiga_get_data_object
+{
+    /// Object ID to be read
+    uint16_t oid;
+    /// Offset of data with the object ID
+    uint16_t offset;
+    /// Data size to be read
+    uint16_t bytes_to_read;
+    /// Contains length of data received in across multiple transceive calls. Used for chaining purpose
+    uint16_t accumulated_size;
+    /// Contains the data length received in last transceive. Used for chaining purpose
+    uint16_t last_read_size;
+    /// Read to data or metadata
+    uint8_t data_or_metadata;
+    /// Pointer to the read buffer length
+    uint16_t * ref_bytes_to_read;
+    /// Read data buffer pointer
+    uint8_t * buffer;
+} optiga_get_data_object_params_t;
+
+/**
+ * \brief Specifies the data structure for data to be written to OPTIGA
+ */
+typedef struct optiga_set_data_object
+{
+    /// Object ID to be written
+    uint16_t oid;
+    /// Offset of data with the object ID
+    uint16_t offset;
+    /// Write data size
+    uint16_t size;
+    /// Contains length of data written in across multiple transceive calls. Used for chaining purpose
+    uint16_t written_size;
+    /// Wrtie data buffer pointer
+    const uint8_t * buffer;
+    /// Write to data or metadata
+    uint8_t data_or_metadata;
+    /// Type of write - Write only or Erase and write
+    uint8_t write_type;
+    ///Count value
+    uint8_t count;
+} optiga_set_data_object_params_t;
+
+/**
+ * \brief Specifies the data structure of calculate hash
+ */
+typedef struct optiga_calc_hash
+{
+    ///OID hash pointer
+    hash_data_in_optiga_t * p_hash_oid;
+    ///Data buffer pointer
+    hash_data_from_host_t * p_hash_data;
+    /// Context buffer pointer
+    optiga_hash_context_t * p_hash_context;
+    ///Type of hash operation
+    uint8_t hash_sequence;
+    ///Current type of hash operation
+    uint8_t current_hash_sequence;    
+    ///Data length has been sent
+    uint32_t data_sent;
+    ///Out digest
+    uint8_t * p_out_digest;
+    ///export hash ctx
+    bool_t export_hash_ctx;
+    ///Possible context size to send in a fragment
+    uint32_t apparent_context_size;
+} optiga_calc_hash_params_t;
+
+
+/**
+ * \brief Specifies the data structure of random generation
+ */
+typedef struct optiga_get_random
+{
+    /// Random data length
+    uint16_t random_data_length;
+    /// Optional data length
+    uint16_t optional_data_length; 
+    /// User buffer for storing random data
+    uint8_t * random_data;
+    /// User buffer which holds the optional data
+    const uint8_t * optional_data;
+    /// Use to indicate to acquire session
+    bool_t store_in_session;
+} optiga_get_random_params_t;
+
+
+/**
+ * \brief Specifies the data structure for generate key pair
+ */
+typedef struct optiga_gen_keypair
+{
+    /// Key usage type
+    uint8_t key_usage;
+    /// Private key export option
+    bool_t export_private_key;
+    /// Type of public key OID
+    optiga_key_id_t private_key_oid;
+    ///  Private key buffer pointer
+    uint8_t * private_key;
+    /// Private key length
+    uint16_t * private_key_length;
+    /// Public key buffer pointer
+    uint8_t * public_key;
+    /// Public key length
+    uint16_t * public_key_length;
+} optiga_gen_keypair_params_t;
+
+/**
+ * \brief Specifies the data structure for signature
+ */
+typedef struct optiga_calc_sign
+{
+    /// Digest buffer pointer
+    const uint8_t * p_digest;
+    /// Signature buffer pointer
+    uint8_t * p_signature;
+    /// Signature length
+    uint16_t * p_signature_length;
+    /// OID of the Private Key (either Key store or Session based). Refer #optiga_key_id_t for possible values.
+    optiga_key_id_t private_key_oid;
+    /// Digest data length
+    uint8_t digest_length;
+} optiga_calc_sign_params_t;
+
+/**
+ * \brief Specifies the data structure for signature verification
+ */
+typedef struct optiga_verify_sign
+{
+    /// Digest buffer pointer
+    const uint8_t * p_digest;
+    /// Digest data length
+    uint8_t digest_length;
+    /// Signature buffer pointer
+    const uint8_t * p_signature;
+    /// Signature data length
+    uint16_t signature_length;
+    /// Source of provided public key
+    uint8_t public_key_source_type;
+    /// Public key provided by host
+    public_key_from_host_t * public_key;
+    /// Public key certificate OID
+    uint16_t certificate_oid;
+} optiga_verify_sign_params_t;
+
+/**
+ * \brief Specifies the structure for derivation of key using pseudo random function
+ */
+typedef struct optiga_derive_key
+{
+    /// Random Seed/Salt
+    const uint8_t * random_data;
+    /// Label input as a constant string
+    const uint8_t * label;
+    /// Application specific info
+    const uint8_t * info;    
+    /// Pointer to a buffer where the exported key to be stored.
+    uint8_t * derived_key;
+    /// Session based (#optiga_key_id_t) or Data object which has the pre-shared secret
+    uint16_t input_shared_secret_oid;
+    /// Random Seed/Salt length
+    uint16_t random_data_length;
+    /// Label length
+    uint16_t label_length;
+    /// Info length
+    uint16_t info_length;
+    /// Derived Key length
+    uint16_t derived_key_length;
+}optiga_derive_key_params_t;
+
+/**
+ * \brief Specifies the structure for asymmetric encryption and decryption
+ */
+typedef struct optiga_enc_dec_asym
+{
+    /// Length of message to be encrypted. Set 0 if data from session OID
+    uint16_t message_length;
+    /// Pointer to the length of the encrypted or decrypted message
+    uint16_t * processed_message_length;
+    /// Message to be encrypted. Set NULL if data from session OID
+    const uint8_t * message;
+    /// Source of provided public key for encryption and Private key for decryption
+    uint8_t public_key_source_type;
+    /// Public key provided by host
+    const void * key;
+    /// Pointer to buffer where encrypted or decrypted message is stored
+    uint8_t * processed_message;
+    /// Store private key OID
+    optiga_key_id_t private_key_id;
+}optiga_encrypt_asym_params_t,optiga_decrypt_asym_params_t;
+
+
+
+/**
+ * \brief Specifies the data structure for protected update
+ */
+typedef struct optiga_set_object_protected_params
+{
+    /// Pointer to the buffer which contains manifest/fragment
+    const uint8_t * p_protected_update_buffer;
+    /// Manifest/Fragment length
+    uint16_t p_protected_update_buffer_length;
+    /// Set protected object tag
+    optiga_set_obj_protected_tag_t set_obj_protected_tag;
+    /// manifest version
+    uint8_t manifest_version;
+} optiga_set_object_protected_params_t;
+
+/**
+ * \brief Specifies the data structure for symmetric encrypt and decrypt
+ */
+typedef struct optiga_symmetric_enc_dec_params
+{
+    /// Symmetric key OID
+    uint16_t symmetric_key_oid;
+    /// Pointer to plain text
+    const uint8_t * in_data;
+    /// Length of plain text
+    uint32_t in_data_length;
+    /// Pointer to initialization vector
+    const uint8_t * iv;
+    /// Length of initialization vector
+    uint16_t iv_length;
+    /// Pointer to associated data
+    const uint8_t * associated_data;
+    /// Length of associated data
+    uint16_t associated_data_length;
+    /// Pointer to output data
+    uint8_t * out_data;
+    /// Length of output data
+    uint32_t * out_data_length;
+    /// Pointer to generated hmac
+    const uint8_t * generated_hmac;
+    /// Requested sequence
+    uint8_t  original_sequence;
+    /// Variable to store current encrypt decrypt sequence
+    uint8_t  current_sequence;
+    /// Length of sent data
+    uint32_t sent_data_length;
+    /// Length of received data
+    uint32_t received_data_length;
+    /// Variable to indicate complete input data length required for CCM
+    uint16_t total_input_data_length;
+    /// Length of generated hmac
+    uint32_t generated_hmac_length;
+    /// Encryption or hmac mode
+    uint8_t mode;
+    /// Symmetric mode of operation
+    uint8_t operation_mode;
+} optiga_encrypt_sym_params_t,optiga_decrypt_sym_params_t;
+
+/**
+ * \brief Specifies the data structure for symmetric generate key 
+ */
+typedef struct optiga_gen_symkey_params
+{
+    /// Key usage type
+    uint8_t key_usage;
+    /// Symmetric key export option
+    bool_t export_symmetric_key;
+    /// Symmetric key buffer pointer or oid pointer
+    void * symmetric_key;
+} optiga_gen_symkey_params_t;
+
+/**
+ * \brief Prepares uint32 [Big endian] type value from the buffer and store
+ *
+ * \details
+ * Prepares uint32 [Big endian] type value from the buffer and store
+ * - Return first 4 bytes from input buffer as uint32_t.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in]  p_input_buffer          Pointer to the buffer
+ *
+ * \retval     return 32 bit value
+ *
+ */
+uint32_t optiga_common_get_uint32(const uint8_t* p_input_buffer);
+
+/**
+ * \brief Copies 2 bytes of uint16 type value to the buffer
+ *
+ * \details
+ * Copies 2 bytes of uint16 type value to the buffer
+ * - Copies the 2 bytes value to input buffer in big endian format.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out]  p_output_buffer         Pointer to the buffer
+ * \param[in]      two_byte_value          16 bit value
+ *
+ */
+void optiga_common_set_uint16(uint8_t * p_output_buffer,
+                              uint16_t two_byte_value);
+
+/**
+ * \brief Copies 4 bytes of uint32 [Big endian] type value to the buffer and stores in the output pointer
+ *
+ * \details
+ * Copies 4 bytes of uint32 [Big endian] type value to the buffer and store
+ * - Copies the 4 bytes value to input buffer in big endian format.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out]  p_output_buffer          Pointer to the buffer
+ * \param[in]      four_byte_value          32 bit value
+ *
+ */
+void optiga_common_set_uint32(uint8_t* p_output_buffer,
+                              uint32_t four_byte_value);
+
+/**
+ * \brief Prepares uint16 [Big endian] type value from the buffer and stores in the output pointer
+ *
+ * \details
+ * Prepares uint16 [Big endian] type value from the buffer and store
+ * - Return first 2 bytes from input buffer as uint16_t.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in]      p_input_buffer    Pointer to the buffer
+ * \param[in,out]  p_two_byte_value  Pointer to the value tobe assigne
+ *
+ */
+void optiga_common_get_uint16(const uint8_t * p_input_buffer,
+                              uint16_t* p_two_byte_value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_LIB_COMMON_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_common_internal.h b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_common_internal.h
new file mode 100644
index 000000000..996c33c1e
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_common_internal.h
@@ -0,0 +1,113 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_lib_common_internal.h
+*
+* \brief   This file provides the prototypes for the commonly used internal functions and structures of OPTIGA Library.
+*
+* \ingroup  grOptigaLibCommon
+*
+* @{
+*/
+
+#ifndef _OPTIGA_LIB_COMMON_INTERNAL_H_
+#define _OPTIGA_LIB_COMMON_INTERNAL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/optiga_lib_config.h"
+
+/// Determines the minimum of two values
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
+/** @brief For hash input as start */
+#define OPTIGA_CRYPT_HASH_START                         (0x00)
+/** @brief For hash input as start and final */
+#define OPTIGA_CRYPT_HASH_START_FINAL                   (0x01)
+/** @brief For hash input as continue */
+#define OPTIGA_CRYPT_HASH_CONTINUE                      (0x02)
+/** @brief For hash input as final */
+#define OPTIGA_CRYPT_HASH_FINAL                         (0x03)
+/** @brief For hash input as intermediate hash context */
+#define OPTIGA_CRYPT_INTERMEDIATE                       (0x06)
+/** @brief For hash input as hash context out */
+#define OPTIGA_CRYPT_HASH_CONTX_OUT                     (0x07)
+/** @brief For hash input as hash oid */
+#define OPTIGA_CRYPT_HASH_FOR_OID                       (0x10)
+
+/** @brief To restore saved secure session */
+#define OPTIGA_COMMS_SESSION_CONTEXT_RESTORE            (0x11)
+/** @brief To store active secure session */
+#define OPTIGA_COMMS_SESSION_CONTEXT_SAVE               (0x22)
+/** @brief For no manage context operation */
+#define OPTIGA_COMMS_SESSION_CONTEXT_NONE               (0x33)
+
+/** @brief For symetric encrypt, dectypt or hmac input as start */
+#define OPTIGA_CRYPT_SYM_START                          (0x00)
+/** @brief For symetric encrypt, dectypt or hmac input as start and final */
+#define OPTIGA_CRYPT_SYM_START_FINAL                    (0x01)
+/** @brief For symetric encrypt, dectypt or hmac input as continue */
+#define OPTIGA_CRYPT_SYM_CONTINUE                       (0x02)
+/** @brief For symetric encrypt, dectypt or hmac input as final */
+#define OPTIGA_CRYPT_SYM_FINAL                          (0x03)
+
+/// @cond hidden
+/// Option to write count value to the data object
+#define OPTIGA_UTIL_COUNT_DATA_OBJECT                   (0x02)
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+/// To set protection level in cmd instance
+#define OPTIGA_SET_PROTECTION_LEVEL                     (0x00)
+/// To set protocol version in cmd instance
+#define OPTIGA_SET_PROTECTION_VERSION                   (0x01)
+/// To set manage context in cmd instance
+#define OPTIGA_SET_MANAGE_CONTEXT                       (0x02)
+    /** @brief Enables the protected I2C communication with OPTIGA for command instances */
+    #define OPTIGA_PROTECTION_ENABLE(p_mycmd, p_protection_mode)  { optiga_cmd_set_shielded_connection_option(p_mycmd, p_protection_mode->protection_level,OPTIGA_SET_PROTECTION_LEVEL) ;}
+    /** @brief Select the protocol version required for the I2C protected communication for command instances */
+    #define OPTIGA_PROTECTION_SET_VERSION(p_mycmd, p_version) {optiga_cmd_set_shielded_connection_option(p_mycmd , p_version->protocol_version,OPTIGA_SET_PROTECTION_VERSION);}
+    /** @brief Select the OPTIGA comms session context save and restore option for command instances */
+    #define OPTIGA_PROTECTION_MANAGE_CONTEXT(p_mycmd, operation) {optiga_cmd_set_shielded_connection_option(p_mycmd ,operation,OPTIGA_SET_MANAGE_CONTEXT);}
+#else
+    #define OPTIGA_PROTECTION_ENABLE(p_instance, p_protection_mode)  { }
+    #define OPTIGA_PROTECTION_SET_VERSION(p_instance, p_version) {}
+    #define OPTIGA_PROTECTION_MANAGE_CONTEXT(p_instance, p_operation) {}
+#endif
+/// @endcond
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_LIB_COMMON_INTERNAL_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_logger.h b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_logger.h
new file mode 100644
index 000000000..78bfa4fbf
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_logger.h
@@ -0,0 +1,241 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file    optiga_lib_logger.h
+*
+* \brief   This file provides the prototypes for the OPTIGA library logger.
+*
+* \ingroup grOptigaLibCommon
+*
+* @{
+*/
+
+#ifndef _OPTIGA_LIB_LOGGER_H_
+#define _OPTIGA_LIB_LOGGER_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/common/optiga_lib_types.h"
+
+//Logger levels
+#define OPTIGA_UTIL_SERVICE                          "[optiga util]     : "
+#define OPTIGA_CRYPT_SERVICE                         "[optiga crypt]    : "
+#define OPTIGA_COMMAND_LAYER                         "[optiga cmd]      : "
+#define OPTIGA_COMMUNICATION_LAYER                   "[optiga comms]    : "
+
+
+// Logger colors options
+#define OPTIGA_LIB_LOGGER_COLOR_RED                  "\x1b[31m"
+#define OPTIGA_LIB_LOGGER_COLOR_GREEN                "\x1b[32m"
+#define OPTIGA_LIB_LOGGER_COLOR_YELLOW               "\x1b[33m"
+#define OPTIGA_LIB_LOGGER_COLOR_BLUE                 "\x1b[34m"
+#define OPTIGA_LIB_LOGGER_COLOR_MAGENTA              "\x1b[35m"
+#define OPTIGA_LIB_LOGGER_COLOR_CYAN                 "\x1b[36m"
+#define OPTIGA_LIB_LOGGER_COLOR_LIGHT_GREY           "\x1b[90m"
+#define OPTIGA_LIB_LOGGER_COLOR_LIGHT_RED            "\x1b[91m"
+#define OPTIGA_LIB_LOGGER_COLOR_LIGHT_GREEN          "\x1b[92m"
+#define OPTIGA_LIB_LOGGER_COLOR_LIGHT_YELLOW         "\x1b[93m"
+#define OPTIGA_LIB_LOGGER_COLOR_LIGHT_BLUE           "\x1b[94m"
+#define OPTIGA_LIB_LOGGER_COLOR_LIGHT_MAGENTA        "\x1b[95m"
+#define OPTIGA_LIB_LOGGER_COLOR_LIGHT_CYAN           "\x1b[96m"
+#define OPTIGA_LIB_LOGGER_COLOR_DEFAULT              "\x1b[0m"
+
+// Logger color for different layers and data
+#define OPTIGA_UTIL_SERVICE_COLOR                    OPTIGA_LIB_LOGGER_COLOR_DEFAULT
+#define OPTIGA_CRYPT_SERVICE_COLOR                   OPTIGA_LIB_LOGGER_COLOR_DEFAULT
+#define OPTIGA_COMMAND_LAYER_COLOR                   OPTIGA_LIB_LOGGER_COLOR_DEFAULT
+#define OPTIGA_COMMUNICATION_LAYER_COLOR             OPTIGA_LIB_LOGGER_COLOR_DEFAULT
+#define OPTIGA_ERROR_COLOR                           OPTIGA_LIB_LOGGER_COLOR_RED
+#define OPTIGA_UNPROTECTED_DATA_COLOR                OPTIGA_LIB_LOGGER_COLOR_LIGHT_CYAN
+#define OPTIGA_PROTECTED_DATA_COLOR                  OPTIGA_LIB_LOGGER_COLOR_YELLOW
+
+#define OPTIGA_HEX_BYTE_SEPERATOR         ""
+/**
+ * \brief To log a string
+ *
+ * \details
+ * To log a string.
+ * -
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] input_string        Pointer to the log string
+ *
+ */
+void optiga_lib_print_string(const char_t *input_string);
+
+/**
+ * \brief To log a string with a new line
+ *
+ * \details
+ * To log a string with a new line
+ * -
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_log_string        Pointer to the log string
+ *
+ */
+void optiga_lib_print_string_with_newline(const char_t * p_log_string);
+
+/**
+ * \brief To log a string with a new line and layer information.
+ *
+ * \details
+ * To log a string with information of the layer from which it is invoked and with a new line
+ * -
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_log_string       Pointer to the log string 
+ * \param[in] p_log_layer        Pointer to the invoked layer information
+ * \param[in] p_log_color        Pointer to the color of log string
+ *
+ */
+void optiga_lib_print_message(const char_t * p_log_string,
+                              const char_t * p_log_layer,
+                              const char_t * p_log_color);
+
+/**
+ * \brief To log a return value with a new line and layer information.
+ *
+ * \details
+ * To log a if the return value was successful or not along with layer information
+ * -
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_log_layer        Pointer to the invoked layer information
+ * \param[in] p_log_color        Pointer to the color of log string
+ * \param[in] return_value       Return value from the invoked layer
+ *
+ */
+void optiga_lib_print_status(const char_t * p_log_layer,
+                             const char_t * p_log_color,
+                             uint16_t return_value);
+/**
+ * \brief To log the byte array in hex format
+ *
+ * \details
+ * To log the byte array in hex format
+ * -
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_log_string        Pointer to the array string
+ * \param[in] length              Length of the array buffer
+ * \param[in] p_log_color         Pointer to the color of array string
+ *
+ */
+void optiga_lib_print_array_hex_format(const uint8_t * p_log_string,
+                                       uint16_t length,
+                                       const char_t * p_log_color);
+
+/**
+ * \brief Converts the input array buffer to encode the color specified
+ *
+ * \details
+ * Converts the input array buffer  to encode the color specified
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[out] p_output_buffer    Pointer to output buffer
+ * \param[in]  p_temp_buffer      Pointer to the input array buffer
+ * \param[in]  p_color            Pointer to the color of array string
+ */
+#define OPTIGA_LIB_LOGGER_PRINT_ARRAY(p_output_buffer, p_temp_buffer, p_color) \
+{ \
+    sprintf((char_t *)p_output_buffer, \
+            "%25s%s%s", \
+            p_color, \
+            p_temp_buffer, \
+            OPTIGA_LIB_LOGGER_COLOR_DEFAULT); \
+}
+
+/**
+ * \brief Converts the input string to encode the color specified
+ *
+ * \details
+ * Converts the input string to encode the color specified
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[out] p_output_buffer    Pointer to output buffer   
+ * \param[in]  p_temp_buffer      Pointer to the input array buffer
+ * \param[in]  p_layer            Pointer to the layer info buffer
+ * \param[in]  p_color            Pointer to the color of array string 
+ */
+#define OPTIGA_LIB_LOGGER_PRINT_INFO(p_output_buffer, p_temp_buffer, p_layer, p_color) \
+{ \
+    sprintf((char_t *)p_output_buffer, \
+            "%s%s%s%s", \
+            p_color, \
+            p_layer, \
+            p_temp_buffer, \
+            OPTIGA_LIB_LOGGER_COLOR_DEFAULT); \
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_LIB_LOGGER_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_return_codes.h b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_return_codes.h
new file mode 100644
index 000000000..2ef9f8b3f
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_return_codes.h
@@ -0,0 +1,140 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_lib_return_codes.h
+*
+* \brief   This file defines the error codes for the all the layers and modules.<br>
+* <b>OPTIGA host library return value Decoding</b><br>
+* The definition of the Error code layering for a 2 byte error code explained below.<br>
+* Each error code is represented as <b>[AB][CD]</b>, where each byte is represented as <b>[ ]</b> and individual alphabets represent a nibble.<br>
+* <b>A  :</b> Error indication <b>Bit 15</b>. Set to 1 indicates error from OPTIGA security chip <br>
+* <b>B  :</b> Layer information <b>Bits [14 - 8]</b>. This indicates the layer from which the error originated. E.g. OPTIGA, PAL, Comms, Util, Crypt etc.<br>
+* <b>CD :</b> Return code <b>Bits [7 - 0]</b>. This indicates the actual nature of error.
+*
+* \ingroup  grOptigaLibCommon
+*
+* @{
+*
+*/
+
+
+#ifndef _OPTIGA_LIB_RETURN_CODES_H_
+#define _OPTIGA_LIB_RETURN_CODES_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+///OPTIGA host library API execution is successful
+#define OPTIGA_LIB_SUCCESS                          (0x0000)
+///OPTIGA host library in busy state
+#define OPTIGA_LIB_BUSY                             (0x0001)
+
+/**
+ * OPTIGA device errors
+ */
+///OPTIGA Device Error to return OPTIGA security chip specific error codes (Refer Solution reference manual for details)
+#define OPTIGA_DEVICE_ERROR                         (0x8000)
+
+/**
+ * OPTIGA comms module return values
+ */
+///OPTIGA comms API execution is successful
+#define OPTIGA_COMMS_SUCCESS                        (0x0000)
+///OPTIGA comms in busy state
+#define OPTIGA_COMMS_BUSY                           (0x0001)
+///OPTIGA comms API failed
+#define OPTIGA_COMMS_ERROR                          (0x0102)
+///OPTIGA comms API called with invalid inputs
+#define OPTIGA_COMMS_ERROR_INVALID_INPUT            (0x0103)
+///OPTIGA comms API called with insufficient memory buffer
+#define OPTIGA_COMMS_ERROR_MEMORY_INSUFFICIENT      (0x0104)
+/// Protocol stack memory insufficient
+#define OPTIGA_COMMS_ERROR_STACK_MEMORY             (0x0105)
+/// Protocol fatal error
+#define OPTIGA_COMMS_ERROR_FATAL                    (0x0106)
+/// Presentation layer handshake error
+#define OPTIGA_COMMS_ERROR_HANDSHAKE                (0x0107)
+/// Presentation layer session error
+#define OPTIGA_COMMS_ERROR_SESSION                  (0x0108)
+
+/**
+ * OPTIGA command module return values
+ */
+///OPTIGA command API execution is successful
+#define OPTIGA_CMD_SUCCESS                          (0x0000)
+///OPTIGA command module in busy state
+#define OPTIGA_CMD_BUSY                             (0x0001)
+///OPTIGA command API failed
+#define OPTIGA_CMD_ERROR                            (0x0202)
+///OPTIGA command API called with invalid inputs
+#define OPTIGA_CMD_ERROR_INVALID_INPUT              (0x0203)
+///OPTIGA command API called with insufficient memory buffer
+#define OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT        (0x0204)
+
+/**
+ * OPTIGA util module return values
+ */
+///OPTIGA util API execution is successful
+#define OPTIGA_UTIL_SUCCESS                         (0x0000)
+///OPTIGA util module in busy state
+#define OPTIGA_UTIL_BUSY                            (0x0001)
+///OPTIGA util API failed
+#define OPTIGA_UTIL_ERROR                           (0x0302)
+///OPTIGA util API called with invalid inputs
+#define OPTIGA_UTIL_ERROR_INVALID_INPUT             (0x0303)
+///OPTIGA util API called with insufficient memory buffer
+#define OPTIGA_UTIL_ERROR_MEMORY_INSUFFICIENT       (0x0304)
+///OPTIGA util API called when, a request of same instance is already in service
+#define OPTIGA_UTIL_ERROR_INSTANCE_IN_USE           (0x0305)
+
+/**
+ * OPTIGA crypt module return values
+ */
+///OPTIGA crypt API execution is successful
+#define OPTIGA_CRYPT_SUCCESS                        (0x0000)
+///OPTIGA crypt module in busy state
+#define OPTIGA_CRYPT_BUSY                           (0x0001)
+///OPTIGA crypt API failed
+#define OPTIGA_CRYPT_ERROR                          (0x0402)
+///OPTIGA crypt API called with invalid inputs
+#define OPTIGA_CRYPT_ERROR_INVALID_INPUT            (0x0403)
+///OPTIGA crypt API called with insufficient memory buffer
+#define OPTIGA_CRYPT_ERROR_MEMORY_INSUFFICIENT      (0x0404)
+///OPTIGA crypt API called when, a request of same instance is already in service
+#define OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE          (0x0405)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_LIB_RETURN_CODES_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_types.h b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_types.h
new file mode 100644
index 000000000..32c0c40f6
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/common/optiga_lib_types.h
@@ -0,0 +1,131 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_lib_types.h
+*
+* \brief   This file contains the type definitions for the fundamental data types.
+*
+* \ingroup grOptigaLibCommon
+*
+* @{
+*/
+
+#ifndef _OPTIGA_LIB_TYPES_H_
+#define _OPTIGA_LIB_TYPES_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+/// @cond hidden
+#ifdef _OPTIGA_EXPORTS_DLLEXPORT_H_
+
+#ifdef OPTIGA_LIB_EXPORTS
+#define LIBRARY_EXPORTS __declspec(dllexport)
+#else
+#define LIBRARY_EXPORTS __declspec(dllimport)
+#endif  // OPTIGA_LIB_EXPORTS
+
+#else
+#define LIBRARY_EXPORTS 
+#endif /*_OPTIGA_EXPORTS_DLLEXPORT_H_*/
+/// @endcond
+
+/// Definition for false
+#ifndef FALSE
+#define FALSE               (0U)
+#endif
+
+/// Definition for true
+#ifndef TRUE
+#define TRUE                (1U)
+#endif
+
+/// Typedef for one byte integer
+typedef char        char_t;
+
+/// Typedef for a double word
+typedef double    double_t;
+
+/// Typedef for a float
+typedef float   float_t;
+
+/// Typedef for a boolean
+typedef uint8_t     bool_t;
+
+/// typedef for handles
+typedef void *  hdl_t;
+
+/// typedef for OPTIGA host library status
+typedef uint16_t optiga_lib_status_t;
+
+/// Typedef for a void
+typedef void            Void;
+
+/// typedef for application event handler
+typedef void (*upper_layer_callback_t)(void* upper_layer_ctx, optiga_lib_status_t event);
+
+/// typedef for event callback handler
+typedef void (*callback_handler_t)(void* callback_ctx, optiga_lib_status_t event);
+
+/**
+ * \brief Structure to specify a byte stream consisting of length and data pointer.
+ */
+typedef struct data_blob
+{
+    /// Pointer to byte array which contains the data stream
+    uint8_t *data_ptr;
+    /// Length of the byte stream
+    uint16_t length;
+} data_blob_t;
+
+
+#ifndef _NO_STATIC_H
+#define _STATIC_H static
+#else
+#define _STATIC_H
+#endif
+
+#ifndef _STATIC_INLINE
+#define _STATIC_INLINE              static inline
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OPTIGA_LIB_TYPES_H_  */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/comms/optiga_comms.h b/3rdparty/experimental/optiga/optiga/include/optiga/comms/optiga_comms.h
new file mode 100644
index 000000000..3b37b54d5
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/comms/optiga_comms.h
@@ -0,0 +1,342 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_comms.h
+*
+* \brief   This file implements Optiga comms abstraction layer for IFX I2C Protocol.
+*
+* \ingroup  grOptigaComms
+*
+* @{
+*/
+
+
+#ifndef _OPTIGA_COMMS_H_
+#define _OPTIGA_COMMS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/common/optiga_lib_types.h"
+#include "optiga/common/optiga_lib_return_codes.h"
+#include "optiga/common/optiga_lib_common.h"
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+// Offset for data
+#define OPTIGA_COMMS_DATA_OFFSET         (0x05)
+// Overhead buffer size for user buffer
+#define OPTIGA_COMMS_PRL_OVERHEAD        (0x0D)
+#else
+#define OPTIGA_COMMS_DATA_OFFSET         (0x00)
+#define OPTIGA_COMMS_PRL_OVERHEAD        (0x00)
+#endif
+
+/** @brief Optiga comms structure */
+typedef struct optiga_comms
+{
+    /// Comms structure pointer
+    void * p_comms_ctx;
+    /// Upper layer context
+    void * p_upper_layer_ctx;
+    /// Upper layer handler
+    upper_layer_callback_t upper_layer_handler;
+    /// Holds the instance initialization state
+    uint8_t instance_init_state;
+    /// OPTIGA comms state
+    uint8_t state;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+    /// To provide the encryption and decryption need for command and response
+    uint8_t protection_level;
+    /// To provide the presentation layer protocol version to be used
+    uint8_t protocol_version;
+    /// To provide the option to save and restore the optiga comms presentation layer context
+    uint8_t manage_context_operation;
+#endif
+    /// Pointer to the pal os event instance/context
+    void * p_pal_os_event_ctx;
+} optiga_comms_t;
+
+/** @brief optiga communication structure */
+extern optiga_comms_t optiga_comms;
+
+/**
+ * \brief Provides the singleton OPTIGA instance.
+ *
+ * \details
+ * Creates an instance of #optiga_comms_t.
+ * - Stores the callers context and callback handler.
+ * - Allocate memory for #optiga_comms_t.
+ * - Assigns OPTIGA structure based on the Optiga instance.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] callback            Pointer to callback function, must not be NULL
+ * \param[in] context             Pointer to upper layer context.
+ *
+ * \retval    #optiga_comms_t *   On successful instance creation
+ * \retval    NULL                Memory allocation failure
+ */
+optiga_comms_t * optiga_comms_create(callback_handler_t callback,
+                                     void * context);
+
+/**
+ * \brief Deinitializes the OPTIGA comms instance
+ *
+ * \details
+ * Destroys the instance of #optiga_comms_t.
+ * - Releases any OPTIGA cmd module lock utilized by the instance.
+ * - Releases any OPTIGA session acquired by the instance.
+ * - Deallocates the memory of the #optiga_comms_t instance.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] optiga_comms         Valid instance of #optiga_comms_t created using #optiga_comms_create
+ *
+ */
+void optiga_comms_destroy(optiga_comms_t * optiga_comms);
+
+/**
+ * \brief Sets the callers context to OPTIGA comms instance
+ *
+ * \details
+ * Sets the callers context to #optiga_comms_t.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_optiga_comms         Valid instance of #optiga_comms_t created using #optiga_comms_create
+ * \param[in] context                Pointer to callers context
+ *
+ */
+optiga_lib_status_t optiga_comms_set_callback_context(optiga_comms_t * p_optiga_comms,
+                                                      void *context);
+
+/**
+ * \brief Sets the callback handler to OPTIGA comms instance
+ *
+ * \details
+ * Sets the callback handler to #optiga_comms_t instance.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_optiga_comms         Valid instance of #optiga_comms_t created using #optiga_comms_create
+ * \param[in] handler                Pointer to callback handler
+ */
+optiga_lib_status_t optiga_comms_set_callback_handler(optiga_comms_t * p_optiga_comms,
+                                                      callback_handler_t handler);
+/**
+ * \brief Opens the communication channel with OPTIGA.
+ *
+ * \details
+ * Initializes the communication with OPTIGA
+ * - Initializes OPTIGA and establishes the communication channel.
+ * - Initializes the IFX I2C protocol stack and registers the event callbacks.
+ * - Negotiates the frame size and bit rate with the OPTIGA.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - The following parameters in #ifx_i2c_context_t must be initialized with appropriate values <br>
+ *   - <b>slave address</b> : Address of I2C slave
+ *   - <b>frame_size</b> : Frame size in bytes. Minimum supported value is 16 bytes.<br>
+ *              - It is recommended not to use a value greater than the slave's frame size.
+ *              - The user specified frame size is written to I2C slave's frame size register.
+ *                The frame size register is read back from I2C slave.
+ *                This frame value is used by the IFX-I2C protocol even if it is not equal to the user specified value.
+ *
+ *   - <b>frequency</b> : Frequency/speed of I2C master in KHz.
+ *              - This must be lowest of the maximum frequency supported by the devices (master/slave) connected on the bus.
+ *              - Initial negotiation starts with a frequency of 100KHz.
+ *              - If the user specified frequency is more than 400 KHz, the I2C slave is configured to operate in "Fm+" mode,
+ *                otherwise the I2C slave is configured for "SM & Fm" mode. <br>
+ *              - If the user specified frequency negotiation fails, the I2C master frequency remains at 100KHz<br>
+ *
+ *   - <b>upper_layer_event_handler</b> : Upper layer event handler. This is invoked when #ifx_i2c_open() is asynchronously completed.
+ *   - <b>upper_layer_ctx</b> : Context of upper layer.
+ *   - <b>p_slave_vdd_pin</b> : GPIO pin for VDD. If not set, cold reset is not done.
+ *   - <b>p_slave_reset_pin</b> : GPIO pin for Reset. If not set, warm reset is not done.
+ *   - <b>manage_contex_operation</b> : Used for managing session context and the values must be as defined below. The value of the parameter is not modified by the IFX-I2C protocol stack.
+ *       - #OPTIGA_COMMS_SESSION_CONTEXT_RESTORE : Restore any stored session context.
+ *       - #OPTIGA_COMMS_SESSION_CONTEXT_NONE : No manage context operation.
+ * - The values of registers MAX_SCL_FREQU and DATA_REG_LEN, read from slave are not validated.
+ * - At present, only single instance of #ifx_i2c_context_t is supported.
+ * - Manage context operations will start in next transceive.
+ *
+ * \param[in,out] p_ctx                     Valid instance of #optiga_comms_t created using #optiga_comms_create
+ *
+ * \retval        #OPTIGA_COMMS_SUCCESS
+ * \retval        #OPTIGA_COMMS_ERROR
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_comms_open(optiga_comms_t * p_ctx);
+
+
+/**
+ * \brief Resets the OPTIGA
+ *
+ * \details
+ * Resets the communication channel with OPTIGA.
+ * - Resets the OPTIGA device.
+ * - Initializes the IFX I2C protocol stack.
+ * - Re-Initializes and negotiates the frame size and bit rate with the OPTIGA.
+ *   The values remain same as that in previous #optiga_comms_open().
+ *
+ * \pre
+ * - Communication channel must be established with OPTIGA.
+ *
+ * \note
+ * - This function clears the saved context.
+ *
+ * \param[in,out] p_ctx                     Valid instance of #optiga_comms_t created using #optiga_comms_create
+ * \param[in,out] reset_type                Type of reset
+ *                                          - For COLD and WARM reset type: If the GPIO(VDD and/or reset) pins are not configured,<br>
+ *                                            the API continues without returning error status<br>
+ *
+ * \retval        #OPTIGA_COMMS_SUCCESS
+ * \retval        #OPTIGA_COMMS_ERROR
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_comms_reset(optiga_comms_t * p_ctx, uint8_t reset_type);
+
+/**
+ * \brief Sends and receives the APDU.
+ *
+ * \details
+ * Sends a command to OPTIGA and receives a response.
+ * - Transmit data(Command) to OPTIGA.
+ * - Receive data(Response) from OPTIGA.
+ *
+ * \pre
+ * - Communication channel must be established with OPTIGA
+ *
+ * \note
+ * - The following parameters in #optiga_comms_t must be initialized with appropriate values <br>
+ *      - The <b>comms_ctx</b> must be initialized with a valid #ifx_i2c_context_t<br>
+ *      - The <b>upper_layer_event_handler</b> parameter must be properly initialized,
+ *          if it is different from that in #optiga_comms_open().
+ *          This is invoked when optiga_comms_transceive is asynchronously completed.<br>
+ *      - The <b>upper_layer_ctx</b> must be properly initialized,
+ *          if it is different from that in #optiga_comms_open().
+ *      - <b>protection_level</b> : Used for secure communication.The value of the parameter is not modified by the IFX-I2C protocol stack.
+ *      - The values for <b>protection_level</b> must be one of the below
+ *        - #OPTIGA_COMMS_NO_PROTECTION : Command and response is unprotected
+ *        - #OPTIGA_COMMS_COMMAND_PROTECTION : Command is protected and response is unprotected
+ *        - #OPTIGA_COMMS_RESPONSE_PROTECTION : Command is unprotected and response is protected
+ *        - #OPTIGA_COMMS_FULL_PROTECTION : Both command and response is protected
+ *        - To re-establish secure channel, bitwise-OR protection_level with #OPTIGA_COMMS_RE_ESTABLISH
+ *   - If Presentation Layer is enabled,
+ *       - Additional buffer size is required to handle encryption and decryption functionality.
+ *   - The total buffer size with the additional presentation layer overhead is explained in the figure below. Please provide the lengths and data buffers as specified below.
+ *       - The transmit and receive data buffers need additional overhead of #OPTIGA_COMMS_PRL_OVERHEAD bytes along with Tx/Rx data(payload) size.
+ *       - Provide the command data, starting from the #OPTIGA_COMMS_DATA_OFFSET location in the transmit buffer.
+ *       - In the receive buffer, the response (received data) from the OPTIGA will be stored from the #OPTIGA_COMMS_DATA_OFFSET location. Read the response from this offset.
+ *       - Provide the length of command data (tx_data_length) with the payload length excluding the additional overhead.
+ *       - Provide the length of response data (p_rx_data_length) in order to copy the response to the buffer provided.
+ *
+ *
+ * \image html optiga_comms_trancv_buffer.png "optiga_comms_transceive()" width=0cm
+ *
+ * - The actual number of bytes received is stored in p_rx_buffer_len. In case of error,p_rx_buffer_len is set to 0.<br>
+ * - If the size of p_rx_data is zero or insufficient to copy the response bytes, #OPTIGA_COMMS_ERROR_STACK_MEMORY error is returned.
+ * - If establishing a secure channel fails, #OPTIGA_COMMS_ERROR_HANDSHAKE is returned.
+ * - If #OPTIGA_COMMS_ERROR_SESSION is returned, a new session must be established.
+ * - If presentation layer is enabled and the command data protection is selected,
+ *   the input data provided will be modified because the data will be encrypted in the same input buffer.
+ *   Therefore, if required by the user a copy of the input data must be preserved by the caller of this API.
+ *
+ *
+ *
+ * \param[in,out] p_ctx                              Valid instance of #optiga_comms_t created using #optiga_comms_create
+ * \param[in]     p_tx_data                          Pointer to the transmit data buffer
+ * \param[in]     tx_data_length                     Length of the transmit data buffer
+ * \param[in,out] p_rx_data                          Pointer to the receive data buffer
+ * \param[in,out] p_rx_data_len                      Pointer to the length of the receive data buffer
+ *
+ * \retval        #OPTIGA_COMMS_SUCCESS
+ * \retval        #OPTIGA_COMMS_ERROR
+ * \retval        #OPTIGA_COMMS_ERROR_STACK_MEMORY
+ * \retval        #OPTIGA_COMMS_ERROR_HANDSHAKE
+ * \retval        #OPTIGA_COMMS_ERROR_SESSION
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_comms_transceive(optiga_comms_t * p_ctx,
+                                                            const uint8_t * p_tx_data,
+                                                            uint16_t tx_data_length,
+                                                            uint8_t * p_rx_data,
+                                                            uint16_t * p_rx_data_len);
+
+/**
+ * \brief Closes the communication channel with OPTIGA.
+ *
+ * \details
+ * Closes the communication with OPTIGA.
+ * - De-Initializes the OPTIGA and closes the communication channel.
+ * - Power downs the OPTIGA.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - The #optiga_comms_t comms_ctx must be initialized with a valid #ifx_i2c_context<br>
+ * - <b>manage_contex_operation</b> : Used for managing session context and the values must be as defined below. The value of the parameter is not modified by the IFX-I2C protocol stack.
+ *   - #OPTIGA_COMMS_SESSION_CONTEXT_SAVE : save active secure session.
+ *   - #OPTIGA_COMMS_SESSION_CONTEXT_NONE : for no manage context operation.
+ *
+ * \param[in,out] p_ctx                   Valid instance of #optiga_comms_t created using #optiga_comms_create
+ *
+ * \retval        #OPTIGA_COMMS_SUCCESS
+ * \retval        #OPTIGA_COMMS_ERROR
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_comms_close(optiga_comms_t * p_ctx);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_COMMS_H_*/
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c.h b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c.h
new file mode 100644
index 000000000..5646c671d
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c.h
@@ -0,0 +1,274 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c.h
+*
+* \brief   This file defines the API prototype for IFX I2C protocol v2.00 wrapper.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+
+#ifndef _IFXI2C_H_
+#define _IFXI2C_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/common/optiga_lib_types.h"
+#include "optiga/ifx_i2c/ifx_i2c_config.h"
+
+/** @brief IFX I2C Reset types */
+typedef enum ifx_i2c_reset_type
+{
+    /// Cold reset. Both reset pin and VDD pin are toggled low and then high
+    IFX_I2C_COLD_RESET = 0U,
+    /// Soft reset. 0x0000 is written to IFX-I2C Soft reset register
+    IFX_I2C_SOFT_RESET = 1U,
+    /// Warm reset. Only reset pin is toggled low and then high
+    IFX_I2C_WARM_RESET = 2U
+} ifx_i2c_reset_type_t;
+
+/**
+ * \brief Initializes the IFX I2C protocol stack for a given context.
+ *
+ * <br>
+ * <br>
+ * \image html ifx_i2c_open.png "ifx_i2c_open()" width=20cm
+ *
+ * \details
+ * Initializes the IFX I2C protocol stack for the given context.
+ * - Performs a reset sequence.<br>
+ * - Initializes the I2C slave device.<br>
+ * - Initializes the IFX I2C protocol stack and registers the event callbacks.
+ * - Negotiates the frame size and bit rate with the I2C slave.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - The values of registers MAX_SCL_FREQU and DATA_REG_LEN, read from slave are not validated.
+ * - At present, only single instance of #ifx_i2c_context_t is supported.
+ * - The following parameters in #ifx_i2c_context_t must be initialized with appropriate values <br>
+ *   - <b>slave address</b> : Address of I2C slave
+ *   - <b>frame_size</b> : Frame size in bytes. Refer #IFX_I2C_FRAME_SIZE for more details.<br>
+ *              - It is recommended not to use a value greater than the slave's frame size.
+ *              - The user specified frame size is written to I2C slave's frame size register.
+ *                The frame size register is read back from I2C slave.
+ *                This frame value is used by the IFX I2C protocol even if it is not equal to the user specified value.
+ *
+ *   - <b>frequency</b> : Frequency/speed of I2C master in KHz.
+ *              - This must be lowest of the maximum frequency supported by the devices (master/slave) connected on the bus.
+ *              - Initial negotiation starts with a frequency of 100KHz.
+ *              - If the user specified frequency is more than 400 KHz, the I2C slave is configured to operate in "Fm+" mode,
+ *                otherwise the I2C slave is configured for "SM & Fm" mode. <br>
+ *              - If the user specified frequency negotiation fails, the I2C master frequency remains at 100KHz<br>
+ *
+ *   - <b>upper_layer_event_handler</b> : Upper layer event handler. This is invoked when #ifx_i2c_open() is asynchronously completed.
+ *   - <b>upper_layer_ctx</b> : Context of upper layer.
+ *   - <b>p_slave_vdd_pin</b> : GPIO pin for VDD. If not set, cold reset is not done.
+ *   - <b>p_slave_reset_pin</b> : GPIO pin for Reset. If not set, warm reset is not done.
+ *   - <b>manage_contex_operation</b> : Used for manage context.The value of the parameter is not modified by the IFX I2C protocol stack.
+ *     - The values for <b>manage_contex_operation</b> must be one of the below.
+ *       - #IFX_I2C_SESSION_CONTEXT_RESTORE : restore the saved secure session.
+ *       - #IFX_I2C_SESSION_CONTEXT_NONE : for no manage context operation. 
+ *
+ * \param[in,out]  p_ctx                    Pointer to #ifx_i2c_context_t, must not be NULL
+ *
+ * \retval         #IFX_I2C_STACK_SUCCESS
+ * \retval         #IFX_I2C_STACK_ERROR
+ */optiga_lib_status_t ifx_i2c_open(ifx_i2c_context_t * p_ctx);
+
+/**
+ * \brief   Resets the I2C slave.
+ *
+ * <br>
+ * <br>
+ * \image html ifx_i2c_reset.png "ifx_i2c_reset()" width=20cm
+ *
+ * \details
+ * Resets the I2C slave and initializes the IFX I2C protocol stack for the given context.
+ * - Resets the I2C slave.
+ * - Initializes the IFX I2C protocol stack.
+ * - Re-Initializes and negotiates the frame size and bit rate with the I2C slave.
+ *   The values remain same as that in previous #ifx_i2c_open().
+ *
+ * \pre
+ * - IFX I2C protocol stack must be initialized.
+ *
+ * \note
+ * - For COLD and WARM reset type: If the GPIO(VDD and/or reset) pins are not configured,<br>
+ *   the API continues without any failure return status<br>
+ *
+ * \param[in,out] p_ctx                  Pointer to #ifx_i2c_context_t, must not be NULL
+ * \param[in,out] reset_type             type of reset
+ *
+ * \retval        #IFX_I2C_STACK_SUCCESS
+ * \retval        #IFX_I2C_STACK_ERROR
+ */
+optiga_lib_status_t ifx_i2c_reset(ifx_i2c_context_t * p_ctx,
+                                  ifx_i2c_reset_type_t reset_type);
+
+/**
+ * \brief   Sends a command and receives a response for the command.
+ *
+ * <br>
+ * \image html ifx_i2c_transceive.png "ifx_i2c_transceive()" width=20cm
+ *
+ * \details
+ * Sends a command and receives a response for the command.<br>
+ * - Transmit data(Command) to I2C slave.
+ * - Receive data(Response) from I2C slave.
+ *
+ * \pre
+ * - IFX I2C protocol stack must be initialized.
+ *
+ * \note
+ * - The actual number of bytes received is stored in p_rx_buffer_len. In case of error, p_rx_buffer_len is set to 0.<br>
+ * - The p_rx_buffer must be large enough to accommodate the response data from the slave.
+ *   The p_rx_buffer_len parameter must specify the length of the receive buffer correctly.
+ *   If the size of p_rx_data is zero or insufficient to copy the response bytes then #IFX_I2C_STACK_MEM_ERROR error is returned.
+ * - If establishing a secure channel fails, #IFX_I2C_HANDSHAKE_ERROR is returned.
+ * - If #IFX_I2C_SESSION_ERROR is returned, a new session must be established.
+ * - If presentation layer is enabled and the command data protection is selected,
+ *   the input data provided will be modified because the data will be encrypted in the same input buffer.
+ *   Hence a copy of the input data must be preserved by the caller of this API, if needed.
+ * - The following parameters in #ifx_i2c_context_t must be initialized with appropriate values <br>
+ *   - <b>upper_layer_event_handler</b> : Upper layer event handler, if it is different from that in #ifx_i2c_open().
+ *     This is invoked when #ifx_i2c_transceive is asynchronously completed.
+ *   - <b>upper_layer_ctx</b> : Context of upper layer, if it is different from that in #ifx_i2c_open.
+ *   - <b>protection_level</b> : Used for secure communication.The value of the parameter is not modified by the IFX I2C protocol stack.
+ *     - The values for <b>protection_level</b> must be one of the below
+ *       - #NO_PROTECTION : data from master and slave is unprotected
+ *       - #MASTER_PROTECTION : data from master is protected and data from slave is unprotected
+ *       - #SLAVE_PROTECTION : data from master is unprotected and data from is slave protected
+ *       - #FULL_PROTECTION : data from master and slave protected
+ *       - To re-establish secure channel, bitwise-OR protection_level with #RE_ESTABLISH
+ *   - If Presentation Layer is enabled,
+ *       - Additional buffer size is required to handle encryption and decryption functionality.
+ *   - The total buffer size with the additional presentation layer overhead is explained in the figure below. Please provide the lengths and data buffers as specified below.
+ *       - The transmit and receive data buffers need additional overhead of #IFX_I2C_PRL_OVERHEAD_SIZE bytes along with Tx/Rx data(payload) size.
+ *       - Provide the command data, starting from the #IFX_I2C_DATA_OFFSET location in the transmit buffer.
+ *       - In the receive buffer, the response (received data) from the OPTIGA will be stored from the #IFX_I2C_DATA_OFFSET location. Read the response from this offset.
+ *       - Provide the length of command data (tx_data_length) with the payload length excluding the additional overhead.
+ *       - Provide the length of response data (p_rx_buffer_len) in-order to copy the response to the buffer provided.
+ *   - If the master sequence number or expected slave sequence for next payload transmission crosses 0xFFFFFFF0, 
+ *     master renegotiate a new secure channel and then sends the payload to slave.
+ * \image html ifx_i2c_trancv_buffer.png "ifx_i2c_transceive()" width=0cm
+ *
+ * \param[in,out] p_ctx                     Pointer to #ifx_i2c_context_t, must not be NULL
+ * \param[in]     p_tx_data                 Pointer to the write transmit buffer
+ * \param[in]     tx_data_length            Length of the write data buffer
+ * \param[in,out] p_rx_buffer               Pointer to the receive data buffer
+ * \param[in,out] p_rx_buffer_len           Pointer to the length of the receive data buffer
+ *
+ * \retval        #IFX_I2C_STACK_SUCCESS
+ * \retval        #IFX_I2C_STACK_ERROR
+ * \retval        #IFX_I2C_STACK_MEM_ERROR
+ * \retval        #IFX_I2C_HANDSHAKE_ERROR
+ * \retval        #IFX_I2C_SESSION_ERROR
+ */
+optiga_lib_status_t ifx_i2c_transceive(ifx_i2c_context_t * p_ctx,
+                                     const uint8_t * p_tx_data,
+                                     uint16_t tx_data_length,
+                                     uint8_t * p_rx_buffer,
+                                     uint16_t* p_rx_buffer_len);
+
+/**
+ * \brief   Closes the IFX I2C protocol stack for a given context.
+ *
+ * <br>
+ * <br>
+ * \image html ifx_i2c_close.png "ifx_i2c_close()" width=20cm
+ *
+ * \details
+ * Closes the IFX I2C protocol stack for a given context.
+ * - De-Initializes the I2C slave device.
+ * - Power downs the I2C slave.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - <b>manage_contex_operation</b> : Used for manage context.The value of the parameter is not modified by the IFX I2C protocol stack.
+ *   - The values for <b>manage_contex_operation</b> must be one of the below
+ *     - #IFX_I2C_SESSION_CONTEXT_SAVE : save active secure session.
+ *     - #IFX_I2C_SESSION_CONTEXT_NONE : for no manage context operation.
+ *
+ * \param[in,out] p_ctx                Pointer to #ifx_i2c_context_t, must not be NULL
+ *
+ * \retval        #IFX_I2C_STACK_SUCCESS
+ */
+optiga_lib_status_t ifx_i2c_close(ifx_i2c_context_t * p_ctx);
+
+/**
+ * \brief   Sets the slave address of the target device.
+ *
+ * \details
+ * Writes new I2C slave Address to the target device.
+ *  - This API is implemented in synchronous mode.
+ *  - If the write fails due to the following reasons, this API repeats the write for PL_POLLING_MAX_CNT times
+ *    with a fixed interval of #PL_POLLING_INVERVAL_US microseconds and exits with respective return status.
+ *    - I2C bus is in busy state, returns #IFX_I2C_STACK_BUSY
+ *    - No-acknowledge(NACK) received from slave, returns #IFX_I2C_STACK_ERROR
+ *    - I2C errors, returns #IFX_I2C_STACK_ERROR
+ *  - Only bits [6:0] from  parameter "slave_address" are considered as slave address. Hence the bit 7 is ignored.
+ *  - Slave address validation is not done in the implementation. Provide a valid slave address as input.
+ *
+ * \pre
+ * - IFX I2C protocol stack must be initialized.
+ *
+ * \note
+ * - If persistent mode is selected, the IFX I2C context slave address will be over-written with the new slave address.
+ *   Even after IFX I2C open/reset, all future executions will use the new slave address.<br>
+ * - If volatile mode is selected, the pal_i2c_context slave address will be over-written with the new slave address.
+ *   This persists only till the next ifx_i2c open/reset is called.
+ *
+ * \param[in,out] p_ctx                    Pointer to #ifx_i2c_context_t
+ * \param[in]     slave_address            Holds new slave address[7 Bit] to be set.
+ * \param[in]     persistent               0 - To set the Slave address until next reset.<br>
+ *                                         Non-zero - To set the slave address to persistent memory.
+ *
+ * \retval        #IFX_I2C_STACK_SUCCESS
+ * \retval        #IFX_I2C_STACK_ERROR
+ */
+optiga_lib_status_t ifx_i2c_set_slave_address(ifx_i2c_context_t * p_ctx,
+                                              uint8_t slave_address,
+                                              uint8_t persistent);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _IFXI2C_H_ */
+/**
+ * @}
+ **/
+
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_config.h b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_config.h
new file mode 100644
index 000000000..74b2b22f0
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_config.h
@@ -0,0 +1,488 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_config.h
+*
+* \brief   This file defines the structures and macros for the Infineon I2C Protocol.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+#ifndef _IFX_I2C_CONFIG_H_
+#define _IFX_I2C_CONFIG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef IFX_I2C_CONFIG_EXTERNAL
+    #include "ifx_i2c_config_external.h"
+#else
+// Protocol Stack Includes
+#include "optiga/pal/pal_i2c.h"
+#include "optiga/pal/pal_gpio.h"
+#include "optiga/pal/pal_os_timer.h"
+#include "optiga/pal/pal_os_datastore.h"
+#include "optiga/optiga_lib_config.h"
+#include "optiga/common/optiga_lib_logger.h"
+
+/** @brief I2C slave address of the Infineon device */
+#define IFX_I2C_BASE_ADDR           (0x30)
+
+/** @brief Physical Layer: polling interval in microseconds */
+#define PL_POLLING_INVERVAL_US      (1000U)
+/** @brief Physical layer: maximal attempts */
+#define PL_POLLING_MAX_CNT          (200U)
+/** @brief Physical Layer: data register polling interval in microseconds */
+#define PL_DATA_POLLING_INVERVAL_US (5000U)
+/** @brief Physical Layer: guard time interval in microseconds */
+#define PL_GUARD_TIME_INTERVAL_US   (50U)
+
+/** @brief Data link layer: frame size (max supported is 277 in OPTIGA ).
+*          - Note: This can be configured externally to a lesser value due to platform restrictions.<br>
+*            Externally means through command line argument or project configuration or optiga_lib_config.h*/
+#ifdef IFX_I2C_FRAME_SIZE
+    #if (IFX_I2C_FRAME_SIZE > 277) || (IFX_I2C_FRAME_SIZE < 16)
+        #error "Unsupported value for IFX_I2C_FRAME_SIZE"
+    #endif
+#else
+    //Setting of frame size more than 277 and less than 16 bytes cause unexpected behaviour.
+    #define IFX_I2C_FRAME_SIZE          (20U)
+#endif
+
+/** @brief Transport Layer: header size */
+#define TL_HEADER_SIZE              (1U)
+/** @brief Data link layer: header size */
+#define DL_HEADER_SIZE              (5U)
+/** @brief Data link layer: maximum number of retries in case of transmission error */
+#define DL_TRANS_REPEAT             (3U)
+/** @brief Data link layer: Trans timeout in milliseconds*/
+#define PL_TRANS_TIMEOUT_MS         (10U)
+
+/** @brief Transport layer: Maximum exit timeout in seconds */
+#define TL_MAX_EXIT_TIMEOUT         (180U)
+
+/** @brief Reset low time for GPIO pin toggling */
+#define RESET_LOW_TIME_MSEC         (2000U)
+/** @brief Start up time */
+#define STARTUP_TIME_MSEC           (12000U)
+
+/** @brief Protocol Stack: Status codes for success */
+#define IFX_I2C_STACK_SUCCESS       (0x0000)
+/** @brief Protocol Stack: Status codes busy */
+#define IFX_I2C_STACK_BUSY          (0x0001)
+/** @brief Protocol Stack: Status codes for error */
+#define IFX_I2C_STACK_ERROR         (0x0102)
+/** @brief Protocol Stack: Memory insufficient */
+#define IFX_I2C_STACK_MEM_ERROR     (0x0104)
+/** @brief Protocol Stack: Fatal error. Used internal to IFX I2C Stack */
+#define IFX_I2C_FATAL_ERROR         (0x0106)
+/** @brief Protocol Stack: handshake error */
+#define IFX_I2C_HANDSHAKE_ERROR     (0x0107)
+/** @brief Protocol Stack: session error */
+#define IFX_I2C_SESSION_ERROR       (0x0108)
+
+/** @brief Offset of Datalink header in tx_frame_buffer */
+#define IFX_I2C_DL_HEADER_OFFSET    (0U)
+/** @brief Offset of Transport header in tx_frame_buffer */
+#define IFX_I2C_TL_HEADER_OFFSET    (IFX_I2C_DL_HEADER_OFFSET + 3)
+/** @brief Protocol Stack debug switch for physical layer (set to 0 or 1) */
+#define IFX_I2C_LOG_PL              (0U)
+/** @brief Protocol Stack debug switch for data link layer (set to 0 or 1) */
+#define IFX_I2C_LOG_DL              (0U)
+/** @brief Protocol Stack debug switch for transport layer (set to 0 or 1) */
+#define IFX_I2C_LOG_TL              (0U)
+/** @brief Protocol Stack debug switch for presentation layer (set to 0 or 1) */
+#define IFX_I2C_LOG_PRL             (0U)
+
+/** @brief Log ID number for physical layer */
+#define IFX_I2C_LOG_ID_PL           (0x00)
+/** @brief Log ID number for data link layer */
+#define IFX_I2C_LOG_ID_DL           (0x01)
+/** @brief Log ID number for transport layer */
+#define IFX_I2C_LOG_ID_TL           (0x02)
+/** @brief Log ID number for presentation layer */
+#define IFX_I2C_LOG_ID_PRL          (0x03)
+/** @brief Log ID number for platform abstraction layer */
+#define IFX_I2C_LOG_ID_PAL          (0x04)
+
+#if defined OPTIGA_COMMS_SHIELDED_CONNECTION
+    #define IFX_I2C_TL_ENABLE              (1U)
+    #define IFX_I2C_PRL_ENABLED            (1U)
+
+    #define IFX_I2C_PRESENCE_BIT           (0x08)
+    #define IFX_I2C_PRL_MAC_SIZE           (0x08)
+    #define IFX_I2C_PRL_HEADER_SIZE        (0x05)
+    /// Overhead buffer size for user buffer
+    #define IFX_I2C_PRL_OVERHEAD_SIZE      (IFX_I2C_PRL_HEADER_SIZE + IFX_I2C_PRL_MAC_SIZE)
+    /// Offset for data
+    #define IFX_I2C_DATA_OFFSET            (IFX_I2C_PRL_HEADER_SIZE)
+    #define IFX_I2C_PRESENCE_BIT_CHECK     (0x08)
+#else
+    #define IFX_I2C_PRESENCE_BIT           (0x00)
+    #define IFX_I2C_PRL_MAC_SIZE           (0x00)
+    #define IFX_I2C_PRL_HEADER_SIZE        (0x00)
+    /// Overhead buffer size for user buffer
+    #define IFX_I2C_PRL_OVERHEAD_SIZE      (IFX_I2C_PRL_HEADER_SIZE + IFX_I2C_PRL_MAC_SIZE)
+    /// Offset for data
+    #define IFX_I2C_DATA_OFFSET            (IFX_I2C_PRL_HEADER_SIZE)
+    #define IFX_I2C_PRESENCE_BIT_CHECK     (0x00)
+#endif
+
+/** @brief Pre shared secret protocol version*/
+#define PROTOCOL_VERSION_PRE_SHARED_SECRET   (0x01)
+/** @brief To restore saved secure session */
+#define IFX_I2C_SESSION_CONTEXT_RESTORE    (0x11)
+/** @brief To store  active secure session */
+#define IFX_I2C_SESSION_CONTEXT_SAVE       (0x22)
+/** @brief For no manage context operation */
+#define IFX_I2C_SESSION_CONTEXT_NONE       (0x33)
+
+/** @brief When data from master and slave is unprotected */
+#define NO_PROTECTION               (0x00)
+/** @brief When data from master is protected and data from slave is unprotected */
+#define MASTER_PROTECTION           (0x01)
+/** @brief When data from master is unprotected and data from is slave protected */
+#define SLAVE_PROTECTION            (0x02)
+/** @brief When data from master and slave protected */
+#define FULL_PROTECTION             (0x03)
+/** @brief To re-establish secure channel */
+#define RE_ESTABLISH                (0x80)
+
+/** @brief Session key buffer size */
+#define IFX_I2C_SESSION_KEY_BUFFER_SIZE    (0x28)
+
+
+typedef struct ifx_i2c_context ifx_i2c_context_t;
+
+/** @brief Event handler function prototype */
+typedef void ( * ifx_i2c_event_handler_t)(struct ifx_i2c_context * p_ctx,
+                                          optiga_lib_status_t event,
+                                          const uint8_t * data,
+                                          uint16_t data_len);
+
+/** @brief Physical layer structure */
+typedef struct ifx_i2c_pl
+{
+    // Physical Layer low level interface variables
+
+    /// Physical layer buffer
+    uint8_t buffer[IFX_I2C_FRAME_SIZE + 1];
+    /// Tx length
+    uint16_t buffer_tx_len;
+    /// Rx length
+    uint16_t buffer_rx_len;
+    /// Action on register, read/write
+    uint8_t  register_action;
+    /// i2c read/i2c write
+    uint8_t  i2c_cmd;
+    /// Retry counter
+    uint16_t retry_counter;
+
+    // Physical Layer high level interface variables
+
+    /// Action of frame. Tx/Rx
+    uint8_t   frame_action;
+    /// Frame state
+    uint8_t   frame_state ;
+    /// Pointer to data to be sent
+    uint8_t * p_tx_frame;
+    /// Length of data to be sent
+    uint16_t  tx_frame_len;
+    // Upper layer handler
+    ifx_i2c_event_handler_t upper_layer_event_handler;
+
+    // Physical Layer negotiation/soft reset variables
+
+    /// Negotiation state
+    uint8_t   negotiate_state;
+    /// Soft reset requested
+    uint8_t   request_soft_reset;
+} ifx_i2c_pl_t;
+
+/** @brief Datalink layer structure */
+typedef struct ifx_i2c_dl
+{
+    // Data Link layer internal state variables
+
+    /// Datalink layer state
+    uint8_t state;
+    /// Tx sequence number
+    uint8_t tx_seq_nr;
+    // Rx sequence number
+    uint8_t rx_seq_nr;
+    /// Indicate only Rx required
+    uint8_t action_rx_only;
+    /// Retransmit counter
+    uint8_t retransmit_counter;
+    /// Error occured
+    uint8_t error;
+    /// Resynced
+    uint8_t resynced;
+    /// Timeout value
+    uint32_t data_poll_timeout;
+    /// Transmit buffer size
+    uint16_t tx_buffer_size;
+    /// Receive buffer size
+    uint16_t rx_buffer_size;
+    /// Pointer to main transmit buffers
+    uint8_t * p_tx_frame_buffer;
+    /// Pointer to main receive buffers
+    uint8_t * p_rx_frame_buffer;
+    ///Start time of sending frame
+    uint32_t frame_start_time;
+    // Upper layer Event handler
+    ifx_i2c_event_handler_t upper_layer_event_handler;
+} ifx_i2c_dl_t;
+
+/** @brief Transport layer structure */
+typedef struct ifx_i2c_tl
+{
+    // Transport Layer state and buffer
+
+    /// Transport layer state
+    uint8_t  state;
+    /// Pointer to packet provided by user
+    uint8_t * p_actual_packet;
+    /// Total received data
+    uint16_t total_recv_length;
+    /// Actual length of user provided packet
+    uint16_t actual_packet_length;
+    /// Offset till which data is sent from p_actual_packet
+    uint16_t packet_offset;
+    /// Maximum length of packet at transport layer
+    uint16_t max_packet_length;
+    /// Pointer to user provided receive buffer
+    uint8_t * p_recv_packet_buffer;
+    /// Length of receive buffer
+    uint16_t * p_recv_packet_buffer_length;
+    /// Start time of the transport layer API
+    uint32_t api_start_time;
+    ///Chaining error count from slave
+    uint8_t chaining_error_count;
+    ///Chaining error count for master
+    uint8_t master_chaining_error_count;
+    ///State to check last chaining state
+    uint8_t previous_chaining;
+    /// transmission done
+    uint8_t transmission_completed;
+    /// Error event state
+    optiga_lib_status_t error_event;
+    ///Tl rx payload copy offset
+    uint8_t payload_offset;
+    ///Tl tx payload copy offset
+    uint8_t tx_payload_offset;
+    ///Initial state check
+    uint8_t initialization_state;
+
+    /// Upper layer event handler
+    ifx_i2c_event_handler_t upper_layer_event_handler;
+} ifx_i2c_tl_t;
+
+#if defined OPTIGA_COMMS_SHIELDED_CONNECTION
+
+/** @brief Presentation layer manage context structure */
+typedef struct ifx_i2c_prl_manage_context
+{
+    ///Buffer to store session key
+    uint8_t session_key[IFX_I2C_SESSION_KEY_BUFFER_SIZE];
+    /// Master retransmit counter
+    uint8_t decryption_failure_counter;
+    /// Slave retransmit counter
+    uint8_t data_retransmit_counter;
+    /// Negotiation state
+    uint8_t negotiation_state;
+    ///Stored context flag
+    uint8_t stored_context_flag;
+   /// Master sequence number
+    uint32_t master_sequence_number;
+    ///Save slave sequence number
+    uint32_t save_slave_sequence_number;
+}ifx_i2c_prl_manage_context_t;
+
+/** @brief Data store configuration structure */
+typedef struct ifx_i2c_datastore_config
+{
+    /// Protocol version
+    uint8_t  protocol_version;
+    /// ID to read and write the shared secret
+    uint16_t datastore_shared_secret_id;
+    /// ID to read and write the shielded connection context data
+    uint16_t datastore_manage_context_id;
+    /// Length of shared secret
+    uint16_t shared_secret_length;
+} ifx_i2c_datastore_config_t;
+
+
+/** @brief Presentation layer structure */
+typedef struct ifx_i2c_prl
+{
+    // Presentation layer state
+    uint8_t state;
+    // Handshake state
+    uint8_t hs_state;
+    /// Handshake negotiation state
+    uint8_t negotiation_state;
+    ///Manage context state
+    uint8_t mc_state;
+    /// Master sequence number
+    uint32_t master_sequence_number;
+    /// Slave sequence number
+    uint32_t slave_sequence_number;
+    ///Save slave sequence number
+    uint32_t save_slave_sequence_number;
+    /// Pointer to packet provided by user
+    uint8_t * p_actual_payload;
+    /// Total received data
+    uint16_t actual_payload_length;
+    /// Pointer to user provided receive buffer
+    uint8_t * p_recv_payload_buffer;
+    /// Length of receive buffer
+    uint16_t * p_recv_payload_buffer_length;
+    ///SCTR status byte
+    uint8_t sctr;
+    ///Saved SCTR status byte
+    uint8_t saved_sctr;
+    ///Alert type
+    uint8_t alert_type;
+    ///Presentation header offset
+    uint8_t prl_header_offset;
+    ///Buffer to store prf
+    uint8_t session_key[IFX_I2C_SESSION_KEY_BUFFER_SIZE];
+    /// Random data
+    uint8_t random[32];
+    /// Receive buffer
+    uint8_t prl_txrx_buffer[58];
+    /// Receive txrx buffer length
+    uint16_t prl_txrx_receive_length;
+    /// Associate data buffer
+    uint8_t associate_data[8];
+    /// Receive buffer length
+    uint16_t prl_receive_length;
+    /// Master retransmit counter
+    uint8_t decryption_failure_counter;
+    /// Slave retransmit counter
+    uint8_t data_retransmit_counter;
+    /// Return status
+    optiga_lib_status_t return_status;
+    ///Restore context flag
+    uint8_t restore_context_flag;
+    //Context to be stored
+    ifx_i2c_prl_manage_context_t prl_saved_ctx;
+    // Upper layer Event handler
+    ifx_i2c_event_handler_t upper_layer_event_handler;
+    // Trans repeat status
+    uint8_t trans_repeat_status;
+}ifx_i2c_prl_t;
+#endif
+
+/** @brief IFX I2C context structure */
+typedef struct ifx_i2c_context
+{
+    /// I2C Slave address
+    uint8_t slave_address;
+    /// Frequency of i2c master
+    uint16_t frequency;
+    /// Data link layer frame size
+    uint16_t frame_size;
+    /// Pointer to pal gpio context for vdd
+    pal_gpio_t * p_slave_vdd_pin;
+    /// Pointer to pal gpio context for reset
+    pal_gpio_t * p_slave_reset_pin;
+    /// Pointer to pal i2c context
+    pal_i2c_t * p_pal_i2c_ctx;
+#if defined OPTIGA_COMMS_SHIELDED_CONNECTION
+    /// Datastore configuration instance for prl
+    ifx_i2c_datastore_config_t * ifx_i2c_datastore_config;
+#endif
+    /// Upper layer event handler
+    upper_layer_callback_t upper_layer_event_handler;
+    /// Upper layer context
+    void * p_upper_layer_ctx;
+    /// Pointer to upper layer rx buffer
+    uint8_t * p_upper_layer_rx_buffer;
+    /// Pointer to length of upper layer rx buffer
+    uint16_t * p_upper_layer_rx_buffer_len;
+
+    /// Protocol variables
+    /// ifx i2c wrapper apis state
+    uint8_t state;
+    /// ifx i2c wrapper api status
+    uint8_t status;
+    /// reset states
+    uint8_t reset_state;
+    /// Close states
+    optiga_lib_status_t close_state;
+    /// type of reset
+    uint8_t reset_type;
+    /// init pal
+    uint8_t do_pal_init;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+    // protection level:
+    //0(master unprotected and slave unprotected),1(master protected and slave unprotected),
+    //2(master unprotected and slave protected),3(master protected and slave protected),
+    //255(re-negotiate)
+    uint8_t protection_level;
+    ///Supported presentation layer protocol version
+    uint8_t protocol_version;
+    ///Variable to indicate manage context operation
+    uint8_t manage_context_operation;
+#endif
+    /// Transport layer context
+    ifx_i2c_tl_t tl;
+    /// Datalink layer context
+    ifx_i2c_dl_t dl;
+    /// Physical layer context
+    ifx_i2c_pl_t pl;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+    /// Presentation layer context
+    ifx_i2c_prl_t prl;
+#endif
+    /// IFX I2C tx frame of max length
+    uint8_t tx_frame_buffer[IFX_I2C_FRAME_SIZE+1];
+    /// IFX I2C rx frame of max length
+    uint8_t rx_frame_buffer[IFX_I2C_FRAME_SIZE+1];
+    void * pal_os_event_ctx;
+
+} ifx_i2c_context_t;
+
+/** @brief IFX I2C Instance */
+extern ifx_i2c_context_t ifx_i2c_context_0;
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _IFX_I2C_CONFIG_H_ */
+
+/**
+ * @}
+ **/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_data_link_layer.h b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_data_link_layer.h
new file mode 100644
index 000000000..06650cf03
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_data_link_layer.h
@@ -0,0 +1,128 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_data_link_layer.h
+*
+* \brief   This file defines the API prototype for data link layer of the Infineon I2C Protocol Stack library.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+#ifndef _IFX_I2C_DATA_LINK_LAYER_H_
+#define _IFX_I2C_DATA_LINK_LAYER_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ifx_i2c_config.h"
+
+/** @brief Error event propagated to upper layer */
+#define IFX_I2C_DL_EVENT_ERROR              (0x01)
+/** @brief Transmit success event propagated to upper layer (bit field 1) */
+#define IFX_I2C_DL_EVENT_TX_SUCCESS         (0x02)
+/** @brief Receive success event propagated to upper layer (bit field 3)*/
+#define IFX_I2C_DL_EVENT_RX_SUCCESS         (0x04)
+
+/**
+ * \brief Function for initializing the module
+ *
+ * \details
+ * Function initializes and enables the module and registers an event handler to receive events from this module.
+ *
+ * \pre
+ * - This function must be called before using the module.
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out] p_ctx                    Pointer to ifx i2c context.
+ * \param[in]     handler                  Function pointer to the event handler of the upper layer.
+ *
+ * \retval        IFX_I2C_STACK_SUCCESS    If initialization was successful.
+ * \retval        IFX_I2C_STACK_ERROR      If the module is already initialized.
+ */
+optiga_lib_status_t ifx_i2c_dl_init(ifx_i2c_context_t * p_ctx,
+                                    ifx_i2c_event_handler_t handler);
+
+/**
+ * \brief Function for sending a frame
+ *
+ * \details
+ * Asynchronous function to send a frame
+ * - The function returns immediately.
+ * - One of the following events is propagated to the event handler registered with #ifx_i2c_dl_init.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out]   p_ctx                   Pointer to ifx i2c context.
+ * \param[in]       frame_len               Frame length.
+ *
+ * \retval          IFX_I2C_STACK_SUCCESS   If function was successful.
+ * \retval          IFX_I2C_STACK_ERROR     If the module is busy.
+ */
+optiga_lib_status_t ifx_i2c_dl_send_frame(ifx_i2c_context_t * p_ctx,
+                                          uint16_t frame_len);
+
+/**
+ * \brief Function for receiving a frame
+ *
+ * \details
+ * Asynchronous function to receive a frame
+ * - The function returns immediately.
+ * - One of the following events is propagated to the event handler registered with #ifx_i2c_dl_init.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out] p_ctx                   Pointer to ifx i2c context.
+ *
+ * \retval        IFX_I2C_STACK_SUCCESS   If function was successful.
+ * \retval        IFX_I2C_STACK_ERROR     If the module is busy.
+ */
+optiga_lib_status_t ifx_i2c_dl_receive_frame(ifx_i2c_context_t * p_ctx);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IFX_I2C_DATA_LINK_LAYER_H_ */
+
+
+/**
+ * @}
+ **/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_physical_layer.h b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_physical_layer.h
new file mode 100644
index 000000000..fd90767e7
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_physical_layer.h
@@ -0,0 +1,146 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_physical_layer.h
+*
+* \brief   This file defines the API prototype for physical layer of the Infineon I2C Protocol Stack library.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+#ifndef _IFX_I2C_PHYSICAL_LAYER_H_
+#define _IFX_I2C_PHYSICAL_LAYER_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ifx_i2c_config.h"
+
+/**
+ * \brief Function for initializing the module.
+ *
+ * \details
+ * Function initializes and enables the module
+ * - It registers an event handler to receive events from this module.
+ *
+ * \pre
+ * - This function must be called before using the module.
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out] p_ctx                   Pointer to IFX I2C context.
+ * \param[in]     handler                 Function pointer to the event handler of the upper layer.
+ *
+ * \retval        IFX_I2C_STACK_SUCCESS   If initialization was successful.
+ * \retval        IFX_I2C_STACK_ERROR     If the module is already initialized.
+ */
+optiga_lib_status_t ifx_i2c_pl_init(ifx_i2c_context_t * p_ctx,
+                                    ifx_i2c_event_handler_t handler);
+
+/**
+ * \brief Function for sending a frame.
+ *
+ * \details
+ * Asynchronous function to send a frame.
+ * - The function returns immediately.
+ * - One of the following events is propagated to the event handler registered with #ifx_i2c_pl_init
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out]  p_ctx                     Pointer to IFX I2C context.
+ * \param[in]      p_frame                   Buffer containing the frame.
+ * \param[in]      frame_len                 Frame length.
+ *
+ * \retval         IFX_I2C_STACK_SUCCESS     If function was successful.
+ * \retval         IFX_I2C_STACK_ERROR       If the module is busy.
+ */
+optiga_lib_status_t ifx_i2c_pl_send_frame(ifx_i2c_context_t * p_ctx,
+                                          uint8_t * p_frame,
+                                          uint16_t frame_len);
+
+/**
+ * \brief Function for receiving a frame.
+ *
+ * \details
+ * Asynchronous function to receive a frame
+ * - The function returns immediately.
+ * - One of the following events is propagated to the event handler registered with #ifx_i2c_pl_init
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_ctx                   Pointer to IFX I2C context.
+ *
+ * \retval    IFX_I2C_STACK_SUCCESS   If function was successful.
+ * \retval    IFX_I2C_STACK_ERROR     If the module is busy.
+ */
+optiga_lib_status_t ifx_i2c_pl_receive_frame(ifx_i2c_context_t * p_ctx);
+
+
+/**
+ * \brief Function for setting slave address.
+ *
+ * \details
+ * Synchronous function to set slave address.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in]    p_ctx                   Pointer to IFX I2C context.
+ * \param[in]    slave_address           Holds new slave address[7 Bit] to be set.
+ * \param[in]    storage_type            0: To set the Slave address until next reset.<br>
+ *                                       Non-zero: To set the slave address to persistent memory.
+ *
+ * \retval       IFX_I2C_STACK_SUCCESS   If function was successful.
+ * \retval       IFX_I2C_STACK_ERROR     If setting slave address fails.
+ */
+optiga_lib_status_t ifx_i2c_pl_write_slave_address(ifx_i2c_context_t * p_ctx,
+                                                   uint8_t slave_address,
+                                                   uint8_t storage_type);
+/**
+ * @}
+ **/
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _IFX_I2C_PHYSICAL_LAYER_H_ */
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_presentation_layer.h b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_presentation_layer.h
new file mode 100644
index 000000000..d464e90e0
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_presentation_layer.h
@@ -0,0 +1,132 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_presentation_layer.h
+*
+* \brief   Module for the presentation layer of the Infineon I2C Protocol Stack library.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+
+#ifndef _IFX_I2C_PRESENTATION_LAYER_H_
+#define _IFX_I2C_PRESENTATION_LAYER_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ifx_i2c_config.h"
+
+/**
+ * \brief Function for initializing the module.
+ *
+ * \details
+ * Function initializes and enables the module
+ * - It registers an event handler to receive events from this module.
+ *
+ * \pre
+ * - This function must be called before using the module.
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out] p_ctx                    Pointer to ifx i2c context.
+ * \param[in]     handler                  Function pointer to the event handler of the upper layer.
+ *
+ * \retval        IFX_I2C_STACK_SUCCESS    If initialization was successful.
+ * \retval        IFX_I2C_STACK_ERROR      If the module is already initialized.
+ */
+
+optiga_lib_status_t ifx_i2c_prl_init(ifx_i2c_context_t * p_ctx,
+                                     ifx_i2c_event_handler_t handler);
+
+/**
+ * \brief Function to transmit and receive a packet.
+ *
+ * \details
+ * Asynchronous function to send and receive protected/unprotected packet
+ * - The function returns immediately.
+ * - One of the following events is propagated to the event handler registered with #ifx_i2c_prl_init
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out] p_ctx                      Pointer to ifx i2c context.
+ * \param[in]     p_tx_data                  Pointer to the buffer containing the data to be transmitted.
+ * \param[in]     tx_data_len                Transmit data length.
+ * \param[in]     p_rx_data                  Pointer to the buffer to store the data received.
+ * \param[in]     p_rx_data_len              Pointer to a variable to store the received data length
+ *
+ * \retval        IFX_I2C_STACK_SUCCESS      If function was successful.
+ * \retval        IFX_I2C_HANDSHAKE_ERROR    If establishing a secure channel fails.
+ * \retval        IFX_I2C_SESSION_ERROR      If an established secure channel is closed.
+ * \retval        IFX_I2C_STACK_ERROR        If the module is busy.
+ */
+optiga_lib_status_t ifx_i2c_prl_transceive(ifx_i2c_context_t * p_ctx,
+                                           uint8_t * p_tx_data,
+                                           uint16_t tx_data_len,
+                                           uint8_t * p_rx_data,
+                                           uint16_t * p_rx_data_len);
+
+
+
+/**
+ * \brief Function for closing the module.
+ *
+ * \details
+ * Function closes the module and registers an event handler to receive events from this module.
+ *
+ * \pre
+ * - This function must be called before using the module.
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out] p_ctx                  Pointer to ifx i2c context.
+ * \param[in]     handler                Function pointer to the event handler of the upper layer.
+ *
+ * \retval        IFX_I2C_STACK_SUCCESS  If initialization was successful.
+ * \retval        IFX_I2C_STACK_ERROR    If the module is already initialized.
+ */
+optiga_lib_status_t ifx_i2c_prl_close(ifx_i2c_context_t * p_ctx,
+                                      ifx_i2c_event_handler_t handler);
+ 
+#ifdef __cplusplus
+}
+#endif
+#endif /* _IFX_I2C_TRANSPORT_LAYER_H_ */
+
+/**
+ * @}
+ */
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_transport_layer.h b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_transport_layer.h
new file mode 100644
index 000000000..8134adb6c
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/ifx_i2c/ifx_i2c_transport_layer.h
@@ -0,0 +1,105 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file ifx_i2c_transport_layer.h
+*
+* \brief   This file defines the API prototype for transport layer of the Infineon I2C Protocol Stack library.
+*
+* \ingroup  grIFXI2C
+*
+* @{
+*/
+
+
+#ifndef _IFX_I2C_TRANSPORT_LAYER_H_
+#define _IFX_I2C_TRANSPORT_LAYER_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ifx_i2c_config.h"
+#include "optiga/pal/pal_os_timer.h"
+
+/**
+ * \brief Function for initializing the module.
+ *
+ * \details
+ * Function initializes and enables the module and registers an event handler to receive events from this module.
+ *
+ * \pre
+ * - This function must be called before using the module.
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out] p_ctx                   Pointer to ifx i2c context.
+ * \param[in]     handler                 Function pointer to the event handler of the upper layer.
+ *
+ * \retval        IFX_I2C_STACK_SUCCESS   If initialization was successful.
+ * \retval        IFX_I2C_STACK_ERROR     If the module is already initialized.
+ */
+optiga_lib_status_t ifx_i2c_tl_init(ifx_i2c_context_t * p_ctx, ifx_i2c_event_handler_t handler);
+
+/**
+ * \brief Function to transmit and receive a packet.
+ *
+ * \details
+ * - The function returns immediately.
+ * - One of the following events is propagated to the event handler registered with #ifx_i2c_tl_init
+ *
+ * \pre
+ * - This function must be called before using the module.
+ *
+ * \note
+ * - None
+ *
+ * \param[in,out] p_ctx                   Pointer to ifx i2c context.
+ * \param[in]     p_packet                Buffer containing the packet header.
+ * \param[in]     packet_len              Packet header length.
+ * \param[in]     p_recv_packet           Buffer containing the packet payload.
+ * \param[in]     p_recv_packet_len       Packet payload length.
+ *
+ * \retval        IFX_I2C_STACK_SUCCESS   If function was successful.
+ * \retval        IFX_I2C_STACK_ERROR     If the module is busy.
+ */
+optiga_lib_status_t ifx_i2c_tl_transceive(ifx_i2c_context_t * p_ctx,
+                                        uint8_t * p_packet,
+                                        uint16_t packet_len,
+                                        uint8_t * p_recv_packet,
+                                        uint16_t * p_recv_packet_len);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _IFX_I2C_TRANSPORT_LAYER_H_ */
+
+/**
+ * @}
+ */
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/optiga_crypt.h b/3rdparty/experimental/optiga/optiga/include/optiga/optiga_crypt.h
new file mode 100644
index 000000000..580527729
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/optiga_crypt.h
@@ -0,0 +1,2338 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_crypt.h
+*
+* \brief   This file implements the prototype declarations of OPTIGA Crypt module.
+*
+* \ingroup  grOptigaCrypt
+*
+* @{
+*/
+
+#ifndef _OPTIGA_CRYPT_H_
+#define _OPTIGA_CRYPT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/cmd/optiga_cmd.h"
+
+/** \brief union for OPTIGA crypt parameters */
+typedef union optiga_crypt_params
+{
+    /// get random params
+    optiga_get_random_params_t optiga_get_random_params;
+    /// get key pair params
+    optiga_gen_keypair_params_t optiga_gen_keypair_params;
+    /// calc sign params
+    optiga_calc_sign_params_t optiga_calc_sign_params;
+    /// verify sign params
+    optiga_verify_sign_params_t optiga_verify_sign_params;
+    /// asymmetric encryption params
+    optiga_encrypt_asym_params_t optiga_encrypt_asym_params;
+    /// calc hash params
+    optiga_calc_hash_params_t optiga_calc_hash_params;
+    /// derive key params
+    optiga_derive_key_params_t optiga_derive_key_params;
+    /// derive key params
+    optiga_encrypt_sym_params_t optiga_symmetric_enc_dec_params;
+    /// generate symmetric key params
+    optiga_gen_symkey_params_t optiga_gen_sym_key_params;    
+}optiga_crypt_params_t;
+
+/** \brief OPTIGA crypt instance structure */
+struct optiga_crypt
+{
+    /// Details/references (pointers) to the Application Inputs
+    optiga_crypt_params_t params;
+    /// Command module instance
+    optiga_cmd_t * my_cmd;
+    /// Caller context
+    void * caller_context;
+    /// Callback handler
+    callback_handler_t handler;
+    ///To provide the busy/free status of the crypt instance
+    uint16_t instance_state;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+    /// To provide the encryption and decryption need for command and response
+    uint8_t protection_level;
+    /// To provide the presentation layer protocol version to be used
+    uint8_t protocol_version;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+
+};
+
+/** \brief OPTIGA crypt instance structure type*/
+typedef struct optiga_crypt optiga_crypt_t;
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+/**
+ * \brief Sets/updates the OPTIGA Comms Shielded connection configuration in
+ *        the respective (optiga_util) instance.
+ *
+ *\details
+ * Sets/updates the OPTIGA Comms Shielded connection configuration in the respective (optiga_util) instance.
+ * - The #OPTIGA_COMMS_PROTECTION_LEVEL configuration settings using this API, will be used in the next immediate usage of the instance.
+ * - Once the API is invoked, this level gets reset to the default protection level #OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL
+ *
+ *\pre
+ * - None
+ *
+ *\note
+ * - None
+ *
+ * \param[in,out]  me                     Valid instance of #optiga_util_t
+ * \param[in]      parameter_type         Parameter Type
+ *                                        Possible Types are
+ *                                        #OPTIGA_COMMS_PROTECTION_LEVEL
+ *                                        #OPTIGA_COMMS_PROTOCOL_VERSION
+ *
+ * \param[in]      value                  Value part for the respective configuration
+ *
+ * <b>Example</b><br>
+ *
+ */
+void optiga_crypt_set_comms_params(optiga_crypt_t * me,
+                                   uint8_t parameter_type,
+                                   uint8_t value);
+#endif
+
+/**
+ * \brief Create an instance of #optiga_crypt_t.
+ *
+ * \details
+ * Create an instance of #optiga_crypt_t.
+ * - Stores the callers context and callback handler.
+ * - Allocate memory for #optiga_crypt_t.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - This API is implemented in synchronous mode.
+ * - For <b>protected I2C communication</b>,
+ *      - Default protection level for this API is #OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL.
+ *      - Default protocol version for this API is #OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET.
+ *
+ * \param[in]   optiga_instance_id  Indicates the OPTIGA instance to be associated with #optiga_crypt_t. Should be defined as below:
+ *                                  Use #OPTIGA_INSTANCE_ID_0.
+ * \param[in]   handler             Pointer to callback function, must not be NULL.
+ * \param[in]   caller_context      Pointer to upper layer context. Contains user context data.
+ *
+ * \retval      #optiga_crypt_t     On success function will return pointer of #optiga_crypt_t.
+ * \retval      NULL                Input arguments are NULL.<br>
+ *                                  Low layer function fails.<br>
+ *                                  OPTIGA_CMD_MAX_REGISTRATIONS number of instances are already created.
+ */
+LIBRARY_EXPORTS optiga_crypt_t * optiga_crypt_create(uint8_t optiga_instance_id,
+                                                     callback_handler_t handler,
+                                                     void * caller_context);
+
+/**
+ * \brief Destroys an instance of #optiga_crypt_t.
+ *
+ * \details
+ * Destroys the #optiga_crypt_t instance.
+ * - De-allocate the memory of the #optiga_crypt_t instance.
+ *
+ * \pre
+ * - An instance of optiga_crypt using #optiga_crypt_create must be available.<br>
+ *
+ * \note
+ *  - User must take care to nullify the instance pointer.
+ *  - Invoke this API only after all the asynchronous process is completed otherwise the behavior of software stack is not defined.
+ *
+ * \param[in] me                                      Valid instance of #optiga_crypt_t.
+ *
+ * \retval    #OPTIGA_LIB_SUCCESS                    Successful invocation.
+ * \retval    #OPTIGA_CRYPT_ERROR_INVALID_INPUT       Wrong Input arguments provided.
+ * \retval    #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete.
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_destroy(optiga_crypt_t * me);
+
+#ifdef OPTIGA_CRYPT_RANDOM_ENABLED
+/**
+ * \brief Generates a random number.
+ *
+ * \details
+ * Generates the requested random stream of data for the user provided length.
+ * - Invokes #optiga_cmd_get_random API, based on the input arguments to retrieve random data .
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers is returned as it is.<br>
+ * - The maximum value of the <b>random_data_length</b> parameter is size of buffer <b>random_data</b>.
+ *   In case the value is greater than buffer size, memory corruption can occur.<br>
+ *
+ * \param[in]      me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]      rng_type                                 Type of random data generator.
+ *                                                          - The input must be from #optiga_rng_type.
+ *                                                          - Argument check for rng_type is not done since OPTIGA will provide an error for invalid rng_type.
+ * \param[in,out]  random_data                              Pointer to the buffer into which random data is stored, must not be NULL.
+ * \param[in]      random_data_length                       Length of random data to be generated.
+ *                                                          - Range should be 8 - 256 bytes.
+ *                                                          - Length validation is not done, since OPTIGA will provide an error for invalid random_data_length.
+ *
+ * \retval         #OPTIGA_CRYPT_SUCCESS                    Successful invocation.
+ * \retval         #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided.
+ * \retval         #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete.
+ * \retval         #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_random.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_random(optiga_crypt_t * me,
+                                                        optiga_rng_type_t rng_type,
+                                                        uint8_t * random_data,
+                                                        uint16_t random_data_length);
+#endif //OPTIGA_CRYPT_RANDOM_ENABLED
+
+#ifdef OPTIGA_CRYPT_HASH_ENABLED
+/**
+ *
+ * \brief Updates a hashing for input data and returns digest.
+ *
+ * \details
+ * Updates hashing for the given data and returns digest.<br>
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ * - Error codes from lower layer will be returned as it is.<br>
+ *
+ *<br>
+ * \param[in]      me                                        Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]      hash_algorithm                            Hash algorithm of #optiga_hash_type_t.
+ * \param[in]      source_of_data_to_hash                    Data from host / Data in OPTIGA. Must be one of the below
+ *                                                           - #OPTIGA_CRYPT_HOST_DATA or Non-Zero value ,if source of data is from Host.
+ *                                                           - #OPTIGA_CRYPT_OID_DATA, if the source of data is from OPTIGA.
+ * \param[in]      data_to_hash                              Data for hashing either in #hash_data_from_host_t or in #hash_data_in_optiga_t
+ * \param[inout]   hash_output                               Pointer to the valid buffer to store hash output.
+ *
+ * \retval         #OPTIGA_CRYPT_SUCCESS                     Successful invocation.
+ * \retval         #OPTIGA_CRYPT_ERROR_INVALID_INPUT         Wrong Input arguments provided.
+ * \retval         #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE       The previous operation with the same instance is not complete.
+ * \retval         #OPTIGA_DEVICE_ERROR                      Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                           (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hash.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hash(optiga_crypt_t * me,
+                                                      optiga_hash_type_t hash_algorithm,
+                                                      uint8_t source_of_data_to_hash,
+                                                      const void * data_to_hash, 
+                                                      uint8_t * hash_output);
+                                      
+ /**
+ *
+ * \brief Initializes a hash context.
+ *
+ * \details
+ * Sets up a hash context and exports it.
+ * - Invokes #optiga_cmd_calc_hash API, based on the input arguments.<br>
+ * - Initializes a new hash context.<br>
+ * - Exports the hash context to caller.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.<br>
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ * - Error codes from lower layer will be returned as it is.<br>
+ * - User must save the output hash context for further usage because OPTIGA does not store it internally.<br>
+ *
+ *<br>
+ * \param[in]      me                                        Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[inout]   hash_ctx                                  Pointer to #optiga_hash_context_t to store the hash context from OPTIGA.
+ *                                                           - The minimum size of the <b>context_buffer</b> must be 209 bytes in #optiga_hash_context_t for hash algo #OPTIGA_HASH_TYPE_SHA_256.
+ *                                                           - The input <b>hash_algo</b> in  <b>hash_ctx</b> must be from #optiga_hash_type.
+ *
+ * \retval         #OPTIGA_CRYPT_SUCCESS                     Successful invocation.
+ * \retval         #OPTIGA_CRYPT_ERROR_INVALID_INPUT         Wrong Input arguments provided.
+ * \retval         #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE       The previous operation with the same instance is not complete.
+ * \retval         #OPTIGA_DEVICE_ERROR                      Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                           (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hash.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hash_start(optiga_crypt_t * me,
+                                                            optiga_hash_context_t * hash_ctx);
+
+
+ /**
+ * \brief Updates a hash context with the input data.
+ *
+ * \details
+ * Updates hashing for the given data and hash context then export the updated hash context.<br>
+ * - Invokes #optiga_cmd_calc_hash API, based on the input arguments.<br>
+ * - Update the input hash context.<br>
+ * - Exports the hash context to caller.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.<br>
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ * - #optiga_hash_context_t from #optiga_crypt_hash_start or #optiga_crypt_hash_update must be available.
+ *
+ * \note<br>
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layer will be returned as it is.<br>
+ * - User must save the output hash context for further usage as OPTIGA does not store it internally.
+ *
+ * \param[in]   me                                      Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]   hash_ctx                                Pointer to #optiga_hash_context_t containing hash context from OPTIGA, must not be NULL
+ *                                                      - The minimum size of the <b>context_buffer</b> must be 209 bytes in #optiga_hash_context_t for hash algo #OPTIGA_HASH_TYPE_SHA_256.
+ * \param[in]   source_of_data_to_hash                  Data from host / Data in optiga. Must be one of the below
+ *                                                      - #OPTIGA_CRYPT_HOST_DATA or Non-Zero value ,if source of data is from Host.
+ *                                                      - #OPTIGA_CRYPT_OID_DATA, if the source of data is from OPITGA.
+ * \param[in]   data_to_hash                            Data for hashing either in #hash_data_from_host or in #hash_data_in_optiga
+ *
+ * \retval      #OPTIGA_CRYPT_SUCCESS                   Successful invocation.
+ * \retval      #OPTIGA_CRYPT_ERROR_INVALID_INPUT       Wrong Input arguments provided.
+ * \retval      #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete.
+ * \retval      #OPTIGA_DEVICE_ERROR                    Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                      (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hash.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hash_update(optiga_crypt_t * me,
+                                                             optiga_hash_context_t * hash_ctx,
+                                                             uint8_t source_of_data_to_hash,
+                                                             const void * data_to_hash);
+
+ /**
+ *
+ * \brief Finalizes and exports the hash output.
+ *
+ * \details
+ * Finalizes the hash context and returns hash as output.
+ * - Invokes #optiga_cmd_calc_hash API, based on the input arguments.<br>
+ * - Finalize the hash from the input hash context
+ * - Exports the finalized hash.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ * - #optiga_hash_context_t from #optiga_crypt_hash_start or #optiga_crypt_hash_update must be available.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layer will be returned as it is.
+ * - hash context is not updated by this API. This can be used later to fulfill intermediate hash use-cases.
+ * - User must save the output hash context for further usage as OPTIGA does not store it internally.
+ *
+ * \param[in]      me                                      Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]      hash_ctx                                Pointer to #optiga_hash_context_t containing hash context from OPTIGA, must not be NULL.
+ *                                                         - The minimum size of the <b>context_buffer</b> must be 209 bytes in #optiga_hash_context_t for hash algo #OPTIGA_HASH_TYPE_SHA_256.
+ * \param[inout]   hash_output                             Output Hash.
+ *
+ * \retval         #OPTIGA_CRYPT_SUCCESS                   Successful invocation.
+ * \retval         #OPTIGA_CRYPT_ERROR_INVALID_INPUT       Wrong Input arguments provided.
+ * \retval         #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete.
+ * \retval         #OPTIGA_DEVICE_ERROR                    Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                         (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hash.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hash_finalize(optiga_crypt_t * me,
+                                                               optiga_hash_context_t * hash_ctx,
+                                                               uint8_t * hash_output);
+
+#endif //OPTIGA_CRYPT_HASH_ENABLED
+
+#ifdef OPTIGA_CRYPT_TLS_PRF_ENABLED
+/**
+ * \brief Derives a key.<br>
+ *
+ * \details
+ * Derives a key using the secret stored in OPTIGA.
+ * - Invokes #optiga_cmd_derive_key API, based on the input arguments.<br>
+ * - Stores the derived key into OPTIGA session context or export it to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - There must be a secret available in the "session context / data object OID" provided as input parameter.<br>
+ * - If the secret type is #OPTIGA_KEY_ID_SESSION_BASED then session must be already available in the instance.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION if secret is in session OID..
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         type                                     Type of scheme to be used for TLS PRF as #optiga_tls_prf_type_t. 
+ * \param[in]         secret                                   Object ID where the secret is stored in OPTIGA.
+ *                                                             - #OPTIGA_KEY_ID_SESSION_BASED from #optiga_key_id_t, indicates the secret is available
+ *                                                               in the session context acquired by the instance.
+ *                                                             - or any OPTIGA data object ID(16 bit OID) which holds the secret.
+ * \param[in]         label                                    Pointer to the label, can be NULL if not applicable.
+ * \param[in]         label_length                             Length of the label.
+ * \param[in]         seed                                     Valid pointer to the seed, must not be NULL.
+ * \param[in]         seed_length                              Length of the seed.
+ * \param[in]         derived_key_length                       Length of derived key.
+ *                                                             - The minimum length of the output derived key can be 1 byte, if derived key is exported.  
+ * \param[in]         export_to_host                           TRUE (1) or Non-Zero value - Exports the derived key to Host. <br>
+ *                                                             FALSE (0) - Stores the derived key into the session object ID acquired by the instance.
+ * \param[in,out]     derived_key                              Pointer to the valid buffer with a minimum size of derived_key_length,
+ *                                                             in case of exporting the key to host(<b>export_to_host is non-zero value</b>). Otherwise set to NULL.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                    Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT        - Wrong Input arguments provided
+ *                                                             - Attempt to use a session OID which is not acquired.
+                                                               Session is not available in instance and the secret type is #OPTIGA_KEY_ID_SESSION_BASED
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                             (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_tls_prf_sha256.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_tls_prf(optiga_crypt_t * me,
+                                                         optiga_tls_prf_type_t type,
+                                                         uint16_t secret,
+                                                         const uint8_t * label,
+                                                         uint16_t label_length,
+                                                         const uint8_t * seed,
+                                                         uint16_t seed_length,
+                                                         uint16_t derived_key_length,
+                                                         bool_t export_to_host,
+                                                         uint8_t * derived_key);
+                                                
+/**
+ * \brief Derives a key using TLS PRF SHA256.<br>
+ *
+ * \details
+ * Derives a key TLS PRF SHA256 using the secret stored in OPTIGA.
+ * - Invokes #optiga_cmd_derive_key API, based on the input arguments.<br>
+ * - Stores the derived key into OPTIGA session context or export it to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - There must be a secret available in the "session context / data object OID" provided as input parameter.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION if secret is in session OID.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         secret                                   Object ID where the secret is stored in OPTIGA.
+ *                                                             - #OPTIGA_KEY_ID_SESSION_BASED from #optiga_key_id_t, indicates the secret is available
+ *                                                               in the session context acquired by the instance.
+ *                                                             - or any OPTIGA data object ID(16 bit OID) which holds the secret.
+ * \param[in]         label                                    Pointer to the label, can be NULL if not applicable.
+ * \param[in]         label_length                             Length of the label.
+ * \param[in]         seed                                     Valid pointer to the seed, must not be NULL.
+ * \param[in]         seed_length                              Length of the seed.
+ * \param[in]         derived_key_length                       Length of derived key.
+ *                                                             - The minimum length of the output derived key can be 1 byte, if derived key is exported. 
+ * \param[in]         export_to_host                           TRUE (1) or Non-Zero value - Exports the derived key to Host. <br>
+ *                                                             FALSE (0) - Stores the derived key into the session object ID acquired by the instance.
+ * \param[in,out]     derived_key                              Pointer to the valid buffer with a minimum size of derived_key_length,
+ *                                                             in case of exporting the key to host(<b>export_to_host is non-zero value</b>). Otherwise set to NULL.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                    Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided
+ *                                                             - Attempt to use a session OID which is not acquired.
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                             (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_tls_prf_sha256.c
+ *
+ */
+_STATIC_INLINE LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_tls_prf_sha256(optiga_crypt_t * me,
+                                                                               uint16_t secret,
+                                                                               const uint8_t * label,
+                                                                               uint16_t label_length,
+                                                                               const uint8_t * seed,
+                                                                               uint16_t seed_length,
+                                                                               uint16_t derived_key_length,
+                                                                               bool_t export_to_host,
+                                                                               uint8_t * derived_key)
+{
+    return (optiga_crypt_tls_prf(me,
+                                 OPTIGA_TLS12_PRF_SHA_256,
+                                 secret,
+                                 label,
+                                 label_length,
+                                 seed,
+                                 seed_length,
+                                 derived_key_length,
+                                 export_to_host,
+                                 derived_key));    
+}
+
+/**
+ * \brief Derives a key using TLS PRF SHA384.<br>
+ *
+ * \details
+ * Derives a key using the secret stored in OPTIGA.
+ * - Invokes #optiga_cmd_derive_key API, based on the input arguments.<br>
+ * - Stores the derived key into OPTIGA session context or export it to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - There must be a secret available in the "session context / data object OID" provided as input parameter.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION if secret is in session OID.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         secret                                   Object ID where the secret is stored in OPTIGA.
+ *                                                             - #OPTIGA_KEY_ID_SESSION_BASED from #optiga_key_id_t, indicates the secret is available
+ *                                                               in the session context acquired by the instance.
+ *                                                             - or any OPTIGA data object ID(16 bit OID) which holds the secret.
+ * \param[in]         label                                    Pointer to the label, can be NULL if not applicable.
+ * \param[in]         label_length                             Length of the label.
+ * \param[in]         seed                                     Valid pointer to the seed, must not be NULL.
+ * \param[in]         seed_length                              Length of the seed.
+ * \param[in]         derived_key_length                       Length of derived key.
+ *                                                             - The minimum length of the output derived key can be 1 byte, if derived key is exported.
+ * \param[in]         export_to_host                           TRUE (1) or Non-Zero value - Exports the derived key to Host. <br>
+ *                                                             FALSE (0) - Stores the derived key into the session object ID acquired by the instance.
+ * \param[in,out]     derived_key                              Pointer to the valid buffer with a minimum size of derived_key_length,
+ *                                                             in case of exporting the key to host(<b>export_to_host is non-zero value</b>). Otherwise set to NULL.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                    Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided
+ *                                                             - Attempt to use a session OID which is not acquired.
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                             (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * None
+ *
+ */
+_STATIC_INLINE LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_tls_prf_sha384(optiga_crypt_t * me,
+                                                                               uint16_t secret,
+                                                                               const uint8_t * label,
+                                                                               uint16_t label_length,
+                                                                               const uint8_t * seed,
+                                                                               uint16_t seed_length,
+                                                                               uint16_t derived_key_length,
+                                                                               bool_t export_to_host,
+                                                                               uint8_t * derived_key)
+{
+    return (optiga_crypt_tls_prf(me,
+                                 OPTIGA_TLS12_PRF_SHA_384,
+                                 secret,
+                                 label,
+                                 label_length,
+                                 seed,
+                                 seed_length,
+                                 derived_key_length,
+                                 export_to_host,
+                                 derived_key));
+}
+
+/**
+ * \brief Derives a key using TLS PRF SHA512.<br>
+ *
+ * \details
+ * Derives a key using the secret stored in OPTIGA.
+ * - Invokes #optiga_cmd_derive_key API, based on the input arguments.<br>
+ * - Stores the derived key into OPTIGA session context or export it to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - There must be a secret available in the "session context / data object OID" provided as input parameter.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION if secret is in session OID.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         secret                                   Object ID where the secret is stored in OPTIGA.
+ *                                                             - #OPTIGA_KEY_ID_SESSION_BASED from #optiga_key_id_t, indicates the secret is available
+ *                                                               in the session context acquired by the instance.
+ *                                                             - or any OPTIGA data object ID(16 bit OID) which holds the secret.
+ * \param[in]         label                                    Pointer to the label, can be NULL if not applicable.
+ * \param[in]         label_length                             Length of the label.
+ * \param[in]         seed                                     Valid pointer to the seed, must not be NULL.
+ * \param[in]         seed_length                              Length of the seed.
+ * \param[in]         derived_key_length                       Length of derived key.
+ *                                                             - The minimum length of the output derived key can be 1 byte, if derived key is exported.
+ * \param[in]         export_to_host                           TRUE (1) or Non-Zero value - Exports the derived key to Host. <br>
+ *                                                             FALSE (0) - Stores the derived key into the session object ID acquired by the instance.
+ * \param[in,out]     derived_key                              Pointer to the valid buffer with a minimum size of derived_key_length,
+ *                                                             in case of exporting the key to host(<b>export_to_host is non-zero value</b>). Otherwise set to NULL.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                    Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided
+ *                                                             - Attempt to use a session OID which is not acquired.
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                             (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * None
+ *
+ */
+_STATIC_INLINE LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_tls_prf_sha512(optiga_crypt_t * me,
+                                                                               uint16_t secret,
+                                                                               const uint8_t * label,
+                                                                               uint16_t label_length,
+                                                                               const uint8_t * seed,
+                                                                               uint16_t seed_length,
+                                                                               uint16_t derived_key_length,
+                                                                               bool_t export_to_host,
+                                                                               uint8_t * derived_key)
+{
+    return (optiga_crypt_tls_prf(me,
+                                 OPTIGA_TLS12_PRF_SHA_512,
+                                 secret,
+                                 label,
+                                 label_length,
+                                 seed,
+                                 seed_length,
+                                 derived_key_length,
+                                 export_to_host,
+                                 derived_key));
+}
+
+#endif //OPTIGA_CRYPT_TLS_PRF_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED
+
+/**
+ * \brief Generates a key pair based on RSA key type.
+ *
+ * \details
+ * Generates a RSA key-pair based on the type of the key.
+ * - Invokes #optiga_cmd_gen_keypair API, based on the input arguments.<br>
+ * - Generate an RSA key pair using OPTIGA.
+ * - If export is requested, exports the private key else stores it in the input private key OID.
+ * - Always exports the public keys.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened before using #optiga_util_open_application before using this API.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers is returned as it is.
+ * - RSA key pair generation on OPTIGA can go beyond 50 seconds therefore use a larger value for optiga comms TL_MAX_EXIT_TIMEOUT.
+ *   The default value is hence set to 180 seconds.
+ *
+ * \param[in]       me                                      Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]       key_type                                RSA key type defined in #optiga_rsa_key_type_t.
+ * \param[in]       key_usage                               Key usage defined in #optiga_key_usage_t.
+ *                                                          - Values from #optiga_key_usage can be logically ORed and passed.<br>
+ *                                                          - It is ignored if export_private_key is TRUE (1) or non-zero.
+ * \param[in]       export_private_key                      TRUE (1) or a non-zero value - Exports private key to the host.<br>
+ *                                                          FALSE (0) - Exports only public key to the host and writes private key to OPTIGA. The input key_usage is ignored.
+ * \param[in,out]       private_key                             Buffer to store private key or private key OID of OPTIGA, must not be NULL.
+ *                                                          - If export_private_key is TRUE, assign a pointer to a buffer to store the generated private key.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the key type and additional DER encoding formats.
+ *                                                          - If export_private_key is FALSE, assign a pointer to variable of type #optiga_key_id_t.
+ * \param[in,out]   public_key                              Buffer to store public key, must not be NULL.
+ * \param[in,out]       public_key_length                       Initially set as length of public_key, later updated as actual length of public_key.
+ *
+ * \retval          #OPTIGA_CRYPT_SUCCESS                   Successful invocation
+ * \retval          #OPTIGA_CRYPT_ERROR_INVALID_INPUT       Wrong Input arguments provided
+ * \retval          #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete
+ * \retval          #OPTIGA_DEVICE_ERROR                    Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_rsa_generate_keypair.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_rsa_generate_keypair(optiga_crypt_t * me,
+                                                                      optiga_rsa_key_type_t key_type,
+                                                                      uint8_t key_usage,
+                                                                      bool_t export_private_key,
+                                                                      void * private_key,
+                                                                      uint8_t * public_key,
+                                                                      uint16_t * public_key_length);
+#endif //OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED
+
+
+#ifdef OPTIGA_CRYPT_RSA_SIGN_ENABLED
+ /**
+ * \brief Generates a RSA signature for the given digest based on the input signature scheme.
+ *
+ * \details
+ * Generates a signature for the given digest using private key stored in OPTIGA.
+ * - Invokes #optiga_cmd_calc_sign API, based on the input arguments.<br>
+ * - Generates signature for the input digest.
+ * - Exports the generated signature.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers is returned as it is.
+ *
+ * \param[in]      me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]      signature_scheme                         RSA signature scheme defined in #optiga_rsa_signature_scheme_t
+ * \param[in]      digest                                   Digest on which signature is generated.
+ * \param[in]      digest_length                            Length of the input digest.
+ * \param[in]      private_key                              Private key OID to generate signature. This is static private key only.
+ * \param[in,out]  signature                                Pointer to store generated signature, must not be NULL.
+ * \param[in]      signature_length                         Length of signature. Initial value set as length of buffer, later updated as the actual length of generated signature.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the signature.
+ * \param[in]      salt_length                              Reserved for future use. Parameter for RSA PSS signature scheme.
+ *
+ * \retval         #OPTIGA_CRYPT_SUCCESS                    Successful invocation.
+ * \retval         #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided.
+ * \retval         #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete.
+ * \retval         #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_rsa_sign.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_rsa_sign(optiga_crypt_t * me,
+                                                          optiga_rsa_signature_scheme_t signature_scheme,
+                                                          const uint8_t * digest,
+                                                          uint8_t digest_length,
+                                                          optiga_key_id_t private_key,
+                                                          uint8_t * signature,
+                                                          uint16_t * signature_length,
+                                                          uint16_t salt_length);
+#endif //OPTIGA_CRYPT_RSA_SIGN_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+/**
+ * \brief Verifies the RSA signature over the given digest.
+ *
+ * \details
+ * Verifies the signature over a given digest provided with the input data.
+ * - Invokes #optiga_cmd_verify_sign API, based on the input arguments.<br>
+ * - Verifies the signature over the given provided with the input data using public key.
+ * - It invokes the callback handler of the instance, when it is asynchronously completed.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]   me                                        Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]   signature_scheme                          RSA signature scheme defined in #optiga_rsa_signature_scheme_t
+ * \param[in]   digest                                    Pointer to a given digest buffer, must not be NULL.
+ * \param[in]   digest_length                             Length of digest.
+ * \param[in]   signature                                 Pointer to a given signature buffer, must not be NULL.
+ * \param[in]   signature_length                          Length of signature.
+ * \param[in]   public_key_source_type                    Public key from host / public key of certificate OID from OPTIGA. Value must be one of the below
+ *                                                        - #OPTIGA_CRYPT_OID_DATA, if the public key is to used from the certificate data object from OPTIGA.
+ *                                                        - #OPTIGA_CRYPT_HOST_DATA or Non-Zero value , if the public key is provided by host.
+ * \param[in]   public_key                                Public key from host / public key of certificate OID. Value must be one of the below
+ *                                                        - For certificate OID, pointer to an OID value must be passed.
+ *                                                        - For Public key from host, pointer to #public_key_from_host_t instance.
+ * \param[in]   salt_length                               Reserved for future use. Parameter for RSA PSS signature scheme.
+ *
+ * \retval      #OPTIGA_CRYPT_SUCCESS                     Successful invocation
+ * \retval      #OPTIGA_CRYPT_ERROR_INVALID_INPUT         Wrong Input arguments provided
+ * \retval      #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE       The previous operation with the same instance is not complete
+ * \retval      #OPTIGA_DEVICE_ERROR                      Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                        (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_rsa_verify.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_rsa_verify(optiga_crypt_t * me,
+                                                            optiga_rsa_signature_scheme_t signature_scheme,
+                                                            const uint8_t * digest,
+                                                            uint8_t digest_length,
+                                                            const uint8_t * signature,
+                                                            uint16_t signature_length,
+                                                            uint8_t public_key_source_type,
+                                                            const void * public_key,
+                                                            uint16_t salt_length);
+#endif //OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED
+/**
+ * \brief Generates a pre-master secret.
+ *
+ * \details
+ * Generates a pre-master secret for RSA key exchange and stores in the acquired session
+ * - Invokes #optiga_cmd_get_random API, based on the input arguments.
+ * - Generates the pre-master secret
+ * - Pre-master secret is stored in session OID.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers is returned as it is.<br>
+ * - Pre Master Secret :
+ *      - Minimum length of generated pre master secret is 8 bytes.
+ *      - The maximum length supported by OPTIGA is 48 bytes.
+ *      - It is a concatenation of optional data and random secret.
+ *
+ * \param[in]      me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]      optional_data                            Optional data that gets prepended to the generated random secret.
+ *                                                          - Can be set to NULL, if not required
+ * \param[in]      optional_data_length                     Length of the optional data provided. It is ignored if optional_data is NULL
+ *                                                          - Value can be up to 58 bytes
+ *                                                          - Difference in shared secret length and optional data length is less than 8 bytes
+ * \param[in]      pre_master_secret_length                 Length of the shared secret to be generated.
+ *                                                          - Length validation for more than maximum length is not done, since OPTIGA will provide an error for an invalid shared secret length.
+ *
+ * \retval         #OPTIGA_CRYPT_SUCCESS                    Successful invocation.
+ * \retval         #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided.<br>
+ *                                                          - optional_data_length is more than 40 bytes
+ *                                                          - Difference in shared secret length and optional data length is less than 8 bytes
+ * \retval         #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete.
+ * \retval         #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_encrypt_session.c
+ *
+ */
+
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_rsa_generate_pre_master_secret(optiga_crypt_t * me,
+                                                                                const uint8_t * optional_data,
+                                                                                uint16_t optional_data_length,
+                                                                                uint16_t pre_master_secret_length);
+#endif //OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+
+/**
+ * \brief Encrypts message using RSA public key.<br>
+ *
+ * \details
+ * Encrypts message using RSA public key which is either provided by the host or stored in OPTIGA.
+ * - Invokes #optiga_cmd_encrypt_asym API, based on the input arguments.<br>
+ * - Encrypts the input message using a RSA public key.
+ * - The RSA public key either provided by the host or refers to a OID in OPTIGA containing the public key certificate.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - <b>encrypted_message_length</b> Initially, it contains the size of buffer provided by user to store the encrypted data. On successful encryption, this value is updated with actual length of the encrypted data.<br>
+ *      In case of any error, the value is set to 0.
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encryption_scheme                     RSA encryption scheme.
+ * \param[in]         message                               Pointer to message to be encrypted.
+ * \param[in]         message_length                        Length of the message to be encrypted.
+ * \param[in]         label                                 Pointer to a label (Reserved for future use).
+ * \param[in]         label_length                          Length of the label (Reserved for future use).
+ * \param[in]         public_key_source_type                Public key from host / public key of certificate OID from OPTIGA. Value must be one of the below
+ *                                                              - #OPTIGA_CRYPT_OID_DATA, if the public key is to be used from the certificate data object from OPTIGA.
+ *                                                              - #OPTIGA_CRYPT_HOST_DATA or Non-Zero value , if the public key is provided by host.
+ * \param[in]         public_key                            Public key from host / public key of certificate OID. Value must be one of the below
+ *                                                              - For certificate OID, pointer to OID value must be passed.
+ *                                                              - For Public key from host, pointer to #public_key_from_host_t instance.
+ * \param[in,out]     encrypted_message                     Pointer to buffer to store encrypted message.
+ * \param[in,out]     encrypted_message_length              Pointer to length of the encrypted message.
+                                                                - Out length is depends on the key size.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_encrypt_message.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_rsa_encrypt_message(optiga_crypt_t * me,
+                                                                     optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                                     const uint8_t * message,
+                                                                     uint16_t message_length,
+                                                                     const uint8_t * label,
+                                                                     uint16_t label_length,
+                                                                     uint8_t public_key_source_type,
+                                                                     const void * public_key,
+                                                                     uint8_t * encrypted_message,
+                                                                     uint16_t * encrypted_message_length);
+
+/**
+ * \brief Encrypts session data using RSA public key.<br>
+ *
+ * \details
+ * Encrypts session data using RSA public key which is either provided by the host or stored in OPTIGA.
+ * - Invokes #optiga_cmd_encrypt_asym API, based on the input arguments.<br>
+ * - Encrypts the data in the session OID using a RSA public key.
+ * - The RSA public key either provided by the host or refers to a OID in OPTIGA containing the public key certificate.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - A session OID must be acquired using #optiga_crypt_rsa_generate_pre_master_secret otherwise #OPTIGA_CMD_ERROR_INVALID_INPUT is returned.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *     - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - <b>encrypted_message_length</b> contains the size of buffer provided by user to store the encrypted data. On successful encryption, this value is updated with actual length of the encrypted data.<br>
+ *      In case of any error, the value is set to 0.
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encryption_scheme                     RSA encryption scheme.
+ * \param[in]         label                                 Pointer to a label (used only is case of RSAES_OAEP_SHA256 otherwise ignored).
+ * \param[in]         label_length                          Length of the label (used only is case of RSAES_OAEP_SHA256 otherwise ignored).
+ * \param[in]         public_key_source_type                Public key from host / public key of certificate OID from OPTIGA. Value must be one of the below
+ *                                                              - #OPTIGA_CRYPT_OID_DATA, if the public key is to be used from the certificate data object from OPTIGA.
+ *                                                              - #OPTIGA_CRYPT_HOST_DATA  or Non-Zero value, if the public key is provided by host.
+ * \param[in]         public_key                            Public key from host / public key of certificate OID. Value must be one of the below
+ *                                                              - For certificate OID, pointer to OID value must be passed.
+ *                                                              - For Public key from host, pointer to #public_key_from_host_t instance.
+ * \param[in,out]     encrypted_message                     Pointer to buffer to store encrypted message.
+ * \param[in,out]     encrypted_message_length              Pointer to length of the encrypted message.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_encrypt_session.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_rsa_encrypt_session(optiga_crypt_t * me,
+                                                                     optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                                     const uint8_t * label,
+                                                                     uint16_t label_length,
+                                                                     uint8_t public_key_source_type,
+                                                                     const void * public_key,
+                                                                     uint8_t * encrypted_message,
+                                                                     uint16_t * encrypted_message_length);
+
+#endif //OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+
+#ifdef OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+/**
+ * \brief Decrypts input data using OPTIGA private key and export it to the host.<br>
+ *
+ * \details
+ * Decrypts input data using RSA private key from OPTIGA and exports the decrypted data to the host.
+ * - Invokes #optiga_cmd_decrypt_asym API, based on the input arguments.<br>
+ * - Decrypts the input data using a RSA private key.
+ * - The RSA private key from OPTIGA is referred by #optiga_key_id_t.
+ * - Decrypted data is exported back to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is OPTIGA_COMMS_RESPONSE_PROTECTION.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - <b>*message_length</b> Initially , it contains the size of buffer provided by user to store the decrypted data. On successful decryption, this value is updated with actual length of the decrypted data.<br>
+ *      In case of any error, the value is set to 0.
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encryption_scheme                     RSA encryption scheme.
+ * \param[in]         encrypted_message                     Pointer to the data to be decrypted.
+ * \param[in]         encrypted_message_length              Length of the data to be decrypted.
+ * \param[in]         label                                 Pointer to a label (Reserved for future use).
+ * \param[in]         label_length                          Length of the label (Reserved for future use).
+ * \param[in]         private_key                           RSA private key in OPTIGA
+ * \param[in,out]     message                               Pointer to buffer to store decrypted message.
+ * \param[in,out]     message_length                        Pointer to length of the decrypted message.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_rsa_decrypt_and_export(optiga_crypt_t * me,
+                                                                         optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                                         const uint8_t * encrypted_message,
+                                                                         uint16_t encrypted_message_length,
+                                                                         const uint8_t * label,
+                                                                         uint16_t label_length,
+                                                                         optiga_key_id_t private_key,
+                                                                         uint8_t * message,
+                                                                         uint16_t * message_length);
+
+ /**
+ * \brief Decrypts input data using OPTIGA private key and stores it in a OPTIGA session.<br>
+ *
+ * \details
+ * Decrypts input data using RSA private key from OPTIGA and stores it in a OPTIGA session.
+ * - Invokes #optiga_cmd_decrypt_asym API, based on the input arguments.<br>
+ * - Decrypts the input data using a RSA private key.
+ * - The RSA private key from OPTIGA is referred by #optiga_key_id_t.
+ * - Stores the decrypted data in the acquired OPTIGA session.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_RESPONSE_PROTECTION.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encryption_scheme                     RSA encryption scheme.
+ * \param[in]         encrypted_message                     Pointer to the data to be decrypted.
+ * \param[in]         encrypted_message_length              Length of the data to be decrypted.
+ * \param[in]         label                                 Pointer to a label (Reserved for future use).
+ * \param[in]         label_length                          Length of the label (Reserved for future use).
+ * \param[in]         private_key                           RSA private key in OPTIGA.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_rsa_decrypt_and_store(optiga_crypt_t * me,
+                                                                        optiga_rsa_encryption_scheme_t encryption_scheme,
+                                                                        const uint8_t * encrypted_message,
+                                                                        uint16_t encrypted_message_length,
+                                                                        const uint8_t * label,
+                                                                        uint16_t label_length,
+                                                                        optiga_key_id_t private_key);
+
+#endif //OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+
+#ifdef OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED
+/**
+ * \brief Encrypt the data using symmetric encryption mode and export encrypted message to host.<br>
+ *
+ * \details
+ * Encrypt the input message using symmetric key from OPTIGA and export the encrypted message to host.<br>
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.
+ * - Encrypts the input message based on the encryption mode.
+ * - Use the symmetric key referred by symmetric key OID.
+ * - Exports the encrypted message back to host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_COMMAND_PROTECTION.
+ * - No internal padding is performed by OPTIGA, hence plain data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encryption_mode                       Symmetric encryption mode
+ * \param[in]         symmetric_key_oid                     OPTIGA symmetric key OID
+ *                                                          - Symmetric key must be available at the specified OID.<br>
+ * \param[in]         plain_data                            Pointer to the data to be encrypted.
+ * \param[in]         plain_data_length                     Length of the data to be encrypted.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ * \param[in]         iv                                    Pointer to an IV(initialization vector) or nonce.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ *                                                          - Only supported for CBC and CCM mode.
+ * \param[in]         iv_length                             Length of the IV
+ *                                                          - Only supported for CBC and CCM mode.
+ * \param[in]         associated_data                       Pointer to associated data
+ *                                                          - Only supported for CCM mode.
+ * \param[in]         associated_data_length                Length of associated data
+ *                                                          - Only supported for CCM mode.
+ * \param[in,out]     encrypted_data                        Pointer to buffer to store encrypted data
+ * \param[in,out]     encrypted_data_length                 Pointer to length of the <b>encrypted_data</b>. Initial value set as length of buffer, later updated as the actual length of encrypted data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the encrypted data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_encrypt(optiga_crypt_t * me,
+                                                                    optiga_symmetric_encryption_mode_t
+                                                                    encryption_mode,
+                                                                    optiga_key_id_t symmetric_key_oid,
+                                                                    const uint8_t * plain_data,
+                                                                    uint32_t plain_data_length,
+                                                                    const uint8_t * iv,
+                                                                    uint16_t iv_length,
+                                                                    const uint8_t * associated_data,
+                                                                    uint16_t associated_data_length,
+                                                                    uint8_t * encrypted_data,
+                                                                    uint32_t * encrypted_data_length);
+
+/**
+ * \brief Encrypt the data using symmetric encryption scheme using ECB mode of operation.<br>
+ *
+ * \details
+ * Encrypt the data using symmetric encryption scheme using ECB mode of operation.<br>
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.<br>
+ * - Encrypts the input message in ecb mode.
+ * - Use the symmetric key referred by symmetric key OID.
+ * - Exports the encrypted message back to host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_COMMAND_PROTECTION.
+ * - No internal padding is performed by OPTIGA hence plain data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         symmetric_key_oid                     OID of the symmetric key object to be used to encrypt the data.
+ *                                                          - Symmetric key must be available at the specified OID.<br>
+ * \param[in]         plain_data                            Pointer to the data to be encrypted.
+ * \param[in]         plain_data_length                     Length of the data to be encrypted.
+ * \param[in,out]     encrypted_data                        Pointer to buffer to store encrypted data.
+ * \param[in,out]     encrypted_data_length                 Pointer to length of the <b>encrypted_data</b>. Initial value set as length of buffer, later updated as the actual length of encrypted data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the encrypted data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt_ecb.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_encrypt_ecb(optiga_crypt_t * me,
+                                                                        optiga_key_id_t symmetric_key_oid,
+                                                                        const uint8_t * plain_data,
+                                                                        uint32_t plain_data_length,
+                                                                        uint8_t * encrypted_data,
+                                                                        uint32_t * encrypted_data_length);
+
+/**
+ * \brief Initiates a symmetric encryption sequence for input data using symmetric key from OPTIGA.<br>
+ *
+ * \details
+ * Initiates a symmetric encryption sequence for input data using symmetric key from OPTIGA.<br>
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.<br>
+ * - It marks the beginning of a strict sequence. None of the service layer API will be processed until the strict sequence is terminated.
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments to generate and export the encrypted message to host.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_COMMAND_PROTECTION.
+ * - No internal padding is performed by OPTIGA, hence plain data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated
+ *   - In case of an error from lower layer.<br>
+ *   - Same instance is used for other service layer APIs (except #optiga_crypt_symmetric_encrypt_continue and #optiga_crypt_symmetric_encrypt_final).<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encryption_mode                       Symmetric encryption mode
+ * \param[in]         symmetric_key_oid                     OPTIGA symmetric key OID
+ *                                                          - Symmetric key must be available at the specified OID.<br>
+ * \param[in]         plain_data                            Pointer to the data to be encrypted.
+ * \param[in]         plain_data_length                     Length of the data to be encrypted.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ * \param[in]         iv                                    Pointer to an IV(initialization vector) or nonce.
+ *                                                          - Only supported for CBC and CCM mode.
+ * \param[in]         iv_length                             Length of the IV
+ *                                                          - Only supported for CBC and CCM mode.
+ * \param[in]         associated_data                       Pointer to associated data
+ *                                                          - Only supported for CCM mode.
+ * \param[in]         associated_data_length                Length of associated data
+ *                                                          - Only supported for CCM mode.
+ * \param[in]         total_plain_data_length               Length of total data to be encrypted until #optiga_crypt_symmetric_encrypt_final.
+ *                                                          - Only supported for CCM mode.
+ * \param[in,out]     encrypted_data                        Pointer to buffer to store encrypted data. Can be NULL for MAC based operations.
+ * \param[in,out]     encrypted_data_length                 Pointer to length of the <b>encrypted_data</b>. Initial value set as length of buffer, later updated as the actual length of encrypted data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the encrypted data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_encrypt_start(optiga_crypt_t * me,
+                                                                          optiga_symmetric_encryption_mode_t
+                                                                          encryption_mode,
+                                                                          optiga_key_id_t symmetric_key_oid,
+                                                                          const uint8_t * plain_data,
+                                                                          uint32_t plain_data_length,
+                                                                          const uint8_t * iv,
+                                                                          uint16_t iv_length,
+                                                                          const uint8_t * associated_data,
+                                                                          uint16_t associated_data_length,
+                                                                          uint16_t total_plain_data_length,
+                                                                          uint8_t * encrypted_data,
+                                                                          uint32_t * encrypted_data_length);
+
+/**
+ * \brief Encrypts input data using symmetric key from OPTIGA and exports block aligned encrypted data.<br>
+ *
+ * \details
+ * Encrypts input data using symmetric key from OPTIGA and exports block aligned encrypted data.<br>
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.<br>
+ * - Encrypts the input message and exports the encrypted message.<br>
+ * - Encryption mode and Symmetric key OID specified in #optiga_crypt_symmetric_encrypt_start is used to encrypt the data by OPTIGA.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.<br>
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The encryption sequence must have been initiated, by invoking #optiga_crypt_symmetric_encrypt_start, before calling this API.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, value set in #optiga_crypt_symmetric_encrypt_start is used in this API.<br>
+ * - No internal padding is performed by OPTIGA, hence plain data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated in case of an error from lower layer<br>
+ * - Invoking this API without successful completion of #optiga_crypt_symmetric_encrypt_start throws #OPTIGA_CMD_ERROR_INVALID_INPUT error.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         plain_data                            Pointer to the data to be encrypted.
+ * \param[in]         plain_data_length                     Length of the data to be encrypted.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ * \param[in,out]     encrypted_data                        Pointer to buffer to store encrypted data. Can be NULL for MAC based operations.
+ * \param[in,out]     encrypted_data_length                 Pointer to length of the <b>encrypted_data</b>. Initial value set as length of buffer, later updated as the actual length of encrypted data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the encrypted data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_encrypt_continue(optiga_crypt_t * me,
+                                                                             const uint8_t * plain_data,
+                                                                             uint32_t plain_data_length,
+                                                                             uint8_t * encrypted_data,
+                                                                             uint32_t * encrypted_data_length);
+
+/**
+ * \brief Encrypts input data using symmetric key from OPTIGA, exports block aligned encrypted data and completes the encryption sequence.<br>
+ *
+ * \details
+ * Encrypts input data using symmetric key from OPTIGA, exports block aligned encrypted data and completes the encryption sequence.<br>
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.
+ * - Encrypts the input message and exports the encrypted message.<br>
+ * - Encryption mode and Symmetric key OID specified in #optiga_crypt_symmetric_encrypt_start is used to encrypt the data by OPTIGA.<br>
+ * - It terminates the strict sequence.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The encryption sequence must have been initiated, by invoking #optiga_crypt_symmetric_encrypt_start, before calling this API.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, value set in #optiga_crypt_symmetric_encrypt_start is used in this API.<br>
+ * - No internal padding is performed by OPTIGA, hence plain data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated in case of an error from lower layer<br>
+ * - Invoking this API without successful completion of #optiga_crypt_symmetric_encrypt_start throws #OPTIGA_CMD_ERROR_INVALID_INPUT error.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         plain_data                            Pointer to the data to be encrypted.
+ * \param[in]         plain_data_length                     Length of the data to be encrypted.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ * \param[in,out]     encrypted_data                        Pointer to buffer to store encrypted data.
+ * \param[in,out]     encrypted_data_length                 Pointer to length of the <b>encrypted_data</b>. Initial value set as length of buffer, later updated as the actual length of encrypted data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the encrypted data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_encrypt_final(optiga_crypt_t * me,
+                                                                          const uint8_t * plain_data,
+                                                                          uint32_t plain_data_length,
+                                                                          uint8_t * encrypted_data,
+                                                                          uint32_t * encrypted_data_length);
+#endif //OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED
+
+#ifdef OPTIGA_CRYPT_SYM_DECRYPT_ENABLED
+/**
+ * \brief Decrypt the encrypted data using symmetric encryption mode and export plain message to host.<br>
+ *
+ * \details
+ * Decrypt the encrypted data using symmetric key from OPTIGA and export the plain data to host.<br>
+ * - Invokes #optiga_cmd_decrypt_sym API, based on the input arguments.<br>
+ * - Decrypts the input message based on the encryption mode.
+ * - Use the symmetric key referred by symmetric key OID.
+ * - Exports the decrypted message back to host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_RESPONSE_PROTECTION.
+ * - The API does not support MAC based encryption modes.<br>
+ * - No internal padding is performed by OPTIGA, hence encrypted data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encryption_mode                       Symmetric encryption mode
+ * \param[in]         symmetric_key_oid                     OPTIGA symmetric key OID
+ *                                                          - Symmetric key must be available at the specified OID.<br> 
+ * \param[in]         encrypted_data                        Pointer to the data to be decrypted.
+ * \param[in]         encrypted_data_length                 Length of the data to be decrypted.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ * \param[in]         iv                                    Pointer to an IV(initialization vector) or nonce.
+ *                                                          - Only supported for CBC and CCM mode.
+ * \param[in]         iv_length                             Length of the IV
+ *                                                          - Only supported for CBC and CCM mode.
+ * \param[in]         associated_data                       Pointer to associated data
+ *                                                          - Only supported for CCM mode.
+ * \param[in]         associated_data_length                Length of associated data
+ *                                                          - Only supported for CBC mode.
+ * \param[in,out]     plain_data                            Pointer to buffer to store plain data.
+ * \param[in,out]     plain_data_length                     Pointer to length of the <b>plain_data</b>. Initial value set as length of buffer, later updated as the actual length of plain data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the plain data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_decrypt(optiga_crypt_t * me,
+                                                                    optiga_symmetric_encryption_mode_t
+                                                                    encryption_mode,
+                                                                    optiga_key_id_t symmetric_key_oid,
+                                                                    const uint8_t * encrypted_data,
+                                                                    uint32_t encrypted_data_length,
+                                                                    const uint8_t * iv,
+                                                                    uint16_t iv_length,
+                                                                    const uint8_t * associated_data,
+                                                                    uint16_t associated_data_length,
+                                                                    uint8_t * plain_data,
+                                                                    uint32_t * plain_data_length);
+/**
+ * \brief Decrypt the data using symmetric encryption scheme using ECB mode of operation.<br>
+ *
+ * \details
+ * Decrypt the data using symmetric encryption scheme using ECB mode of operation.<br>
+ * - Invokes #optiga_cmd_decrypt_sym API, based on the input arguments.<br>
+ * - Decrypts the input message based on ecb mode.
+ * - Use the symmetric key referred by symmetric key OID.
+ * - Exports the decrypted message back to host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_RESPONSE_PROTECTION.
+ * - No internal padding is performed by OPTIGA, hence encrypted data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         symmetric_key_oid                     OID of the symmetric key object to be used to decrypt the data.
+ *                                                          - Symmetric key must be available at the specified OID.<br> 
+ * \param[in]         encrypted_data                        Pointer to the encrypted data to be decrypted.
+ * \param[in]         encrypted_data_length                 Length of the encrypted data to be decrypted.
+ * \param[in,out]     plain_data                            Pointer to buffer to store decrypted data.
+ * \param[in,out]     plain_data_length                     Pointer to length of the <b>plain_data</b>. Initial value set as length of buffer, later updated as the actual length of plain data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the plain data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt_ecb.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_decrypt_ecb(optiga_crypt_t * me,
+                                                                        optiga_key_id_t symmetric_key_oid,
+                                                                        const uint8_t * encrypted_data,
+                                                                        uint32_t encrypted_data_length,
+                                                                        uint8_t * plain_data,
+                                                                        uint32_t * plain_data_length);
+
+/**
+ * \brief Initiate symmetric decryption sequence for input data using symmetric key from OPTIGA.<br>
+ *
+ * \details
+ * Initiate symmetric decryption sequence for input data using symmetric key from OPTIGA.<br>
+ * - Invokes #optiga_cmd_decrypt_sym API, based on the input arguments.<br>
+ * - It marks the beginning of a strict sequence. None of the service layer API will be processed until the strict sequence is terminated.
+ * - Invokes #optiga_cmd_decrypt_sym API, based on the input arguments to generate and export the plain message to host.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_RESPONSE_PROTECTION.
+ * - The API does not support MAC based encryption modes.<br>
+ * - No internal padding is performed by OPTIGA, hence encrypted data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated
+ *   - In case of an error from lower layer.<br>
+ *   - Same instance is used for other service layer APIs (except #optiga_crypt_symmetric_decrypt_continue and #optiga_crypt_symmetric_decrypt_final).<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encryption_mode                       Symmetric encryption mode
+ * \param[in]         symmetric_key_oid                     OPTIGA symmetric key OID
+ *                                                          - Symmetric key must be available at the specified OID.<br> 
+ * \param[in]         encrypted_data                        Pointer to the data to be decrypted.
+ * \param[in]         encrypted_data_length                 Length of the data to be decrypted.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ * \param[in]         iv                                    Pointer to an IV(initialization vector) or nonce.
+ *                                                          - Only supported for CBC and CCM mode.
+ * \param[in]         iv_length                             Length of the IV
+ *                                                          - Only supported for CBC and CCM mode.
+ * \param[in]         associated_data                       Pointer to associated data
+ *                                                          - Only supported for CCM mode.
+ * \param[in]         associated_data_length                Length of associated data
+ *                                                          - Only supported for CCM mode.
+ * \param[in]         total_encrypted_data_length           Length of total data to be decrypted until #optiga_crypt_symmetric_decrypt_final.
+ *                                                          - Only supported for CCM mode.
+ * \param[in,out]     plain_data                            Pointer to buffer to store plain data.
+ * \param[in,out]     plain_data_length                     Pointer to length of the <b>plain_data</b>. Initial value set as length of buffer, later updated as the actual length of plain data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the plain data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_decrypt_start(optiga_crypt_t * me,
+                                                                          optiga_symmetric_encryption_mode_t
+                                                                          encryption_mode,
+                                                                          optiga_key_id_t symmetric_key_oid,
+                                                                          const uint8_t * encrypted_data,
+                                                                          uint32_t encrypted_data_length,
+                                                                          const uint8_t * iv,
+                                                                          uint16_t iv_length,
+                                                                          const uint8_t * associated_data,
+                                                                          uint16_t associated_data_length,
+                                                                          uint16_t total_encrypted_data_length,
+                                                                          uint8_t * plain_data,
+                                                                          uint32_t * plain_data_length);
+
+/**
+ * \brief Decrypts input encrypted data using symmetric key from OPTIGA and exports block aligned plain data.<br>
+ *
+ * \details
+ * Decrypts input encrypted data using symmetric key from OPTIGA and exports block aligned plain data.<br>
+ * - Invokes #optiga_cmd_decrypt_sym API, based on the input arguments.<br>
+ * - Decrypts the input message and exports the decrypted message.<br>
+ * - Encryption mode and the Symmetric key OID specified in #optiga_crypt_symmetric_decrypt_start is used to decrypt the data by OPTIGA.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The decryption sequence must have been initiated, by invoking #optiga_crypt_symmetric_decrypt_start, before calling this API.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, value set in #optiga_crypt_symmetric_decrypt_start is used in this API.<br>
+ * - No internal padding is performed by OPTIGA, hence encrypted data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated in case of an error from lower layer<br>
+ * - Invoking this API without successful completion of #optiga_crypt_symmetric_decrypt_start throws #OPTIGA_CMD_ERROR_INVALID_INPUT error.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encrypted_data                        Pointer to the data to be decrypted.
+ * \param[in]         encrypted_data_length                 Length of the data to be decrypted.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ * \param[in,out]     plain_data                            Pointer to buffer to store plain data.
+ * \param[in,out]     plain_data_length                     Pointer to length of the <b>plain_data</b>. Initial value set as length of buffer, later updated as the actual length of plain data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the plain data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_decrypt_continue(optiga_crypt_t * me,
+                                                                             const uint8_t * encrypted_data,
+                                                                             uint32_t encrypted_data_length,
+                                                                             uint8_t * plain_data,
+                                                                             uint32_t * plain_data_length);
+
+/**
+ * \brief Decrypts input data using symmetric key from OPTIGA, exports block aligned plain data and completes the decryption sequence.<br>
+ *
+ * \details
+ * Decrypts input data using symmetric key from OPTIGA, exports block aligned plain data and completes the decryption sequence.<br>
+ * - Invokes #optiga_cmd_decrypt_sym API, based on the input arguments to generate and export the plain message to host.<br>
+ * - Decrypts the input message and exports the decrypted message.<br>
+ * - Encryption mode and the symmetric key OID specified in #optiga_crypt_symmetric_decrypt_start is used to decrypt the data by OPTIGA.<br>
+ * - It terminates the strict sequence.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The decryption sequence must have been initiated, by invoking #optiga_crypt_symmetric_decrypt_start, before calling this API.<br>
+ * - Symmetric key must be available at symmetric key OID in OPTIGA.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, value set in #optiga_crypt_symmetric_decrypt_start is used in this API.<br>
+ * - No internal padding is performed by OPTIGA, hence encrypted data length must be block aligned (minimum 1 block).<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated in case of an error from lower layer<br>
+ * - Invoking this API without successful completion of #optiga_crypt_symmetric_decrypt_start throws #OPTIGA_CMD_ERROR_INVALID_INPUT error.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         encrypted_data                        Pointer to the data to be decrypted.
+ * \param[in]         encrypted_data_length                 Length of the data to be decrypted.
+ *                                                          - It must be block aligned, otherwise OPTIGA returns an error.<br>
+ * \param[in,out]     plain_data                            Pointer to buffer to store plain data.
+ * \param[in,out]     plain_data_length                     Pointer to length of the <b>plain_data</b>. Initial value set as length of buffer, later updated as the actual length of plain data.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the plain data.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_encrypt_decrypt.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_decrypt_final(optiga_crypt_t * me,
+                                                                          const uint8_t * encrypted_data,
+                                                                          uint32_t encrypted_data_length,
+                                                                          uint8_t * plain_data,
+                                                                          uint32_t * plain_data_length);
+#endif //OPTIGA_CRYPT_SYM_DECRYPT_ENABLED
+
+
+#ifdef OPTIGA_CRYPT_HMAC_ENABLED
+/**
+ * \brief Generates HMAC on the input message using input secret from OPTIGA and exports the generated HMAC to the host.<br>
+ *
+ * \details
+ * Generates HMAC on the input message using input secret from OPTIGA and exports the generated HMAC to host.<br>
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.
+ * - Generates HMAC on the input data and exports it to host.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_COMMAND_PROTECTION.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ 
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         type                                  HMAC type
+ * \param[in]         secret                                OPTIGA OID with input secret
+ *                                                          - Input secret must be available at the specified OID.<br> 
+ *                                                          - To indicate session OID (already acquired by instance), specify #OPTIGA_KEY_ID_SESSION_BASED
+ * \param[in]         input_data                            Pointer to input data for HMAC generation.
+ * \param[in]         input_data_length                     Length of input data for HMAC generation.
+ *                                                          - Must be greater than 0.<br>
+ * \param[in,out]     mac                                   Pointer to buffer to store generated HMAC
+ * \param[in,out]     mac_length                            Pointer to length of the <b>mac</b>. Initial value set as length of buffer, later updated as the actual length of generated HMAC.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the HMAC.
+ *                                                          - If the <b>mac_length</b> is lesser than the length of MAC received from OPTIGA, then first <b>mac_length</b> bytes are only returned.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hmac.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hmac(optiga_crypt_t * me,
+                                                       optiga_hmac_type_t type,
+                                                       uint16_t secret,
+                                                       const uint8_t * input_data,
+                                                       uint32_t input_data_length,
+                                                       uint8_t * mac,
+                                                       uint32_t * mac_length);
+
+/**
+ * \brief Initiates a HMAC generation sequence for the input data using input secret from OPTIGA.<br>
+ *
+ * \details
+ * Initiates a HMAC generation sequence for the input data.<br>
+ * - It marks the beginning of a strict sequence. None of the service layer API will be processed until the strict sequence is terminated.
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.
+ * - Generates HMAC on the input data but does not export it to host.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_COMMAND_PROTECTION.<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated
+ *   - In case of an error from lower layer.<br>
+ *   - Same instance is used for other service layer APIs (except #optiga_crypt_hmac_update and #optiga_crypt_hmac_finalize).<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         type                                  HMAC type
+ * \param[in]         secret                                OPTIGA OID with input secret
+ *                                                          - Input secret must be available at the specified OID.<br>
+ *                                                          - To indicate session OID (already acquired by instance), specify #OPTIGA_KEY_ID_SESSION_BASED
+ * \param[in]         input_data                            Pointer to input data for HMAC generation.
+ * \param[in]         input_data_length                     Length of input data for HMAC generation.
+ *                                                          - Must be greater than 0.<br>
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hmac.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hmac_start(optiga_crypt_t * me,
+                                                             optiga_hmac_type_t type,
+                                                             uint16_t secret,
+                                                             const uint8_t * input_data,
+                                                             uint32_t input_data_length);
+
+/**
+ * \brief Generates HMAC on the input message using input secret from OPTIGA, update the previously generated HMAC value internally.<br>
+ *
+ * \details
+ * Generates HMAC on the input message using input secret from OPTIGA and updates the previously generated HMAC value internally.<br>
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.
+ * - Generates HMAC on the input data but does not export it to host.
+ * - Input secret specified in #optiga_crypt_hmac_start is used to generate HMAC.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The HMAC sequence must have been initiated, by invoking #optiga_crypt_hmac_start, before calling this API.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, value set in #optiga_crypt_hmac_start is used in this API.<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated in case of an error from lower layer<br>
+ * - Invoking this API without successful completion of #optiga_crypt_hmac_start throws #OPTIGA_CMD_ERROR_INVALID_INPUT error.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         input_data                            Pointer to input data for HMAC generation.
+ * \param[in]         input_data_length                     Length of input data for HMAC generation.
+ *                                                          - Must be greater than 0.<br>
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hmac.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hmac_update(optiga_crypt_t * me,
+                                                              const uint8_t * input_data,
+                                                              uint32_t input_data_length);
+
+/**
+ * \brief Generates HMAC on the input message using input secret from OPTIGA and exports the finalized HMAC to host.<br>
+ *
+ * \details
+ * Generates HMAC on the input message using input secret from OPTIGA and exports the finalized HMAC to host.<br>
+ * - Invokes #optiga_cmd_encrypt_sym API, based on the input arguments.
+ * - Generates HMAC on the input data and exports it to host.
+ * - Input secret specified in #optiga_crypt_hmac_start is used to generate HMAC.<br>
+ * - It terminates the strict sequence.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The HMAC sequence must have been initiated, by invoking #optiga_crypt_hmac_start, before calling this API.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, value set in #optiga_crypt_hmac_start is used in this API.<br>
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ * - The strict sequence is terminated in case of an error from lower layer<br>
+ * - Invoking this API without successful completion of #optiga_crypt_hmac_start throws #OPTIGA_CMD_ERROR_INVALID_INPUT error.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         input_data                            Pointer to input data for HMAC generation.
+ * \param[in]         input_data_length                     Length of input data for HMAC generation.
+ *                                                          - Must be greater than 0.<br>
+ * \param[in,out]     mac                                   Pointer to buffer to store generated HMAC
+ * \param[in,out]     mac_length                            Pointer to length of the <b>mac</b>. Initial value set as length of buffer, later updated as the actual length of generated HMAC.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the HMAC.
+ *                                                          - If the <b>mac_length</b> is lesser than the length of MAC received from OPTIGA, then first <b>mac_length</b> bytes are only returned.
+ *                                                          - In case of any error, the value is set to 0.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hmac.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hmac_finalize(optiga_crypt_t * me,
+                                                                const uint8_t * input_data,
+                                                                uint32_t input_data_length,
+                                                                uint8_t * mac,
+                                                                uint32_t * mac_length);
+#endif //OPTIGA_CRYPT_HMAC_ENABLED
+                                                                
+#ifdef OPTIGA_CRYPT_HKDF_ENABLED
+/**
+ * \brief Derives a key or shared secret using HKDF operation from the secret stored in OPTIGA.<br>
+ *
+ * \details
+ * Derives a key or shared secret using HKDF operation from the secret stored in OPTIGA.
+ * - Invokes #optiga_cmd_derive_key API, based on the input arguments.<br>
+ * - The derived key is either stored in a OPTIGA session context or exported back to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ * - If the secret type is #OPTIGA_KEY_ID_SESSION_BASED then session must be already available in the instance.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION if secret is in session OID.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         type                                     HKDF scheme as #optiga_hkdf_type_t.
+ * \param[in]         secret                                   Object ID of the secret stored in OPTIGA.
+ *                                                             - #OPTIGA_KEY_ID_SESSION_BASED from #optiga_key_id_t, indicates the secret is available
+ *                                                               in the session context acquired by the instance.
+ *                                                             - or any OPTIGA data object ID(16 bit OID) which holds the secret.
+ * \param[in]         salt                                     Pointer to buffer containing salt value, can be NULL if not applicable.
+ * \param[in]         salt_length                              Length of salt.
+ * \param[in]         info                                     Pointer to buffer containing application specific information, can be NULL if not applicable.
+ * \param[in]         info_length                              Length of info.
+ * \param[in]         derived_key_length                       Length of derived key.
+ *                                                             - The minimum length of the output derived key can be 1 byte, if derived key is exported.
+ * \param[in]         export_to_host                           TRUE (1) or Non-Zero value - Exports the derived key to Host. <br>
+ *                                                             FALSE (0) - Stores the derived key into the session object ID acquired by the instance.
+ * \param[in,out]     derived_key                              Pointer to the valid buffer with a minimum size of derived_key_length,
+ *                                                             in case of exporting the key to host(<b>export_to_host is non-zero value</b>). Otherwise set to NULL.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                    Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided.<br>
+                                                               Session is not available in instance and the secret type is #OPTIGA_KEY_ID_SESSION_BASED
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                             (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hkdf.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hkdf(optiga_crypt_t * me,
+                                                      optiga_hkdf_type_t type,
+                                                      uint16_t secret,
+                                                      const uint8_t * salt,
+                                                      uint16_t salt_length,
+                                                      const uint8_t * info,
+                                                      uint16_t info_length,
+                                                      uint16_t derived_key_length,
+                                                      bool_t export_to_host,
+                                                      uint8_t * derived_key);
+
+/**
+ * \brief Derives a key or shared secret using HKDF-SHA256 operation from the secret stored in OPTIGA.<br>
+ *
+ * \details
+ * Derives a key or shared secret using HKDF-SHA256 operation from the secret stored in OPTIGA.
+ * - Invokes #optiga_cmd_derive_key API, based on the input arguments.<br>
+ * - The derived key is either stored in a OPTIGA session context or exported back to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ * - If the secret type is #OPTIGA_KEY_ID_SESSION_BASED then session must be already available in the instance.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION if secret is in session OID.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         secret                                   Object ID of the secret stored in OPTIGA.
+ *                                                             - #OPTIGA_KEY_ID_SESSION_BASED from #optiga_key_id_t, indicates the secret is available
+ *                                                               in the session context acquired by the instance.
+ *                                                             - or any OPTIGA data object ID(16 bit OID) which holds the secret.
+ * \param[in]         salt                                     Pointer to buffer containing salt value, can be NULL if not applicable.
+ * \param[in]         salt_length                              Length of salt.
+ * \param[in]         info                                     Pointer to buffer containing application specific information, can be NULL if not applicable.
+ * \param[in]         info_length                              Length of info.
+ * \param[in]         derived_key_length                       Length of derived key.
+ *                                                             - The minimum length of the output derived key can be 1 byte, if derived key is exported.
+ * \param[in]         export_to_host                           TRUE (1) or Non-Zero value - Exports the derived key to Host. <br>
+ *                                                             FALSE (0) - Stores the derived key into the session object ID acquired by the instance.
+ * \param[in,out]     derived_key                              Pointer to the valid buffer with a minimum size of derived_key_length,
+ *                                                             in case of exporting the key to host(<b>export_to_host is non-zero value</b>). Otherwise set to NULL.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                    Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided.<br>
+                                                               Session is not available in instance and the secret type is #OPTIGA_KEY_ID_SESSION_BASED
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                             (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hkdf.c
+ *
+ */
+_STATIC_INLINE LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hkdf_sha256(optiga_crypt_t * me,
+                                                                            uint16_t secret,
+                                                                            const uint8_t * salt,
+                                                                            uint16_t salt_length,
+                                                                            const uint8_t * info,
+                                                                            uint16_t info_length,
+                                                                            uint16_t derived_key_length,
+                                                                            bool_t export_to_host,
+                                                                            uint8_t * derived_key)
+{
+    return (optiga_crypt_hkdf(me,
+                              OPTIGA_HKDF_SHA_256,
+                              secret,
+                              salt,
+                              salt_length,
+                              info,
+                              info_length,
+                              derived_key_length,
+                              export_to_host,
+                              derived_key));
+}
+
+/**
+ * \brief Derives a key or shared secret using HKDF-SHA384 operation from the secret stored in OPTIGA.<br>
+ *
+ * \details
+ * Derives a key or shared secret using HKDF-SHA384 operation from the secret stored in OPTIGA.
+ * - Invokes #optiga_cmd_derive_key API, based on the input arguments.<br>
+ * - The derived key is either stored in a OPTIGA session context or exported back to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ * - If the secret type is #OPTIGA_KEY_ID_SESSION_BASED then session must be already available in the instance.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION if secret is in session OID.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         secret                                   Object ID of the secret stored in OPTIGA.
+ *                                                             - #OPTIGA_KEY_ID_SESSION_BASED from #optiga_key_id_t, indicates the secret is available
+ *                                                               in the session context acquired by the instance.
+ *                                                             - or any OPTIGA data object ID(16 bit OID) which holds the secret.
+ * \param[in]         salt                                     Pointer to buffer containing salt value, can be NULL if not applicable.
+ * \param[in]         salt_length                              Length of salt.
+ * \param[in]         info                                     Pointer to buffer containing application specific information, can be NULL if not applicable.
+ * \param[in]         info_length                              Length of info.
+ * \param[in]         derived_key_length                       Length of derived key.
+ *                                                             - The minimum length of the output derived key can be 1 byte, if derived key is exported.
+ * \param[in]         export_to_host                           TRUE (1) or Non-Zero value - Exports the derived key to Host. <br>
+ *                                                             FALSE (0) - Stores the derived key into the session object ID acquired by the instance.
+ * \param[in,out]     derived_key                              Pointer to the valid buffer with a minimum size of derived_key_length,
+ *                                                             in case of exporting the key to host(<b>export_to_host is non-zero value</b>). Otherwise set to NULL.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                    Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided.<br>
+                                                               Session is not available in instance and the secret type is #OPTIGA_KEY_ID_SESSION_BASED
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                             (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * None
+ *
+ */
+
+_STATIC_INLINE LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hkdf_sha384(optiga_crypt_t * me,
+                                                                            uint16_t secret,
+                                                                            const uint8_t * salt,
+                                                                            uint16_t salt_length,
+                                                                            const uint8_t * info,
+                                                                            uint16_t info_length,
+                                                                            uint16_t derived_key_length,
+                                                                            bool_t export_to_host,
+                                                                            uint8_t * derived_key)
+{
+    return (optiga_crypt_hkdf(me,
+                              OPTIGA_HKDF_SHA_384,
+                              secret,
+                              salt,
+                              salt_length,
+                              info,
+                              info_length,
+                              derived_key_length,
+                              export_to_host,
+                              derived_key));
+}
+
+/**
+ * \brief Derives a key or shared secret using HKDF-SHA512 operation from the secret stored in OPTIGA.<br>
+ *
+ * \details
+ * Derives a key or shared secret using HKDF-SHA384 operation from the secret stored in OPTIGA.
+ * - Invokes #optiga_cmd_derive_key API, based on the input arguments.<br>
+ * - The derived key is either stored in a OPTIGA session context or exported back to the host.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ * - If the secret type is #OPTIGA_KEY_ID_SESSION_BASED then session must be already available in the instance.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ *      - Default protection level for this API is OPTIGA_COMMS_COMMAND_PROTECTION if secret is in session OID.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         secret                                   Object ID of the secret stored in OPTIGA.
+ *                                                             - #OPTIGA_KEY_ID_SESSION_BASED from #optiga_key_id_t, indicates the secret is available
+ *                                                               in the session context acquired by the instance.
+ *                                                             - or any OPTIGA data object ID(16 bit OID) which holds the secret.
+ * \param[in]         salt                                     Pointer to buffer containing salt value, can be NULL if not applicable.
+ * \param[in]         salt_length                              Length of salt.
+ * \param[in]         info                                     Pointer to buffer containing application specific information, can be NULL if not applicable.
+ * \param[in]         info_length                              Length of info.
+ * \param[in]         derived_key_length                       Length of derived key.
+ *                                                             - The minimum length of the output derived key can be 1 byte, if derived key is exported.
+ * \param[in]         export_to_host                           TRUE (1) or Non-Zero value - Exports the derived key to Host. <br>
+ *                                                             FALSE (0) - Stores the derived key into the session object ID acquired by the instance.
+ * \param[in,out]     derived_key                              Pointer to the valid buffer with a minimum size of derived_key_length,
+ *                                                             in case of exporting the key to host(<b>export_to_host is non-zero value</b>). Otherwise set to NULL.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                    Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT        Wrong Input arguments provided.<br>
+                                                               Session is not available in instance and the secret type is #OPTIGA_KEY_ID_SESSION_BASED
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE      The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                             (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * None
+ *
+ */
+
+_STATIC_INLINE LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hkdf_sha512(optiga_crypt_t * me,
+                                                                            uint16_t secret,
+                                                                            const uint8_t * salt,
+                                                                            uint16_t salt_length,
+                                                                            const uint8_t * info,
+                                                                            uint16_t info_length,
+                                                                            uint16_t derived_key_length,
+                                                                            bool_t export_to_host,
+                                                                            uint8_t * derived_key)
+{
+    return (optiga_crypt_hkdf(me,
+                              OPTIGA_HKDF_SHA_512,
+                              secret,
+                              salt,
+                              salt_length,
+                              info,
+                              info_length,
+                              derived_key_length,
+                              export_to_host,
+                              derived_key));
+}
+#endif //OPTIGA_CRYPT_HKDF_ENABLED
+
+#ifdef OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+
+/**
+ * \brief Generates a symmetric key using OPTIGA.
+ *
+ * \details
+ * Generates a symmetric key using OPTIGA for different key sizes.
+ * - Invokes #optiga_cmd_gen_symkey API, based on input arguments.
+ * - Symmetric key is generated based on the key type.<br>
+ * - If export to host is requested, exports the symmetric key back to host otherwise stores it in the provided symmetric key OID.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers is returned as it is.
+ *
+ * \param[in]       me                                      Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]       key_type                                Key type of #optiga_symmetric_key_type_t.
+ * \param[in]       key_usage                               Key usage defined in #optiga_key_usage_t.
+ *                                                          - It is ignored if export_symmetric_key is TRUE (1) or Non-Zero.
+ * \param[in]       export_symmetric_key                    TRUE (1) or Non-Zero value - Exports symmetric key to the host.<br>
+ *                                                          FALSE (0) - Stores symmetric key in OPTIGA.
+ * \param[in,out]   symmetric_key                           Pointer to buffer of symmetric key.
+ *                                                          - If export_symmetric_key is TRUE or non-zero, assign pointer to a buffer to store symmetric key. 
+ *                                                          - If export_symmetric_key is FALSE, assign pointer to variable of type #optiga_key_id_t.
+ *                                                          - The size of the buffer must be sufficient enough to accommodate the key. 
+ *
+ * \retval          #OPTIGA_CRYPT_SUCCESS                   Successful invocation.
+ * \retval          #OPTIGA_CRYPT_ERROR_INVALID_INPUT       Wrong Input arguments provided.
+ * \retval          #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete.
+ * \retval          #OPTIGA_DEVICE_ERROR                    Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_symmetric_generate_key.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_symmetric_generate_key(optiga_crypt_t * me,
+                                                                        optiga_symmetric_key_type_t key_type,
+                                                                        uint8_t key_usage,
+                                                                        bool_t export_symmetric_key,
+                                                                        void * symmetric_key);
+#endif //OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+
+#ifdef OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED
+
+/**
+ * \brief Generates a random number using OPTIGA and stores the same in acquired session context at OPTIGA. 
+ *
+ * \details
+ * Generates random stream code for user provided length.
+ * - Invokes #optiga_cmd_get_random API, based on the input arguments to retrieve random data <br>
+ * - Generated random is returned to host .
+ * - Generated random and optional data is also stored in the session context acquired at OPTIGA.
+ * - Data stored in the acquired session context acquired at OPTIGA is used as an auth code.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers is returned as it is.
+ * - Minimum length of generated random data is 8 bytes. 
+ * - Auth Code is a concatenation of optional data and random data. 
+ * - Maximum length of auth code is 48 bytes.
+ *
+ * \param[in]      me                                       Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]      rng_type                                 Type of random data generator.
+ *                                                          - The input must be from #optiga_rng_type.
+ *                                                          - Argument check for rng_type is not done since OPTIGA will provide an error for invalid rng_type.
+ * \param[in]      optional_data                            Optional data that gets prepended to the generated random secret.
+ *                                                          - Can be set to NULL, if not required
+ * \param[in]      optional_data_length                     Length of the optional data provided. It is ignored if optional_data is NULL
+ *                                                          - Value can be up to 58 bytes
+ *                                                          - Difference in random data length and optional data length is less than 8 bytes 
+ * \param[in,out]  random_data                              Pointer to the buffer into which random data is stored, must not be NULL.
+ * \param[in]      random_data_length                       Length of random data to be generated.
+ *                                                          - Minimum range is 8 bytes.
+ *
+ * \retval          #OPTIGA_CRYPT_SUCCESS                   Successful invocation.
+ * \retval          #OPTIGA_CRYPT_ERROR_INVALID_INPUT       Wrong Input arguments provided.
+ * \retval          #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete.
+ * \retval          #OPTIGA_DEVICE_ERROR                    Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_generate_auth_code(optiga_crypt_t * me,
+                                                                    optiga_rng_type_t rng_type,
+                                                                    const uint8_t * optional_data,
+                                                                    uint16_t optional_data_length,
+                                                                    uint8_t * random_data,
+                                                                    uint16_t random_data_length);
+#endif //OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED
+
+#ifdef OPTIGA_CRYPT_HMAC_VERIFY_ENABLED
+/**
+ * \brief Performs the HMAC verification for the provided authorization value using OPTIGA.<br>
+ *
+ * \details
+ * Verifies HMAC generated at host with HMAC generated from OPTIGA for the provided authorization value.<br>
+ * - Invokes #optiga_cmd_decrypt_sym API, based on the input arguments.<br>
+ * - Acquired session gets released after completion of hmac verify operation between host and OPTIGA.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ * - The data object specified by input <b>secret</b> must have a secret written into it.<br>
+ * - Session has already been acquired by #optiga_crypt_generate_auth_code.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_RESPONSE_PROTECTION.
+ * - Error codes from lower layers is returned as it is to the application.<br>
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         type                                  HMAC type as #optiga_hmac_type_t
+ * \param[in]         secret                                OPTIGA OID with input secret
+ *                                                          - Input secret must be available at the specified OID.<br> 
+ *                                                          - Data object type must be AUTOREF.
+ * \param[in]         input_data                            Pointer to input data for HMAC generation.
+ *                                                          - Input data is concatenation of optional data, random and arbitrary data.
+ *                                                          - Optional data is input provided to #optiga_crypt_generate_auth_code 
+ *                                                            and random data is returned by #optiga_crypt_generate_auth_code. 
+ * \param[in]         input_data_length                     Length of input data.
+ *                                                          - Must be greater than 0.<br>
+ * \param[in]         hmac                                  Pointer to buffer of HMAC generated at host which gets verified at OPTIGA.
+ * \param[in]         hmac_length                           Length of the generated <b>hmac</b> at host. 
+ *                                                          - Host generated hmac length must be the size of output defined in respective hash algorithm used in hmac scheme.
+ *
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ * \retval            #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_hmac_verify.c
+ *
+ */
+ LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_hmac_verify(optiga_crypt_t * me,
+                                                              optiga_hmac_type_t type,
+                                                              uint16_t secret,
+                                                              const uint8_t * input_data,
+                                                              uint32_t input_data_length,
+                                                              const uint8_t * hmac,
+                                                              uint32_t hmac_length);
+#endif // OPTIGA_CRYPT_HMAC_VERIFY_ENABLED
+#ifdef OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED
+/**
+ * \brief This operation clears the AUTO state at OPTIGA for input secret OID.<br>
+ *
+ * \details
+ * Clears the AUTO state and session if it's already acquired.<br>
+ * - Invokes #optiga_cmd_decrypt_sym API, based on the input arguments.<br>
+ * - Acquired session is released after completion of clear auto state operation.<br>
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.<br>
+ *
+ * \note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL.
+ *      - Default protection level for this API is #OPTIGA_COMMS_RESPONSE_PROTECTION.
+ *
+ * \param[in]         me                                    Valid instance of #optiga_crypt_t created using #optiga_crypt_create.
+ * \param[in]         secret                                OPTIGA OID with input secret. It should be of AUTOREF type
+
+ * \retval            #OPTIGA_CRYPT_SUCCESS                 Successful invocation
+ * \retval            #OPTIGA_CRYPT_ERROR_INVALID_INPUT     Wrong Input arguments provided
+ * \retval            #OPTIGA_CRYPT_ERROR_INSTANCE_IN_USE   The previous operation with the same instance is not complete
+ *
+ * <b>Example</b><br>
+ * example_optiga_crypt_clear_auto_state.c
+ *
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_crypt_clear_auto_state(optiga_crypt_t * me,
+                                                                  uint16_t secret);
+
+#endif //OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED
+/**
+ * \brief Enables the protected I2C communication with OPTIGA for CRYPT instances
+ *
+ * \details
+ * Enables the protected I2C communication with OPTIGA
+ * - Sets the protection mode for the supplied instance.<br>
+ * - Call this function before calling the service layer API which requires protection.
+ * - The callback registered with instance (#optiga_crypt_create) gets invoked, when the operation is asynchronously completed.
+ *
+ * \pre
+ * - #OPTIGA_COMMS_SHIELDED_CONNECTION macro must be defined.<br>
+ * - #OPTIGA_CRYPT_SET_COMMS_PROTOCOL_VERSION function must be called once to set the required protocol version
+ *   - Currently only the Pre-shared Secret based version is supported.
+ * - The host and OPTIGA must be paired and Pre-Shared secret is available.<br>
+ *
+ * \note
+ * - The protection mode for the instance is reset to #OPTIGA_COMMS_NO_PROTECTION once the service layer API returns synchronously.
+ *
+ * \param[in]      p_instance           Valid pointer to an instance
+ * \param[in]      protection_level     Required protection mode
+ *                                      - #OPTIGA_COMMS_NO_PROTECTION : Command and response is unprotected
+ *                                      - #OPTIGA_COMMS_COMMAND_PROTECTION : Command is protected and response is unprotected
+ *                                      - #OPTIGA_COMMS_RESPONSE_PROTECTION : Command is unprotected and response is protected
+ *                                      - #OPTIGA_COMMS_FULL_PROTECTION : Both command and response is protected
+ *                                      - To re-establish secure channel, bitwise-OR protection_level with #OPTIGA_COMMS_RE_ESTABLISH
+ */
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+#define OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL(p_instance, protection_level) \
+{ \
+    optiga_crypt_set_comms_params(p_instance, \
+                                  OPTIGA_COMMS_PROTECTION_LEVEL, \
+                                  protection_level);\
+}
+#else
+#define OPTIGA_CRYPT_SET_COMMS_PROTECTION_LEVEL(p_instance, protection_level) {}
+#endif
+
+/**
+ * \brief Select the protocol version required for the I2C protected communication for CRYPT instances
+ *
+ * \details
+ * Select the protocol version required for the I2C protected communication
+ * - Select the protocol version for the supplied instance.<br>
+ *
+ * \pre
+ * - #OPTIGA_COMMS_SHIELDED_CONNECTION macro must be defined.<br>
+ *
+ * \note
+ * - None
+ *
+ * \param[in]      p_instance    Valid pointer to an instance
+ * \param[in]      version       Required protocol version
+ *                               - #OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET : Pre-shared Secret based protocol version
+ */
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+#define OPTIGA_CRYPT_SET_COMMS_PROTOCOL_VERSION(p_instance, version) \
+{ \
+    optiga_crypt_set_comms_params(p_instance, \
+                                  OPTIGA_COMMS_PROTOCOL_VERSION, \
+                                  version);\
+}
+#else
+#define OPTIGA_CRYPT_SET_COMMS_PROTOCOL_VERSION(p_instance, version) {}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_CRYPT_H_*/
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/optiga_lib_config.h b/3rdparty/experimental/optiga/optiga/include/optiga/optiga_lib_config.h
new file mode 100644
index 000000000..a1f39f3fb
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/optiga_lib_config.h
@@ -0,0 +1,142 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_lib_config.h
+*
+* \brief   This file is defines the compilation switches to build code with required features.
+*
+* \ingroup grOptigaLibCommon
+*
+* @{
+*/
+
+
+#ifndef _OPTIGA_LIB_CONFIG_H_
+#define _OPTIGA_LIB_CONFIG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPTIGA_LIB_EXTERNAL
+    #include "optiga_lib_config_external.h"
+#else
+    /** @brief OPTIGA CRYPT random number generation feature enable/disable macro */
+    #define OPTIGA_CRYPT_RANDOM_ENABLED
+    /** @brief OPTIGA CRYPT hash feature enable/disable macro */
+    #define OPTIGA_CRYPT_HASH_ENABLED
+    /** @brief OPTIGA CRYPT TLS PRF feature enable/disable macro */
+    #define OPTIGA_CRYPT_TLS_PRF_ENABLED
+    /** @brief OPTIGA CRYPT RSA generate keypair feature enable/disable macro */
+    #define OPTIGA_CRYPT_RSA_GENERATE_KEYPAIR_ENABLED
+    /** @brief OPTIGA CRYPT RSA sign feature enable/disable macro */
+    #define OPTIGA_CRYPT_RSA_SIGN_ENABLED
+    /** @brief OPTIGA CRYPT RSA verify sign feature enable/disable macro */
+    #define OPTIGA_CRYPT_RSA_VERIFY_ENABLED
+    /** @brief OPTIGA CRYPT RSA Encrypt feature enable/disable macro */
+    #define OPTIGA_CRYPT_RSA_ENCRYPT_ENABLED
+    /** @brief OPTIGA CRYPT RSA Decrypt feature enable/disable macro */
+    #define OPTIGA_CRYPT_RSA_DECRYPT_ENABLED
+    /** @brief OPTIGA CRYPT RSA pre-master feature enable/disable macro */
+    #define OPTIGA_CRYPT_RSA_PRE_MASTER_SECRET_ENABLED
+    /** @brief OPTIGA CRYPT symmetric encrypt feature enable/disable macro */
+    #define OPTIGA_CRYPT_SYM_ENCRYPT_ENABLED
+    /** @brief OPTIGA CRYPT symmetric decrypt feature enable/disable macro */
+    #define OPTIGA_CRYPT_SYM_DECRYPT_ENABLED
+    /** @brief OPTIGA CRYPT HMAC feature enable/disable macro */
+    #define OPTIGA_CRYPT_HMAC_ENABLED
+    /** @brief OPTIGA CRYPT HKDF feature enable/disable macro */
+    #define OPTIGA_CRYPT_HKDF_ENABLED
+    /** @brief OPTIGA CRYPT symmetric generate key feature enable/disable macro */
+    #define OPTIGA_CRYPT_SYM_GENERATE_KEY_ENABLED
+    /** @brief OPTIGA CRYPT generate auth code feature enable/disable macro */
+    #define OPTIGA_CRYPT_GENERATE_AUTH_CODE_ENABLED
+    /** @brief OPTIGA CRYPT HMAC verify feature enable/disable macro */
+    #define OPTIGA_CRYPT_HMAC_VERIFY_ENABLED
+    /** @brief OPTIGA CRYPT clear AUTO state feature enable/disable macro */
+    #define OPTIGA_CRYPT_CLEAR_AUTO_STATE_ENABLED
+    
+    /** @brief NULL parameter check.
+     *         To disable the check, undefine the macro
+     */
+    #define OPTIGA_LIB_DEBUG_NULL_CHECK
+    /** @brief Maximum number of instance registration */
+    #define OPTIGA_CMD_MAX_REGISTRATIONS                (0x06)
+    /** @brief Maximum buffer size required to communicate with OPTIGA */
+    #define OPTIGA_MAX_COMMS_BUFFER_SIZE                (0x615) //1557 in decimal
+
+    /** @brief Macro to enable logger \n
+    * Enable macro OPTIGA_LIB_ENABLE_UTIL_LOGGING for Util Service layer logging     \n
+    * Enable macro OPTIGA_LIB_ENABLE_CRYPT_LOGGING for Crypt Service layer logging     \n
+    * Enable macro OPTIGA_LIB_ENABLE_CMD_LOGGING for Command layer logging     \n
+    * Enable macro OPTIGA_LIB_ENABLE_COMMS_LOGGING for Communication layer logging     */
+    #define OPTIGA_LIB_ENABLE_LOGGING
+    /** @brief Enable macro OPTIGA_PAL_INIT_ENABLED for calling pal_init functionality */
+    #define OPTIGA_PAL_INIT_ENABLED
+/// @cond
+#ifdef OPTIGA_LIB_ENABLE_LOGGING
+    /** @brief Macro to enable logger for Util service */
+    //#define OPTIGA_LIB_ENABLE_UTIL_LOGGING
+    /** @brief Macro to enable logger for Crypt service */
+    //#define OPTIGA_LIB_ENABLE_CRYPT_LOGGING
+    /** @brief Macro to enable logger for Command layer */
+    //#define OPTIGA_LIB_ENABLE_CMD_LOGGING
+    /** @brief Macro to enable logger for Communication layer */
+    //#define OPTIGA_LIB_ENABLE_COMMS_LOGGING
+#endif
+/// @endcond
+
+    /** @brief OPTIGA COMMS shielded connection feature.
+     *         To disable the feature, undefine the macro
+     */
+    //#define OPTIGA_COMMS_SHIELDED_CONNECTION
+
+    /** @brief Default reset protection level for OPTIGA CRYPT and UTIL APIs */
+    #define OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL           OPTIGA_COMMS_NO_PROTECTION
+
+  /** @brief Default reset type in optiga_comms_open.             \n
+     *         Cold Reset - (0) : This is applicable if the host platform has GPIO option for RST and VDD.    \n
+     *         Soft Reset - (1) : This is applicable if the host platform doesn't have GPIO options for VDD and RST.  \n
+     *         Warm Reset - (2) : This is applicable if the host platform doesn't have GPIO option for VDD. \n
+     *         Any other value will lead to error
+     */
+    #define OPTIGA_COMMS_DEFAULT_RESET_TYPE     (0U)
+
+
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OPTIGA_LIB_CONFIG_H_*/
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/optiga_lib_version.h b/3rdparty/experimental/optiga/optiga/include/optiga/optiga_lib_version.h
new file mode 100644
index 000000000..272e0ab84
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/optiga_lib_version.h
@@ -0,0 +1,56 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_lib_version.h
+*
+* \brief   This file contains Optiga library version information.
+*
+* \ingroup grOptigaLibCommon
+*
+* @{
+*/
+
+#ifndef _OPTIGA_LIB_VERSION_H_
+#define _OPTIGA_LIB_VERSION_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/// OPTIGA Library version information
+#define OPTIGA_LIB_VERSION "Ver 2.00.2473"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_LIB_VERSION_H_*/
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/optiga_util.h b/3rdparty/experimental/optiga/optiga/include/optiga/optiga_util.h
new file mode 100644
index 000000000..417c6850c
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/optiga_util.h
@@ -0,0 +1,624 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_util.h
+*
+* \brief   This file defines APIs, types and data structures used in the OPTIGA utility module.
+*
+* \ingroup  grOptigaUtil
+*
+* @{
+*/
+
+
+#ifndef _OPTIGA_UTIL_H_
+#define _OPTIGA_UTIL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/cmd/optiga_cmd.h"
+
+/// Option to only write the data object
+#define OPTIGA_UTIL_WRITE_ONLY      (0x00)
+/// Option to erase and write the data object
+#define OPTIGA_UTIL_ERASE_AND_WRITE (0x40)
+
+
+/// To Initialize a clean application context
+#define OPTIGA_UTIL_CONTEXT_NONE        (0x00)
+
+/** \brief union for OPTIGA util parameters */
+typedef union optiga_util_params
+{
+    // set data object params
+    optiga_set_data_object_params_t optiga_set_data_object_params;
+    // get data object params
+    optiga_get_data_object_params_t optiga_get_data_object_params;
+    // set object protected params
+    optiga_set_object_protected_params_t optiga_set_object_protected_params;
+}optiga_util_params_t;
+
+/** \brief OPTIGA util instance structure */
+struct optiga_util
+{
+    ///Details/references (pointers) to the Application Inputs
+    optiga_util_params_t params;
+    ///pointer to optiga command instance
+    optiga_cmd_t * my_cmd;
+    /// Callback context
+    void* caller_context;
+    /// Callback handler
+    callback_handler_t handler;
+    ///To provide the busy/free status of the util instance
+    uint16_t instance_state;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+    /// To provide the encryption and decryption need for command and response
+    uint8_t protection_level;
+    /// To provide the presentation layer protocol version to be used
+    uint8_t protocol_version;
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+
+};
+/** \brief OPTIGA util instance structure type*/
+typedef struct optiga_util optiga_util_t;
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+/**
+ * \brief Sets/updates the OPTIGA Comms Shielded connection configuration in
+ *        the respective (optiga_util) instance.
+ *
+ *\details
+ * Sets/updates the OPTIGA Comms Shielded connection configuration in the respective (optiga_util) instance.
+ * - The #OPTIGA_COMMS_PROTECTION_LEVEL configuration settings using this API, will be used in the next immediate usage of the instance.
+ * - Once the API is invoked, this level gets reset to the default protection level #OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL
+ *
+ *\pre
+ * - None
+ *
+ *\note
+ * - None
+ *
+ * \param[in,out]  me                     Valid instance of #optiga_util_t
+ * \param[in]      parameter_type         Parameter Type
+ *                                        Possible Types are
+ *                                        #OPTIGA_COMMS_PROTECTION_LEVEL
+ *                                        #OPTIGA_COMMS_PROTOCOL_VERSION
+ *
+ * \param[in]      value                  Value part for the respective configuration
+ *
+ * <b>Example</b><br>
+ *
+ */
+void optiga_util_set_comms_params(optiga_util_t * me,
+                                  uint8_t parameter_type,
+                                  uint8_t value);
+#endif
+/**
+ * \brief Create an instance of #optiga_util_t.
+ *
+ *\details
+ * Create an instance of #optiga_util_t.
+ * - Stores the callers context and callback handler.
+ * - Allocate memory for #optiga_util_t.
+ *
+ *\pre
+ * - None
+ *
+ *\note
+ * - This API is implemented in synchronous mode.
+ * - For <b>protected I2C communication</b>, 
+ *      - Default protection level for this API is #OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL.
+ *      - Default protocol version for this API is #OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET.
+ *
+ * \param[in]   optiga_instance_id    Indicates the OPTIGA instance to be associated with #optiga_util_t. Value should be defined as below
+ *                                    - #OPTIGA_INSTANCE_ID_0 : Indicate created instance will be part of OPTIGA with slave address 0x30.
+ * \param[in]   handler               Valid pointer to callback function
+ * \param[in]   caller_context        Pointer to upper layer context, contains user context data
+ *
+ * \retval      #optiga_util_t        On success function will return pointer of #optiga_util_t
+ * \retval      NULL                Input arguments are NULL.<br>
+ *                                  Low layer function fails.<br>
+ *                                  OPTIGA_CMD_MAX_REGISTRATIONS number of instances are already created.
+ *
+ * <b>Example</b><br>
+ * main_xmc4800_sample.c
+ */
+LIBRARY_EXPORTS optiga_util_t * optiga_util_create(uint8_t optiga_instance_id,
+                                                   callback_handler_t handler,
+                                                   void * caller_context);
+
+/**
+ * \brief De-Initializes the OPTIGA util instance.
+ *
+ *\details
+ * De-Initializes the #optiga_util_t instance.
+ * - De-allocate the memory of the #optiga_util_t instance.
+ *
+ *\pre
+ * - None
+ *
+ *\note
+ *  - User must take care to nullify the instance pointer.
+ *  - Invoke this API only after all the asynchronous process is completed otherwise the behavior of software stack is not defined.
+ *
+ * \param[in]  me                                    Valid instance of #optiga_util_t
+ *
+ * \retval     #OPTIGA_LIB_SUCCESS                   Successful invocation
+ * \retval     #OPTIGA_UTIL_ERROR_INVALID_INPUT      Wrong Input arguments provided
+ * \retval     #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE    The previous operation with the same instance is not complete
+ *
+ * <b>Example</b><br>
+ * main_xmc4800_sample.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_destroy(optiga_util_t * me);
+
+/**
+ * \brief Initializes the communication with optiga and open the application on OPTIGA.
+ *
+ *\details
+ * Initializes the communication with OPTIGA for the given instance.
+ * - Sets up optiga comms channel.<br>
+ * - Initiate open application command to optiga.<br>
+ * - Perform manage context , session restore operations and application restore.<br>
+ *
+ *\pre
+ * - For restoring OPTIGA application, the application must be in hibernate state using #optiga_util_close_application.
+ *
+ *\note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layer will be returned as it is.
+ * - If error in lower layer occurs while restoring OPTIGA application, then initialize a clean OPTIGA application context.
+ *
+ * \param[in]   me                                    Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]   perform_restore                       Restore application on OPTIGA from a previous hibernate state. The values must be as defined below
+ *                                                    - TRUE (1) - Performs application restore. <br>
+ *                                                    - FALSE (0) - Initialize a clean application context.
+ *
+ * \retval      #OPTIGA_UTIL_SUCCESS                  Successful invocation
+ * \retval      #OPTIGA_UTIL_ERROR_INVALID_INPUT      Wrong Input arguments provided
+ * \retval      #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE    The previous operation with the same instance is not complete
+ * \retval      #OPTIGA_DEVICE_ERROR                  Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                    (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * main_xmc4800_sample.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_open_application(optiga_util_t * me,
+                                                                 bool_t perform_restore);
+
+/**
+ *\brief Closes the application on OPTIGA and closes the communication with optiga.
+ *
+ *\details
+ * Closes the communication with OPTIGA for the given instance.
+ * - Initiate close application command to optiga.
+ * - Perform manage context secure session save operations.
+ * - De-Initializes the OPTIGA and closes the communication channel.
+ * - Power downs the OPTIGA after closing the application on optiga.
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ *
+ *\note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layer will be returned as it is.
+ * - Close application with hibernate and shielded connection establishment(negotiation/re-negotiation) will fail at OPTIGA because hibernation is not allowed when SEC value is greater than zero.
+ *   The SEC value increments internally on every shielded connection negotiation process.
+
+ *
+ *<br>
+ * \param[in]   me                                       Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]   perform_hibernate                        Hibernate the application on OPTIGA. The values must be as defined below.
+ *                                                        - TRUE (1) - Performs application hibernate. <br>
+ *                                                        - FALSE (0) - De-Initializes application context.
+ *
+ * \retval      #OPTIGA_UTIL_SUCCESS                     Successful invocation
+ * \retval      #OPTIGA_UTIL_ERROR_INVALID_INPUT         Input arguments are NULL
+ * \retval      #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE       The previous operation with the same instance is not complete
+ * \retval      #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                       (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * main_xmc4800_sample.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_close_application(optiga_util_t * me,
+                                                                  bool_t perform_hibernate);
+
+/**
+ * \brief Reads data from optiga.
+ *
+ *\details
+ * Retrieves the requested data that is stored in the user provided data object.<br>
+ * - Invokes #optiga_cmd_get_data_object API and based on the input arguments, read the data from the data object.
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ *
+ *\note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers will be returned as it is.
+ * - The maximum value of the <b>*length</b> parameter must be the size of buffer <b>buffer</b>. In case the value is greater than buffer size, memory corruption can occur.<br>
+ * - If any errors occur while retrieving the data, <b>*length</b> parameter is set to 0.
+ *
+ * \param[in]      me                                     Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]      optiga_oid                             OID of data object
+ *                                                        - It should be a valid data object, otherwise OPTIGA returns an error.<br>
+ * \param[in]      offset                                 Offset from within data object
+ *                                                        - It must be valid offset from within data object, otherwise OPTIGA returns an error.<br>
+ * \param[in,out]  buffer                                 Valid pointer to the buffer to which data is read
+ * \param[in,out]  length                                 Valid pointer to the length of data to be read from data object
+ *                                                        - When the data is successfully retrieved, it is updated with actual data length retrieved
+ *
+ * \retval         #OPTIGA_UTIL_SUCCESS                   Successful invocation
+ * \retval         #OPTIGA_UTIL_ERROR_INVALID_INPUT       Wrong Input arguments provided
+ * \retval         #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete
+ * \retval         #OPTIGA_DEVICE_ERROR                   Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                        (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_util_read_data.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_read_data(optiga_util_t * me,
+                                                          uint16_t optiga_oid,
+                                                          uint16_t offset,
+                                                          uint8_t * buffer,
+                                                          uint16_t * length);
+
+/**
+ * \brief Reads metadata of the specified data object from optiga.
+ *
+ *\details
+ * Reads the metadata of the user provided data object.
+ * - Invokes #optiga_cmd_get_data_object API, based on the input arguments to read the metadata from the data object.
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.
+ *
+ *\note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers will be returned as it is.
+ * - The metadata returned will be in TLV format.
+ * - The maximum value of the <b>*length</b> parameter  must be the size of <b>buffer</b>. In case the value is greater than buffer size, memory corruption can occur.<br>
+ * - If any errors occur while retrieving the data, <b>*length</b> parameter is set to 0.
+ *
+ * \param[in]      me                                       Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]      optiga_oid                               OID of data object
+ *                                                          - It should be a valid data object, otherwise OPTIGA returns an error.<br>
+ * \param[in,out]  buffer                                   Valid pointer to the buffer to which metadata is read
+ * \param[in,out]  length                                   Valid pointer to the length of metadata to be read from data object
+ *                                                          - When the metadata is successfully retrieved, it is updated with actual metadata length retrieved
+ *
+ * \retval         #OPTIGA_UTIL_SUCCESS                     Successful invocation
+ * \retval         #OPTIGA_UTIL_ERROR_INVALID_INPUT         Wrong Input arguments provided
+ * \retval         #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE       The previous operation with the same instance is not complete
+ * \retval         #OPTIGA_DEVICE_ERROR                     Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                          (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_util_read_data.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_read_metadata(optiga_util_t * me,
+                                                              uint16_t optiga_oid,
+                                                              uint8_t * buffer,
+                                                              uint16_t * length);
+
+/**
+ * \brief Writes data to optiga.
+ *
+ *\details
+ * Writes the data provided by the user into the specified data object.<br>
+ * - Invokes #optiga_cmd_set_data_object API, based on the input arguments to write the data to the data object.<br>
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.<br>
+ *
+ *\note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers will be returned as it is.<br>
+ * - The maximum value of the <b>length parameter</b> is size of <b>buffer</b>. In case the value is greater than buffer size, incorrect values can get written into the data object in OPTIGA.<br>
+ * - In case the write_type provided is other than <b>erase and write(0x00)</b> or <b>write only(0x40)</b>, the function returns #OPTIGA_UTIL_ERROR_INVALID_INPUT.<br>
+ *
+ * \param[in]      me                                        Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]      optiga_oid                                OID of data object
+ *                                                           - It should be a valid data object, otherwise OPTIGA returns an error.<br>
+ * \param[in]      write_type                                Type of write must be either #OPTIGA_UTIL_WRITE_ONLY or #OPTIGA_UTIL_ERASE_AND_WRITE.<br>
+ * \param[in]      offset                                    Offset from within data object
+ *                                                           - It must be valid offset from within data object, otherwise OPTIGA returns an error.<br>
+ * \param[in]      buffer                                    Valid pointer to the buffer with user data to write
+ * \param[in]      length                                    Length of data to be written
+ *
+ * \retval         #OPTIGA_UTIL_SUCCESS                      Successful invocation
+ * \retval         #OPTIGA_UTIL_ERROR_INVALID_INPUT          Wrong Input arguments provided
+ * \retval         #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE        The previous operation with the same instance is not complete
+ * \retval         #OPTIGA_DEVICE_ERROR                      Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                           (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_util_write_data.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_write_data(optiga_util_t * me,
+                                                           uint16_t optiga_oid,
+                                                           uint8_t write_type,
+                                                           uint16_t offset,
+                                                           const uint8_t * buffer,
+                                                           uint16_t length);
+
+/**
+ * \brief Writes metadata for the user provided data object.
+ *
+ *\details
+ * Writes metadata for the specified data object.
+ * - Invokes #optiga_cmd_set_data_object API, based on the input arguments to write metadata to the data object.
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.
+ *
+ *\note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers will be returned as it is.<br>
+ * - The maximum value of the <b>length</b> parameter is size of <b>buffer</b>.
+ *   In case the value is greater than buffer size, incorrect values can get written into the meta data of the data object in OPTIGA.<br>
+ * - The metadata to be written must be in TLV format.
+ *
+ * \param[in]      me                                     Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]      optiga_oid                             OID of data object
+ *                                                        - It should be a valid data object, otherwise OPTIGA returns an error.<br>
+ * \param[in]      buffer                                 Valid pointer to the buffer with metadata to write
+ * \param[in]      length                                 Length of metadata to be written
+ *
+ * \retval         #OPTIGA_UTIL_SUCCESS                   Successful invocation
+ * \retval         #OPTIGA_UTIL_ERROR_INVALID_INPUT       Wrong Input arguments provided
+ * \retval         #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete
+ * \retval         #OPTIGA_DEVICE_ERROR                   Command execution failure in OPTIGA and the LSB indicates the error code.
+ *
+ * <b>Example</b><br>
+ * example_optiga_util_write_data.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_write_metadata(optiga_util_t * me,
+                                                               uint16_t optiga_oid,
+                                                               const uint8_t * buffer,
+                                                               uint8_t length);
+
+/**
+ * \brief Initiates the start of protected update of object by writing manifest into OPTIGA object.
+ *
+ *\details
+ * Initiates the start of protected update of object.
+ * - It marks the beginning of a strict sequence. None of the service layer API will be processed until the strict sequence is terminated.
+ * - Invokes #optiga_cmd_set_object_protected API, based on the input arguments to send manifest to OPTIGA.
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.
+ *
+ *\note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL
+ *      - The protection level set in this API will be used for #optiga_util_protected_update_continue and #optiga_util_protected_update_final.<br>
+ * - Error codes from lower layers will be returned as it is.<br>
+ * - The strict sequence is terminated
+ *   - In case of an error from lower layer.<br>
+ *   - Same instance is used for other service layer APIs (except #optiga_util_protected_update_continue).<br>
+ *
+ * \param[in]      me                                     Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]      manifest_version                       Version of manifest to be written
+ * \param[in]      manifest                               Valid pointer to the buffer which contains manifest
+ *                                                        - It should be a valid manifest, otherwise OPTIGA returns an error.<br>
+ * \param[in]      manifest_length                        Length of manifest to be written
+ *
+ * \retval         #OPTIGA_UTIL_SUCCESS                   Successful invocation
+ * \retval         #OPTIGA_UTIL_ERROR_INVALID_INPUT       Wrong Input arguments provided
+ * \retval         #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete
+ * \retval         #OPTIGA_DEVICE_ERROR                   Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                        (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_util_protected_update.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_protected_update_start(optiga_util_t * me,
+                                                                       uint8_t manifest_version,
+                                                                       const uint8_t * manifest,
+                                                                       uint16_t manifest_length);
+
+/**
+ * \brief Sends fragment(s) of data to be written to OPTIGA.
+ *
+ *\details
+ * Sends a fragment of data to be written to OPTIGA.
+ * - Invokes #optiga_cmd_set_object_protected API, to send the fragment of data to write to OPTIGA.
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.
+ * - The manifest must be written to OPTIGA using #optiga_util_protected_update_start, otherwise lower layer returns an error.
+ *\note
+ * - The <b>protected I2C communication</b> value set in #optiga_util_protected_update_start will be used in this API.<br>
+ * - Error codes from lower layers will be returned as it is.<br>
+ * - For writing 'n' fragment (s) ,
+ *   - if n > 1 : Send 1 to 'n - 1' fragments using #optiga_util_protected_update_continue and and the final fragment using #optiga_util_protected_update_final.<br>
+ *   - if n == 1 : Send the fragment using #optiga_util_protected_update_final.<br>
+ * - Chaining of fragments and the sequence of sending fragments must be handled externally to this API.<br>
+ * - The strict sequence is terminated in case of an error from lower layer<br>
+ *
+ * \param[in]      me                                     Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]      fragment                               Valid pointer to the buffer which contains fragment
+ *                                                        - It must be a valid fragment, otherwise OPTIGA returns an error.<br>
+ * \param[in]      fragment_length                        Length of fragment to be written
+ *
+ * \retval         #OPTIGA_UTIL_SUCCESS                   Successful invocation
+ * \retval         #OPTIGA_UTIL_ERROR_INVALID_INPUT       Wrong Input arguments provided
+ * \retval         #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete
+ * \retval         #OPTIGA_DEVICE_ERROR                   Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                        (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_util_protected_update.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_protected_update_continue(optiga_util_t * me,
+                                                                          const uint8_t * fragment,
+                                                                          uint16_t fragment_length);
+
+/**
+ * \brief Sends the last fragment to finalize the protected update of data object.
+ *
+ *\details
+ * Sends the last fragment to finalize the protected update of data object.
+ * - Invokes #optiga_cmd_set_object_protected API, based on the input arguments to write the final fragment to data object.
+ * - It terminates the strict sequence.
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application.
+ * - The manifest must be written to OPTIGA using #optiga_util_protected_update_start, otherwise lower layer returns an error.
+ *
+ *\note
+ * - The <b>protected I2C communication</b> value set in #optiga_util_protected_update_start will be used in this API.<br>
+ * - Error codes from lower layers will be returned as it is.<br>
+ * - The strict sequence is terminated in case of an error from lower layer.<br>
+ *
+ * \param[in]      me                                     Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]      fragment                               Valid pointer to the buffer which contains the last fragment.
+ *                                                        - If NULL, only strict sequence is released and no APDU is sent to OPTIGA
+ * \param[in]      fragment_length                        Length of fragment to be written
+ *
+ * \retval         #OPTIGA_UTIL_SUCCESS                   Successful invocation
+ * \retval         #OPTIGA_UTIL_ERROR_INVALID_INPUT       Wrong Input arguments provided
+ * \retval         #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE     The previous operation with the same instance is not complete
+ * \retval         #OPTIGA_DEVICE_ERROR                   Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                        (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_util_protected_update.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_protected_update_final(optiga_util_t * me,
+                                                                       const uint8_t * fragment,
+                                                                       uint16_t fragment_length);
+
+/**
+ * \brief Increments the counter object by a value specified by user.
+ *
+ *\details
+ * Increments the counter object by a value specified by user.<br>
+ * - Invokes #optiga_cmd_set_data_object API, based on the input arguments to update the count to the specified data object.<br>
+ *
+ *\pre
+ * - The application on OPTIGA must be opened using #optiga_util_open_application before using this API.<br>
+ * - Initial count and threshold value must be set using #optiga_util_write_data.<br>
+ *
+ *\note
+ * - For <b>protected I2C communication</b>, Refer #OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL
+ * - Error codes from lower layers will be returned as it is.<br>
+ *
+ * \param[in]      me                                        Valid instance of #optiga_util_t created using #optiga_util_create.
+ * \param[in]      optiga_counter_oid                        OID of counter data object
+ *                                                           - It should be a valid data object, otherwise OPTIGA returns an error.<br>
+ * \param[in]      count                                     Counter value to be updated
+ *
+ * \retval         #OPTIGA_UTIL_SUCCESS                      Successful invocation
+ * \retval         #OPTIGA_UTIL_ERROR_INVALID_INPUT          Wrong Input arguments provided
+ * \retval         #OPTIGA_UTIL_ERROR_INSTANCE_IN_USE        The previous operation with the same instance is not complete
+ * \retval         #OPTIGA_DEVICE_ERROR                      Command execution failure in OPTIGA and the LSB indicates the error code.
+ *                                                           (Refer Solution Reference Manual)
+ *
+ * <b>Example</b><br>
+ * example_optiga_util_update_count.c
+ */
+LIBRARY_EXPORTS optiga_lib_status_t optiga_util_update_count(optiga_util_t * me,
+                                                             uint16_t optiga_counter_oid,
+                                                             uint8_t count);
+
+/**
+ * \brief Enables the protected I2C communication with OPTIGA for UTIL instances
+ *
+ * \details
+ * Enables the protected I2C communication with OPTIGA
+ * - Sets the protection mode for the supplied instance.<br>
+ * - Call this function before calling the service layer API which requires protection.
+ *
+ * \pre
+ * - #OPTIGA_COMMS_SHIELDED_CONNECTION macro must be defined.<br>
+ * - #OPTIGA_UTIL_SET_COMMS_PROTOCOL_VERSION function must be called once to set the required protocol version
+ *   - Currently only Pre-shared Secret based version is supported.
+ * - The host and OPTIGA must be paired and Pre-Shared secret is available.<br>
+ *
+ * \note
+ * - The protection mode for the instance is reset to #OPTIGA_COMMS_NO_PROTECTION once the service layer API returns synchronously.
+ *
+ * \param[in]      p_instance           Valid pointer to an instance
+ * \param[in]      protection_level     Required protection mode
+ *                                      - #OPTIGA_COMMS_NO_PROTECTION : Command and response is unprotected
+ *                                      - #OPTIGA_COMMS_COMMAND_PROTECTION : Command is protected and response is unprotected
+ *                                      - #OPTIGA_COMMS_RESPONSE_PROTECTION : Command is unprotected and response is protected
+ *                                      - #OPTIGA_COMMS_FULL_PROTECTION : Both command and response is protected
+ *                                      - To re-establish secure channel, bitwise-OR protection_level with #OPTIGA_COMMS_RE_ESTABLISH
+ */
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+#define OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL(p_instance, protection_level) \
+{ \
+    optiga_util_set_comms_params(p_instance, \
+                                 OPTIGA_COMMS_PROTECTION_LEVEL, \
+                                 protection_level); \
+}
+#else
+#define OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL(p_instance, protection_level) {}
+#endif
+/**
+ * \brief Select the protocol version required for the I2C protected communication for UTIL instances
+ *
+ * \details
+ * Select the protocol version required for the I2C protected communication
+ * - Select the protocol version for the supplied instance.<br>
+ *
+ * \pre
+ * - #OPTIGA_COMMS_SHIELDED_CONNECTION macro must be defined.<br>
+ *
+ * \note
+ * - None
+ *
+ * \param[in]      p_instance    Valid pointer to an instance
+ * \param[in]      version       Required protocol version
+ *                               - #OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET : Pre-shared Secret based protocol version
+ */
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+#define OPTIGA_UTIL_SET_COMMS_PROTOCOL_VERSION(p_instance, version) \
+{ \
+    optiga_util_set_comms_params(p_instance, \
+                                 OPTIGA_COMMS_PROTOCOL_VERSION, \
+                                 version);\
+}
+#else
+#define OPTIGA_UTIL_SET_COMMS_PROTOCOL_VERSION(p_instance, version) {}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_OPTIGA_UTIL_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal.h
new file mode 100644
index 000000000..3666e8a61
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal.h
@@ -0,0 +1,106 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal.h
+*
+* \brief   This file provides the prototype declarations of platform abstraction layer
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#ifndef _PAL_H_
+#define _PAL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/common/optiga_lib_types.h"
+#include "ulog/ulog.h"
+
+/// PAL API execution is successful
+#define PAL_STATUS_SUCCESS          (0x0000)
+/// PAL API execution failed
+#define PAL_STATUS_FAILURE          (0x0001)
+/// PAL I2C is busy
+#define PAL_STATUS_I2C_BUSY         (0x0002)
+/// PAL API execution with wrong input arguments provided 
+#define PAL_STATUS_INVALID_INPUT    (0x0004)
+
+
+/**
+ * @brief PAL return status.
+ */
+typedef uint16_t pal_status_t;
+
+/**
+ * \brief Initializes the PAL layer
+ *
+ * \details
+ * Initializes the PAL layer
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \retval  #PAL_STATUS_SUCCESS  Returns when the PAL init it successful
+ * \retval  #PAL_STATUS_FAILURE  Returns when the PAL init fails.
+ */
+LIBRARY_EXPORTS pal_status_t pal_init(void);
+
+/**
+ * \brief De-Initializes the PAL layer
+ *
+ * \details
+ * De-Initializes the PAL layer
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \retval  #PAL_STATUS_SUCCESS  Returns when the PAL de-init it successful
+ * \retval  #PAL_STATUS_FAILURE  Returns when the PAL de-init fails.
+ */
+LIBRARY_EXPORTS pal_status_t pal_deinit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PAL_H_ */
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_crypt.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_crypt.h
new file mode 100644
index 000000000..5685918a0
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_crypt.h
@@ -0,0 +1,217 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_crypt.h
+*
+* \brief   This file provides the prototype declarations of PAL crypt.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+
+#ifndef _PAL_CRYPT_H_
+#define _PAL_CRYPT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/common/optiga_lib_types.h"
+#include "optiga/pal/pal.h"
+
+/** \brief PAL crypt context structure */
+typedef struct pal_crypt_t
+{
+    /// callback
+    void * callback_ctx;
+}pal_crypt_t;
+
+/**
+ * \brief Derives the key using the TLS PRF SHA256 for a given secret.
+ *
+ * \details
+ * Derives the key using the TLS PRF SHA256 for a given secret.
+ * - Derives a key using the user provided secret.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in]           p_pal_crypt             Crypt context
+ * \param[in]           p_secret                Valid pointer to input shared secret.
+ * \param[in]           secret_length           Length of the shared secret.
+ * \param[in]           p_label                 Valid pointer to Label for PRF calculation.
+ * \param[in]           label_length            Label length.
+ * \param[in]           p_seed                  Valid pointer to the buffer which contains seed.
+ * \param[in]           seed_length             seed length.
+ * \param[in,out]       p_derived_key           Valid pointer to the buffer where PRF output to be saved.
+ * \param[in]           derived_key_length      Length of the key to be derived from secret.
+ *
+ * \retval              PAL_STATUS_SUCCESS      In case of success
+ * \retval              PAL_STATUS_FAILURE      In case of failure
+ */
+LIBRARY_EXPORTS pal_status_t pal_crypt_tls_prf_sha256(pal_crypt_t* p_pal_crypt,
+                                                      const uint8_t * p_secret,
+                                                      uint16_t secret_length,
+                                                      const uint8_t * p_label,
+                                                      uint16_t label_length,
+                                                      const uint8_t * p_seed,
+                                                      uint16_t seed_length,
+                                                      uint8_t * p_derived_key,
+                                                      uint16_t derived_key_length);
+
+/**
+ * \brief Encrypts the input plain text using AES CCM algorithm and provides the cipher text as well as MAC into output buffer.
+ *
+ * \details
+ * Encrypts the input plain text using AES CCM algorithm and provides the cipher text as well as MAC into output buffer.
+ * - Encrypts the given plain text using the provided encryption key, nonce and associated data.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - If <b>mac_size</b> is set to 8 AES128_CCM_8 algorithm will be used for encryption.
+ * - If <b>mac_size</b> is set to 16 AES128_CCM algorithm will be used for encryption.
+ *
+ * \param[in]           p_pal_crypt                 Crypt context                                                      
+ * \param[in]           p_plain_text                Valid pointer to plain text data.
+ * \param[in]           plain_text_length           Plain text data size.
+ * \param[in]           p_encrypt_key               Valid pointer to Encrypt key .
+ * \param[in]           p_nonce                     Valid pointer to Nonce data.
+ * \param[in]           nonce_length                Nonce data size.
+ * \param[in]           p_associated_data           Valid pointer to Associated data.
+ * \param[in]           associated_data_length      Associated data size.
+ * \param[in]           mac_size                    Length of expected MAC data.
+ * \param[in,out]       p_cipher_text               Valid pointer to store cipher text and MAC output. Buffer length must be at-least <b>plain_text_length</b> + <b>MAC mac_size</b>.
+ *
+ * \retval              PAL_STATUS_SUCCESS          In case of success
+ * \retval              PAL_STATUS_FAILURE          In case of failure
+ */
+LIBRARY_EXPORTS pal_status_t pal_crypt_encrypt_aes128_ccm(pal_crypt_t* p_pal_crypt,
+                                                          const uint8_t * p_plain_text,
+                                                          uint16_t plain_text_length,
+                                                          const uint8_t * p_encrypt_key,
+                                                          const uint8_t * p_nonce,
+                                                          uint16_t nonce_length,
+                                                          const uint8_t * p_associated_data,
+                                                          uint16_t associated_data_length,
+                                                          uint8_t mac_size,
+                                                          uint8_t * p_cipher_text);
+
+/**
+ * \brief Decrypts the cipher text using AES CCM algorithm and provides the plain text.
+ *
+ * \details
+ * Decrypts the cipher text using AES CCM algorithm and provides the plain text.
+ * - Decrypts the cipher text using the provided decryption key, nonce and associated data
+ * - This operation validates the MAC internally and provided the plain text if the MAC is successfully validated.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - If <b>mac_size</b> is set to 8 AES128_CCM_8 algorithm will be used for decryption.
+ * - If <b>mac_size</b> is set to 16 AES128_CCM algorithm will be used for decryption.
+ *
+ * \param[in]           p_pal_crypt                 Crypt context
+ * \param[in]           p_cipher_text               Valid pointer to the Cipher text + MAC data.
+ * \param[in]           cipher_text_length          Cipher text data size.
+ * \param[in]           p_decrypt_key               Valid pointer to decrypt key.
+ * \param[in]           p_nonce                     Valid pointer to Nonce data.
+ * \param[in]           nonce_length                Nonce size.
+ * \param[in]           p_associated_data           Valid pointer to Associated data.
+ * \param[in]           associated_data_length      Associated data size.
+ * \param[in]           mac_size                    Length of MAC data.
+ * \param[in,out]       p_plain_text                Valid pointer to store plain text. Buffer length must be at-least <b>Cipher_text_length</b> - <b>mac_size</b>.
+ *
+ * \retval              PAL_STATUS_SUCCESS          In case of success
+ * \retval              PAL_STATUS_FAILURE          In case of failure
+ */
+LIBRARY_EXPORTS pal_status_t pal_crypt_decrypt_aes128_ccm(pal_crypt_t* p_pal_crypt,
+                                                          const uint8_t * p_cipher_text,
+                                                          uint16_t cipher_text_length,
+                                                          const uint8_t * p_decrypt_key,
+                                                          const uint8_t * p_nonce,
+                                                          uint16_t nonce_length,
+                                                          const uint8_t * p_associated_data,
+                                                          uint16_t associated_data_length,
+                                                          uint8_t mac_size,
+                                                          uint8_t * p_plain_text);
+
+/**
+ * \brief Gets the external crypto library version number.
+ *
+ * \details
+ * Gets the external crypto library version number. <br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - Format of version information : vX.Y.Z
+ * - mbedTLS Version: vX.Y.Z
+ *
+ * \param[inout]     p_crypt_lib_version_info               Valid pointer to store the version number.
+ * \param[inout]     length                                 version number size.
+ *
+ * \retval           PAL_STATUS_SUCCESS                     In case of success
+ * \retval           PAL_STATUS_FAILURE                     In case of failure
+ */
+pal_status_t pal_crypt_version(uint8_t * p_crypt_lib_version_info, uint16_t * length);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_PAL_CRYPT_H_ */
+
+/**
+* @}
+*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_gpio.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_gpio.h
new file mode 100644
index 000000000..73e365844
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_gpio.h
@@ -0,0 +1,146 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_gpio.h
+*
+* \brief   This file provides the prototype declarations of PAL GPIO.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#ifndef _PAL_GPIO_H_
+#define _PAL_GPIO_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pal.h"
+
+
+/**
+ * \brief Structure defines the PAL GPIO configuration.
+ */
+typedef struct pal_gpio
+{
+    /// Pointer to GPIO platform specific context/structure
+    void * p_gpio_hw;
+
+} pal_gpio_t;
+
+/**
+ * \brief Function to transmit and receive a packet.
+ *
+ * \details
+ * Function to transmit and receive a packet.
+ * - The API sets the pin high, only if the pin is assigned to a valid GPIO context<br>
+ *   Otherwise the API returns without any failure status
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ *\param[in] p_gpio_context      Valid pointer to PAL layer GPIO context
+ *
+ *
+ */
+LIBRARY_EXPORTS void pal_gpio_set_high(const pal_gpio_t * p_gpio_context);
+
+/**
+ * \brief Sets the GPIO pin to Low state.
+ *
+ * \details
+ * Sets the GPIO pin to Low state.
+ * - The API set the pin low, only if the pin is assigned to a valid GPIO context.<br>
+ *   Otherwise the API returns without any failure status.<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ *\param[in] p_gpio_context      Valid pointer to PAL layer GPIO context
+ *
+ */
+LIBRARY_EXPORTS void pal_gpio_set_low(const pal_gpio_t * p_gpio_context);
+
+/**
+ * \brief Function to initialize GPIO.
+ *
+ * \details
+ * Function to initialize GPIO.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_gpio_context                         Valid pointer to PAL layer GPIO context
+ *
+ * \retval    #PAL_STATUS_SUCCESS                    On successful execution
+ * \retval    #PAL_STATUS_FAILURE                    On failure
+ *
+ */
+LIBRARY_EXPORTS pal_status_t pal_gpio_init(const pal_gpio_t * p_gpio_context);
+
+/**
+ * \brief Function to de-initialize GPIO.
+ *
+ * \details
+ * Function to de-initialize GPIO.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_gpio_context                         Valid pointer to PAL layer GPIO context
+ *
+ * \retval    #PAL_STATUS_SUCCESS                    On successful execution
+ * \retval    #PAL_STATUS_FAILURE                    On failure
+ */
+LIBRARY_EXPORTS pal_status_t pal_gpio_deinit(const pal_gpio_t * p_gpio_context);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PAL_GPIO_H_ */
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_i2c.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_i2c.h
new file mode 100644
index 000000000..d8b571076
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_i2c.h
@@ -0,0 +1,244 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_i2c.h
+*
+* \brief   This file provides the prototype declarations of PAL I2C.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+
+#ifndef _PAL_I2C_H_
+#define _PAL_I2C_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pal.h"
+
+/// Event returned when I2C master completes execution
+#define PAL_I2C_EVENT_SUCCESS (0x0000)
+/// Event returned when I2C master operation fails
+#define PAL_I2C_EVENT_ERROR   (0x0001)
+/// Event returned when lower level I2C bus is busy
+#define PAL_I2C_EVENT_BUSY    (0x0002)
+
+/** @brief PAL I2C context structure */
+typedef struct pal_i2c
+{
+    /// Pointer to I2C master platform specific context
+    void * p_i2c_hw_config;
+    /// I2C slave address
+    uint8_t slave_address;
+    /// Pointer to store the callers context information
+    void * p_upper_layer_ctx;
+    /// Pointer to store the callers handler
+    void * upper_layer_event_handler;
+
+} pal_i2c_t;
+
+/**
+ * @brief Initializes the I2C master.
+ *
+ * Initializes the I2C master with the given context.
+ * <br>
+ *
+ * \details
+ * - The platform specific initialization of I2C master has to be implemented as part of this API, if required.<br>
+ * - If the target platform does not demand explicit initialization of i2c master
+ *   (Example: If the platform driver takes care of init after the reset), it would not be required to implement.<br>
+ * - The implementation must take care the following scenarios depending upon the target platform selected.
+ *   - The implementation must handle the acquiring and releasing of the I2C bus before initializing the I2C master to
+ *     avoid interrupting the ongoing slave I2C transactions using the same I2C master.
+ *   - If the I2C bus is in busy state, the API must not initialize and return #PAL_STATUS_I2C_BUSY status.
+ *   - Repeated initialization must be taken care with respect to the platform requirements. (Example: Multiple users/applications
+ *     sharing the same I2C master resource)
+ * 
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_i2c_context      Valid pointer to the PAL I2C context that should be initialized
+ *
+ * \retval  #PAL_STATUS_SUCCESS  Returns when the I2C master init it successful
+ * \retval  #PAL_STATUS_FAILURE  Returns when the I2C init fails.
+ */
+LIBRARY_EXPORTS pal_status_t pal_i2c_init(const pal_i2c_t * p_i2c_context);
+
+/**
+ * @brief Sets the I2C Master bitrate
+ *
+ * Sets the bitrate/speed(KHz) of I2C master.
+ * <br>
+ *
+ * \details
+ * - Sets the bitrate of I2C master if the I2C bus is free, else it returns busy status #PAL_STATUS_I2C_BUSY<br>
+ * - The bus is released after the setting the bitrate.<br>
+ * - This API must take care of setting the bitrate to I2C master's maximum supported value.
+ * - Eg. In XMC4800, the maximum supported bitrate is 400 KHz. If the supplied bitrate is greater than 400KHz, the API will
+ *   set the I2C master's bitrate to 400KHz.
+ * - If upper_layer_event_handler is initialized, the upper layer handler is invoked with the respective event
+ *   status listed below.
+ *   - #PAL_I2C_EVENT_BUSY when I2C bus in busy state
+ *   - #PAL_I2C_EVENT_ERROR when API fails to set the bit rate
+ *   - #PAL_I2C_EVENT_SUCCESS when operation is successful
+ *<br>
+ *
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_i2c_context  Valid pointer to the PAL I2C context
+ * \param[in] bitrate        Bitrate to be used by I2C master in KHz
+ *
+ * \retval  #PAL_STATUS_SUCCESS  Returns when the setting of bitrate is successfully completed
+ * \retval  #PAL_STATUS_FAILURE  Returns when the setting of bitrate fails.
+ * \retval  #PAL_STATUS_I2C_BUSY Returns when the I2C bus is busy.
+ */
+LIBRARY_EXPORTS pal_status_t pal_i2c_set_bitrate(const pal_i2c_t * p_i2c_context, uint16_t bitrate);
+
+/**
+ * @brief Writes on I2C bus.
+ *
+ * Writes the data to I2C slave.
+ * <br>
+ * <br>
+ * \image html pal_i2c_write.png "pal_i2c_write()" width=20cm
+ *
+ *
+ * \details
+ * - The API attempts to write if the I2C bus is free, else it returns busy status #PAL_STATUS_I2C_BUSY<br>
+ * - The bus is released only after the completion of transmission or after completion of error handling.<br>
+ * - The API invokes the upper layer handler with the respective event status as explained below.
+ *   - #PAL_I2C_EVENT_BUSY when I2C bus in busy state
+ *   - #PAL_I2C_EVENT_ERROR when API fails
+ *   - #PAL_I2C_EVENT_SUCCESS when operation is successfully completed asynchronously
+ *<br>
+ *
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ *  - Otherwise the below implementation has to be updated to handle different bitrates based on the input context.<br>
+ *  - The caller of this API must take care of the guard time based on the slave's requirement.<br>
+ *  - The upper_layer_event_handler must be initialized in the p_i2c_context before invoking the API.<br>
+ *
+ * \param[in] p_i2c_context  Valid pointer to the PAL I2C context #pal_i2c_t
+ * \param[in] p_data         Pointer to the data to be written
+ * \param[in] length         Length of the data to be written
+ *
+ * \retval  #PAL_STATUS_SUCCESS  Returns when the I2C write is invoked successfully
+ * \retval  #PAL_STATUS_FAILURE  Returns when the I2C write fails.
+ * \retval  #PAL_STATUS_I2C_BUSY Returns when the I2C bus is busy.
+ */
+LIBRARY_EXPORTS pal_status_t pal_i2c_write(const pal_i2c_t * p_i2c_context, uint8_t * p_data, uint16_t length);
+
+/**
+ * @brief Reads from I2C bus.
+ *
+ * Reads the data from I2C slave.
+ * <br>
+ * <br>
+ * \image html pal_i2c_read.png "pal_i2c_read()" width=20cm
+ *
+ * \details
+ * - The API attempts to read if the I2C bus is free, else it returns busy status #PAL_STATUS_I2C_BUSY<br>
+ * - The bus is released only after the completion of reception or after completion of error handling.<br>
+ * - The API invokes the upper layer handler with the respective event status as explained below.
+ *   - #PAL_I2C_EVENT_BUSY when I2C bus in busy state
+ *   - #PAL_I2C_EVENT_ERROR when API fails
+ *   - #PAL_I2C_EVENT_SUCCESS when operation is successfully completed asynchronously
+ *<br>
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ *  - Otherwise the below implementation has to be updated to handle different bitrates based on the input context.<br>
+ *  - The caller of this API must take care of the guard time based on the slave's requirement.<br>
+ *
+ * \param[in]  p_i2c_context  pointer to the PAL I2C context #pal_i2c_t
+ * \param[in]  p_data         Pointer to the data buffer to store the read data
+ * \param[in]  length         Length of the data to be read
+ *
+ * \retval  #PAL_STATUS_SUCCESS  Returns when the I2C read is invoked successfully
+ * \retval  #PAL_STATUS_FAILURE  Returns when the I2C read fails.
+ * \retval  #PAL_STATUS_I2C_BUSY Returns when the I2C bus is busy.
+ */
+LIBRARY_EXPORTS pal_status_t pal_i2c_read(const pal_i2c_t * p_i2c_context, uint8_t * p_data, uint16_t length);
+
+/**
+ * @brief De-initializes the I2C master.
+ *
+ * De-initializes the I2C master with the specified context.
+ * <br>
+ *
+ * \details
+ * - The platform specific de-initialization of I2C master has to be implemented as part of this API, if required.<br>
+ * - If the target platform does not demand explicit de-initialization of i2c master
+ *   (Example: If the platform driver takes care of init after the reset), it would not be required to implement.<br>
+ * - The implementation must take care the following scenarios depending upon the target platform selected.
+ *   - The implementation must handle the acquiring and releasing of the I2C bus before de-initializing the I2C master to
+ *     avoid interrupting the ongoing slave I2C transactions using the same I2C master.
+ *   - If the I2C bus is in busy state, the API must not de-initialize and return #PAL_STATUS_I2C_BUSY status.
+ *     - This API must ensure that multiple users/applications sharing the same I2C master resource is not impacted.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_i2c_context   Valid pointer to the PAL I2C context that should be de-initialized
+ *
+ * \retval  #PAL_STATUS_SUCCESS  Returns when the I2C master de-init it successful
+ * \retval  #PAL_STATUS_FAILURE  Returns when the I2C de-init fails.
+ */
+LIBRARY_EXPORTS pal_status_t pal_i2c_deinit(const pal_i2c_t * p_i2c_context);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PAL_I2C_H_ */
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_ifx_i2c_config.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_ifx_i2c_config.h
new file mode 100644
index 000000000..01519e312
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_ifx_i2c_config.h
@@ -0,0 +1,62 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_ifx_i2c_config.h
+*
+* \brief   This file provides the platform abstraction layer extern declarations for IFX I2C.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#ifndef _PAL_IFX_I2C_CONFIG_H_
+#define _PAL_IFX_I2C_CONFIG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pal.h"
+#include "pal_i2c.h"
+#include "pal_gpio.h"
+#include "pal_os_datastore.h"
+
+extern pal_i2c_t optiga_pal_i2c_context_0;
+extern pal_gpio_t optiga_vdd_0;
+extern pal_gpio_t optiga_reset_0;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PAL_IFX_I2C_CONFIG_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_logger.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_logger.h
new file mode 100644
index 000000000..9e11d6013
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_logger.h
@@ -0,0 +1,155 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file    pal_logger.h
+*
+* \brief   This file provides the prototypes declarations for pal logger.
+*
+* \ingroup grPAL
+*
+* @{
+*/
+
+
+#ifndef _PAL_LOGGER_H_
+#define _PAL_LOGGER_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "optiga/pal/pal.h"
+
+/** \brief PAL logger context structure */
+typedef struct pal_logger
+{
+  /// Pointer to logger hardware
+  void * logger_config_ptr;
+  /// Receive complete flag
+  volatile uint8_t logger_rx_flag;
+  /// Transmit complete flag
+  volatile uint8_t logger_tx_flag;
+
+} pal_logger_t;
+
+/**
+ * \brief Initializes the logger port.
+ *
+ * \details
+ * Initializes the logger port.
+ * - Creates and initializes structure low level logging.<br>
+ *
+ * \pre
+ * - None.
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_logger_context    Valid pointer to the PAL logger context that should be initialized
+ *
+ * \retval    PAL_STATUS_SUCCESS  In case of successfully written to logger
+ * \retval    PAL_STATUS_FAILURE  In case of failure while writing to logger
+ *
+ */
+pal_status_t pal_logger_init(void * p_logger_context);
+
+/**
+ * \brief De-Initializes the logger port.
+ *
+ * \details
+ * De-Initializes the logger port.
+ * - Clears the structure low level logging.<br>
+ *
+ * \pre
+ * - None.
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_logger_context    Valid pointer to the PAL logger context that should be initialized
+ *
+ * \retval    PAL_STATUS_SUCCESS  In case of successfully written to logger
+ * \retval    PAL_STATUS_FAILURE  In case of failure while writing to logger
+ *
+ */
+pal_status_t pal_logger_deinit(void * p_logger_context);
+
+/**
+ * \brief Writes to logger port.
+ *
+ * \details
+ * Writes to logger port.
+ * - Invokes the platform dependent function to log the information provided.<br>
+ *
+ * \pre
+ * - The pal_logger is initialized if required.
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_logger_context    Valid pointer to the PAL logger context that should be initialized
+ * \param[in] p_log_data          Pointer to the log data (data to be logged)
+ * \param[in] log_data_length     Length of data to be logged.
+ *
+ * \retval    PAL_STATUS_SUCCESS  In case of successfully written to logger
+ * \retval    PAL_STATUS_FAILURE  In case of failure while writing to logger
+ *
+ */
+pal_status_t pal_logger_write(void * p_logger_context, const uint8_t * p_log_data, uint32_t log_data_length);
+
+/**
+ * \brief Read to logger port.
+ *
+ * \details
+ * Reads to logger port.
+ * - Invokes the platform dependent function to log the information provided.<br>
+ *
+ * \pre
+ * - The pal_logger is initialized if required.
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_logger_context    Valid pointer to the PAL logger context that should be initialized
+ * \param[in] p_log_data          Pointer to the log data (data to be logged)
+ * \param[in] log_data_length     Length of data to be logged.
+ *
+ * \retval    PAL_STATUS_SUCCESS  In case of successfully read to logger
+ * \retval    PAL_STATUS_FAILURE  In case of failure while read to logger
+ *
+ */
+pal_status_t pal_logger_read(void * p_logger_context, uint8_t * p_log_data, uint32_t log_data_length);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_PAL_LOGGER_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_datastore.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_datastore.h
new file mode 100644
index 000000000..5fc9fa32f
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_datastore.h
@@ -0,0 +1,130 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_datastore.h
+*
+* \brief   This file provides API prototypes of platform abstraction layer for datastore operations.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+
+#ifndef _PAL_OS_DATASTORE_H_
+#define _PAL_OS_DATASTORE_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/pal/pal.h"
+
+/// Identifier to store and read OPTIGA Platform Binding Shared secret on host platform
+#define OPTIGA_PLATFORM_BINDING_SHARED_SECRET_ID        (0x11)
+
+/// Maximum shared secret length this value is bind with OPTIGA_PLATFORM_BINDING_SHARED_SECRET_ID
+#define OPTIGA_SHARED_SECRET_MAX_LENGTH                 (0x40)
+
+// Persistant data store is not configured
+#define OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED        (0x00)
+
+// !!!OPTIGA_LIB_PORTING_REQUIRED
+// Identifier to store and read OPTIGA Shielded connection manage context on host platform,
+// If the manage context data is to be stored in volatile memory only, 
+// set OPTIGA_COMMS_MANAGE_CONTEXT_ID to OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED.
+#define OPTIGA_COMMS_MANAGE_CONTEXT_ID                  (0x22)
+
+// !!!OPTIGA_LIB_PORTING_REQUIRED
+// Identifier to store and read OPTIGA application context handle on host platform, 
+// If the application context data is to be stored in volatile memory only, 
+// set OPTIGA_COMMS_MANAGE_CONTEXT_ID to OPTIGA_LIB_PAL_DATA_STORE_NOT_CONFIGURED.
+#define OPTIGA_HIBERNATE_CONTEXT_ID                     (0x33)
+
+/// @cond hidden
+/// Size of application context handle buffer
+#define APP_CONTEXT_SIZE        (0x08)
+/// @endcond
+/**
+ * \brief Reads data from the specified location for a given datastore_id.
+ *
+ * \details
+ * Reads data from the specified location for a given datastore_id.
+ *  - Reads data from any configured specific location.
+ *  - Once the timer expires, the registered callback function gets called from the timer event handler, if the call back is not NULL.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in]     datastore_id          Datastore id from where the data should be read.
+ * \param[out]    p_buffer              Valid Pointer to output buffer
+ * \param[in,out] p_buffer_length       Valid Pointer to the data buffer length to store the read data length. The input value gets updated with the actual length read from the data store.
+ *
+ * \retval        #PAL_STATUS_SUCCESS   On successful execution
+ * \retval        #PAL_STATUS_FAILURE   On failure
+ */
+pal_status_t pal_os_datastore_read(uint16_t datastore_id,
+                                   uint8_t * p_buffer,
+                                   uint16_t * p_buffer_length);
+
+/**
+ * \brief Writes data to the specified location for a given datastore_id
+ *
+ * \details
+ * Writes data to the specified location for a given datastore_id.
+ * - Writes data to any configured specific location.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] datastore_id          Datastore id where the data should be written.
+ * \param[in] p_buffer              Valid pointer to the input buffer
+ * \param[in] length                Length of the data to be written
+ *
+ * \retval    #PAL_STATUS_SUCCESS   On successful execution
+ * \retval    #PAL_STATUS_FAILURE   On failure
+ */
+pal_status_t pal_os_datastore_write(uint16_t datastore_id,
+                                    const uint8_t * p_buffer,
+                                    uint16_t length);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PAL_OS_DATASTORE_H_ */
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_event.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_event.h
new file mode 100644
index 000000000..dc89595aa
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_event.h
@@ -0,0 +1,191 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_event.h
+*
+* \brief   This file provides the prototype declarations of PAL OS event
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#ifndef _PAL_OS_EVENT_H_
+#define _PAL_OS_EVENT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "optiga/common/optiga_lib_types.h"
+
+/**
+ * \brief typedef for Callback function when timer elapses.
+ */
+typedef void ( * register_callback)(void * );
+
+/** \brief PAL os event structure */
+typedef struct pal_os_event
+{
+    /// event triggered status
+    bool_t is_event_triggered;
+    /// registered callback
+    register_callback callback_registered;
+    /// context to be passed to callback
+    void * callback_ctx;
+    /// os timer
+    void * os_timer;
+}pal_os_event_t;
+
+
+/**
+ * \brief Create an os event.
+ *
+ * \details
+ * Starts an OS event.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] callback                      Callback function to be registered internally
+ * \param[in] callback_args                 Arguement to be passed to registered callback
+ *
+ */
+LIBRARY_EXPORTS pal_os_event_t * pal_os_event_create(register_callback callback,
+                                                     void * callback_args);
+
+/**
+ * \brief Destroys an os event.
+ *
+ * \details
+ * Starts an OS event.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] pal_os_event                  pal_os_event to be destroyed
+ *
+ */
+LIBRARY_EXPORTS void pal_os_event_destroy(pal_os_event_t * pal_os_event);
+
+/**
+ * \brief Callback registration function to trigger once when timer expires.
+ *
+ * \details
+ * Platform specific event call back registration function to trigger once when timer expires.
+ *  - This function registers the callback function supplied by the caller.
+ *  - It triggers a timer with the supplied time interval in microseconds.
+ *  - Once the timer expires, the registered callback function gets called.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_pal_os_event        Pointer to pal_os_event
+ * \param[in] callback              Callback function pointer
+ * \param[in] callback_args         Callback arguments
+ * \param[in] time_us               time in micro seconds to trigger the call back
+ *
+ */
+LIBRARY_EXPORTS void pal_os_event_register_callback_oneshot(pal_os_event_t * p_pal_os_event,
+                                                            register_callback callback,
+                                                            void * callback_args,
+                                                            uint32_t time_us);
+
+/**
+ * \brief Timer callback handler.
+ *
+ * \details
+ * Timer callback handler.
+ *  - This gets called from the TIMER elapse event.
+ *  - Once the timer expires, the registered callback function gets called from the timer event handler, if the call back is not NULL.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+*/
+void pal_os_event_trigger_registered_callback(void);
+
+/**
+ * \brief Start an os event.
+ *
+ * \details
+ * Starts an OS event.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_pal_os_event                Pointer to os event
+ * \param[in] callback                      Callback function to be registered internally
+ * \param[in] callback_args                 Arguement to be passed to registered callback
+ *
+ */
+LIBRARY_EXPORTS void pal_os_event_start(pal_os_event_t * p_pal_os_event,
+                                        register_callback callback,
+                                        void * callback_args);
+
+/**
+ * \brief Stops an os event.
+ *
+ * \details
+ * Stops an OS event.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_pal_os_event                Pointer to os event
+ *
+ */
+LIBRARY_EXPORTS void pal_os_event_stop(pal_os_event_t * p_pal_os_event);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_PAL_OS_EVENT_H_*/
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_lock.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_lock.h
new file mode 100644
index 000000000..2dc6b5263
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_lock.h
@@ -0,0 +1,166 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_lock.h
+*
+* \brief   This file provides the prototype declarations of PAL OS lock functionalities
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#ifndef _PAL_OS_LOCK_H_
+#define _PAL_OS_LOCK_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pal.h"
+/**
+ * @brief PAL OS lock structure .
+ */
+typedef struct pal_os_lock
+{
+    uint8_t lock;
+    uint8_t type;
+} pal_os_lock_t;
+
+/**
+ * \brief Creates a lock.
+ *
+ * \details
+ * Creates a lock to the instance of #pal_os_lock_t.
+ * - Creates the lock to the supplied instance.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_lock         Valid instance of #pal_os_lock_t.
+ * \param[in] lock_type      Type of the lock.
+ *
+ */
+void pal_os_lock_create(pal_os_lock_t * p_lock, uint8_t lock_type);
+
+/**
+ * \brief Deinitializes the lock.
+ *
+ * \details
+ * Destroys the lock to the instance of #pal_os_lock_t.
+ * - Deinitializes the lock of the supplied instance.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_lock         Valid instance of #pal_os_lock_t.
+ *
+ */
+void pal_os_lock_destroy(pal_os_lock_t * p_lock);
+
+/**
+ * \brief Acquires a lock.
+ *
+ * \details
+ * Acquires the lock associated with the instance of #pal_os_lock_t.
+ * - Acquires the lock to the supplied instance.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_lock         Valid instance of #pal_os_lock_t.
+ *
+ */
+pal_status_t pal_os_lock_acquire(pal_os_lock_t * p_lock);
+
+/**
+ * \brief Releases the lock.
+ *
+ * \details
+ * Releases the lock associated with the instance of #pal_os_lock_t.
+ * - Releases the lock to the supplied instance.
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_lock         Valid instance of #pal_os_lock_t.
+ *
+ */
+void pal_os_lock_release(pal_os_lock_t * p_lock);
+
+/**
+ * \brief To enter critical section.
+ *
+ * \details
+ * Enters critical section
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ */
+void pal_os_lock_enter_critical_section(void);
+
+/**
+ * \brief To exit critical section.
+ *
+ * \details
+ * Exits critical section
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ */
+void pal_os_lock_exit_critical_section(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_PAL_OS_LOCK_H_ */
+
+/**
+ * @}
+ */
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_memory.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_memory.h
new file mode 100644
index 000000000..495120ad9
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_memory.h
@@ -0,0 +1,162 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_memory.h
+*
+* \brief   This file provides the prototype declarations of PAL OS MEMORY.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+
+#ifndef _PAL_OS_MEMORY_H_
+#define _PAL_OS_MEMORY_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pal.h"
+
+
+/**
+ * \brief Allocates a block of memory specified by the block size and return the pointer to it.
+ *
+ * <br>
+ *
+ * \details
+ * - Allocates a block of memory specified by the block size and return the pointer to it
+ * 
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] block_size         Size of the block
+ *
+ * \retval  Block Pointer  Memory allocation is successful
+ * \retval  NULL           Memory allocation is not successful
+ */
+LIBRARY_EXPORTS void * pal_os_malloc(uint32_t block_size);
+
+/**
+ * @brief Allocates a block of memory specified by the block size and return the pointer to it.
+ *
+ * <br>
+ *
+ * \details
+ * - Allocates a block of memory specified by the block size and return the pointer to it
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] number_of_blocks      Number of block to allocate
+ * \param[in] block_size            Size of the block
+ *
+ * \retval  Block Pointer  Memory allocation is successful
+ * \retval  NULL           Memory allocation is not successful
+ */
+LIBRARY_EXPORTS void * pal_os_calloc(uint32_t number_of_blocks , uint32_t block_size);
+
+/**
+ * @brief Frees the block of memory specified by the block pointer.
+ *
+ * <br>
+ *
+ * \details
+ * - Frees the block of memory specified by the block pointer
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] block      Pointer to memory block to be freed
+ *
+ */
+LIBRARY_EXPORTS void pal_os_free(void * block);
+
+/**
+ * @brief Copies data from source to destination.
+ *
+ * <br>
+ *
+ * \details
+ * - Copies data from source to destination
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_destination      Source to copy the data from
+ * \param[in] p_source           Destination to copy the data to
+ * \param[in] size               Size of the data to copy
+ *
+ */
+LIBRARY_EXPORTS void pal_os_memcpy(void * p_destination, const void * p_source, uint32_t size);
+
+/**
+ * @brief Sets the buffer with the given value.
+ *
+ * <br>
+ *
+ * \details
+ * - Sets the buffer with the given value
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] p_buffer      Pointer to buffer
+ * \param[in] value         Value to be set in the buffer
+ * \param[in] size          Size of the buffer
+ *
+ */
+LIBRARY_EXPORTS void pal_os_memset(void * p_buffer, uint32_t value, uint32_t size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PAL_OS_MEMORY_H_ */
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_timer.h b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_timer.h
new file mode 100644
index 000000000..3c31dfea1
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/include/optiga/pal/pal_os_timer.h
@@ -0,0 +1,142 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_timer.h
+*
+* \brief   This file provides the prototype declarations of PAL OS timer functionalities.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#ifndef _PAL_OS_TIMER_H_
+#define _PAL_OS_TIMER_H_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pal.h"
+
+    
+/**
+ * \brief Gets tick count value in microseconds
+ *
+ * \details
+ * Get the current time in microseconds
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \retval  uint32_t time in microseconds
+ */  
+uint32_t pal_os_timer_get_time_in_microseconds(void);
+
+
+/**
+ * \brief Gets tick count value in milliseconds
+ *
+ * \details
+ * Get the current time in milliseconds
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \retval  uint32_t time in milliseconds
+ */
+uint32_t pal_os_timer_get_time_in_milliseconds(void);
+
+/**
+ * \brief Waits or delay until the supplied milliseconds
+ *
+ * \details
+ * Waits or delays until the given milliseconds time
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \param[in] milliseconds Delay value in milliseconds
+ *
+ */
+void pal_os_timer_delay_in_milliseconds(uint16_t milliseconds);
+
+/**
+ * \brief To initialize the timer
+ *
+ * \details
+ * To initialize the timer
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \retval  #PAL_STATUS_SUCCESS    On successful execution
+ * \retval  #PAL_STATUS_FAILURE    On failure
+ */
+pal_status_t pal_timer_init(void);
+
+/**
+ * \brief To De-initialize the timer
+ *
+ * \details
+ * To De-initialize the timer
+ *
+ * \pre
+ * - None
+ *
+ * \note
+ * - None
+ *
+ * \retval  #PAL_STATUS_SUCCESS    On successful execution
+ * \retval  #PAL_STATUS_FAILURE    On failure
+ */
+pal_status_t pal_timer_deinit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PAL_OS_TIMER_H_ */
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/optiga/util/optiga_util.c b/3rdparty/experimental/optiga/optiga/util/optiga_util.c
new file mode 100644
index 000000000..beab3bd3b
--- /dev/null
+++ b/3rdparty/experimental/optiga/optiga/util/optiga_util.c
@@ -0,0 +1,672 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file optiga_util.c
+*
+* \brief   This file implements the OPTIGA utility module functionalities
+*
+* \ingroup  grOptigaUtil
+*
+* @{
+*/
+
+#include "optiga/optiga_util.h"
+#include "optiga/common/optiga_lib_logger.h"
+#include "optiga/common/optiga_lib_common_internal.h"
+#include "optiga/pal/pal_os_memory.h"
+
+#if defined (OPTIGA_LIB_ENABLE_LOGGING) && defined (OPTIGA_LIB_ENABLE_UTIL_LOGGING)
+
+//Logs the message provided from Util layer
+#define OPTIGA_UTIL_LOG_MESSAGE(msg) \
+{\
+    optiga_lib_print_message(msg,OPTIGA_UTIL_SERVICE,OPTIGA_UTIL_SERVICE_COLOR);\
+}
+
+//Logs the byte array buffer provided from Util layer in hexadecimal format
+//lint --e{750} suppress "The unused OPTIGA_UTIL_LOG_HEX_DATA macro is kept for future enhancements"
+#define OPTIGA_UTIL_LOG_HEX_DATA(array,array_len) \
+{\
+    optiga_lib_print_array_hex_format(array,array_len,OPTIGA_UNPROTECTED_DATA_COLOR);\
+}
+
+//Logs the status info provided from Util layer
+//lint --e{750} suppress "The unused OPTIGA_UTIL_LOG_STATUS macro is kept for future enhancements"
+#define OPTIGA_UTIL_LOG_STATUS(return_value) \
+{ \
+    if (OPTIGA_LIB_SUCCESS != return_value) \
+    { \
+        optiga_lib_print_status(OPTIGA_UTIL_SERVICE,OPTIGA_ERROR_COLOR,return_value); \
+    } \
+    else\
+    { \
+        optiga_lib_print_status(OPTIGA_UTIL_SERVICE,OPTIGA_UTIL_SERVICE_COLOR,return_value); \
+    } \
+}
+#else
+
+#define OPTIGA_UTIL_LOG_MESSAGE(msg) {}
+//lint --e{750} suppress "The unused OPTIGA_UTIL_LOG_HEX_DATA macro is kept for future enhancements"
+#define OPTIGA_UTIL_LOG_HEX_DATA(array, array_len) {}
+//lint --e{750} suppress "The unused OPTIGA_UTIL_LOG_STATUS macro is kept for future enhancements"
+#define OPTIGA_UTIL_LOG_STATUS(return_value) {}
+
+#endif
+
+extern void optiga_cmd_set_shielded_connection_option(optiga_cmd_t * me, uint8_t value,
+                                                      uint8_t shielded_connection_option);
+
+
+
+_STATIC_H void optiga_util_generic_event_handler(void * me,
+                                                 optiga_lib_status_t event)
+{
+    optiga_util_t * p_optiga_util = (optiga_util_t *)me;
+
+    p_optiga_util->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+    p_optiga_util->handler(p_optiga_util->caller_context, event);
+}
+
+_STATIC_H void optiga_util_reset_protection_level(optiga_util_t * me)
+{
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+    if (NULL != me)
+#endif
+    {
+        OPTIGA_UTIL_SET_COMMS_PROTECTION_LEVEL(me, OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL);
+    }
+}
+
+_STATIC_H optiga_lib_status_t optiga_util_write_data_wrapper(optiga_util_t * me,
+                                                             uint16_t optiga_oid,
+                                                             uint8_t write_type,
+                                                             uint16_t offset,
+                                                             const uint8_t * p_buffer,
+                                                             uint16_t length)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    optiga_set_data_object_params_t * p_params;
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == p_buffer))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_set_data_object_params_t *)&(me->params.optiga_set_data_object_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_util_params_t));
+
+        if (OPTIGA_UTIL_COUNT_DATA_OBJECT == write_type)
+        {
+            p_params->count = p_buffer[0];
+            p_params->buffer = NULL;
+        }
+        else
+        {
+            p_params->count = 0;
+            p_params->buffer = p_buffer;
+        }
+        p_params->oid = optiga_oid;
+        p_params->offset = offset;
+        p_params->data_or_metadata = 0;//for Data
+        p_params->size = length;
+        p_params->written_size = 0;
+        p_params->write_type = write_type;
+
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+        return_value = optiga_cmd_set_data_object(me->my_cmd, write_type, (optiga_set_data_object_params_t *)p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_util_reset_protection_level(me);
+
+    return (return_value);
+}
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+void optiga_util_set_comms_params(optiga_util_t * me,
+                                  uint8_t parameter_type,
+                                  uint8_t value)
+{
+    switch (parameter_type)
+    {
+        case OPTIGA_COMMS_PROTECTION_LEVEL:
+        {
+            me->protection_level = value;
+            break;
+        }
+        case OPTIGA_COMMS_PROTOCOL_VERSION:
+        {
+            me->protocol_version = value;
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+#endif
+
+optiga_util_t * optiga_util_create(uint8_t optiga_instance_id,
+                                   callback_handler_t handler,
+                                   void * caller_context)
+{
+    optiga_util_t * me = NULL;
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if (NULL == handler)
+        {
+            break;
+        }
+#endif
+        me = (optiga_util_t *)pal_os_calloc(1, sizeof(optiga_util_t));
+        if (NULL == me)
+        {
+            break;
+        }
+
+        me->handler = handler;
+        me->caller_context = caller_context;
+        me->instance_state = OPTIGA_LIB_SUCCESS;
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        me->protocol_version = OPTIGA_COMMS_PROTOCOL_VERSION_PRE_SHARED_SECRET;
+        me->protection_level = OPTIGA_COMMS_DEFAULT_PROTECTION_LEVEL;
+#endif
+        me->my_cmd = optiga_cmd_create(optiga_instance_id, optiga_util_generic_event_handler, me);
+        if (NULL == me->my_cmd)
+        {
+            pal_os_free(me);
+            me = NULL;
+        }
+    } while (FALSE);
+
+    return (me);
+}
+
+optiga_lib_status_t optiga_util_destroy(optiga_util_t * me)
+{
+    optiga_lib_status_t return_value;
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if (NULL == me)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+        return_value = optiga_cmd_destroy(me->my_cmd);
+        pal_os_free(me);
+    } while (FALSE);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_open_application(optiga_util_t * me,
+                                                 bool_t perform_restore)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        if (FALSE == perform_restore)
+        {
+            OPTIGA_PROTECTION_MANAGE_CONTEXT(me->my_cmd, OPTIGA_COMMS_SESSION_CONTEXT_NONE);
+        }
+        else
+        {
+             OPTIGA_PROTECTION_MANAGE_CONTEXT(me->my_cmd, OPTIGA_COMMS_SESSION_CONTEXT_RESTORE);
+        }
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+
+        return_value = optiga_cmd_open_application(me->my_cmd, perform_restore, NULL);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+
+    } while (FALSE);
+    optiga_util_reset_protection_level(me);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_close_application(optiga_util_t * me,
+                                                  bool_t perform_hibernate)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+#ifdef OPTIGA_COMMS_SHIELDED_CONNECTION
+        if (FALSE == perform_hibernate)
+        {
+            OPTIGA_PROTECTION_MANAGE_CONTEXT(me->my_cmd, OPTIGA_COMMS_SESSION_CONTEXT_NONE);
+        }
+        else
+        {
+            OPTIGA_PROTECTION_MANAGE_CONTEXT(me->my_cmd, OPTIGA_COMMS_SESSION_CONTEXT_SAVE);
+        }
+#endif //OPTIGA_COMMS_SHIELDED_CONNECTION
+
+        return_value = optiga_cmd_close_application(me->my_cmd, perform_hibernate, NULL);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+
+    } while (FALSE);
+    optiga_util_reset_protection_level(me);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_read_data(optiga_util_t * me,
+                                          uint16_t optiga_oid,
+                                          uint16_t offset,
+                                          uint8_t * buffer,
+                                          uint16_t * length)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    optiga_get_data_object_params_t * p_params;
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) ||
+            (NULL == buffer) || (NULL == length))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_get_data_object_params_t *)&(me->params.optiga_get_data_object_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_util_params_t));
+
+        p_params->oid = optiga_oid;
+        p_params->offset = offset;
+        // set option to read data
+        p_params->data_or_metadata = 0;
+        p_params->buffer = buffer;
+        p_params->bytes_to_read = *length;
+        p_params->ref_bytes_to_read = length;
+        p_params->accumulated_size = 0;
+        p_params->last_read_size = 0;
+
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+        return_value = optiga_cmd_get_data_object(me->my_cmd, p_params->data_or_metadata, p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+
+    } while (FALSE);
+    optiga_util_reset_protection_level(me);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_read_metadata(optiga_util_t * me,
+                                              uint16_t optiga_oid,
+                                              uint8_t * buffer,
+                                              uint16_t * length)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    optiga_get_data_object_params_t * p_params;
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) ||
+            (NULL == buffer) || (NULL == length))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_get_data_object_params_t *)&(me->params.optiga_get_data_object_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_util_params_t));
+
+        p_params->oid = optiga_oid;
+        p_params->offset = 0;
+        // set option to read metadata
+        p_params->data_or_metadata = 1;//for metadata
+        p_params->buffer = buffer;
+        p_params->bytes_to_read = *length;
+        p_params->ref_bytes_to_read = length;
+        p_params->accumulated_size = 0;
+        p_params->last_read_size = 0;
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+        return_value = optiga_cmd_get_data_object(me->my_cmd, p_params->data_or_metadata,
+                                                  (optiga_get_data_object_params_t *)p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_util_reset_protection_level(me);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_write_data(optiga_util_t * me,
+                                           uint16_t optiga_oid,
+                                           uint8_t write_type,
+                                           uint16_t offset,
+                                           const uint8_t * buffer,
+                                           uint16_t length)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+        if ((OPTIGA_UTIL_WRITE_ONLY != write_type) && (OPTIGA_UTIL_ERASE_AND_WRITE != write_type))
+        {
+            break;
+        }
+        return_value =  optiga_util_write_data_wrapper(me,
+                                                       optiga_oid,
+                                                       write_type,
+                                                       offset,
+                                                       buffer,
+                                                       length);
+    } while (FALSE);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_write_metadata(optiga_util_t * me,
+                                               uint16_t optiga_oid,
+                                               const uint8_t * buffer,
+                                               uint8_t length)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    optiga_set_data_object_params_t * p_params;
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == buffer))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_set_data_object_params_t *)&(me->params.optiga_set_data_object_params);
+        pal_os_memset(&me->params,0x00,sizeof(optiga_util_params_t));
+
+        p_params->oid = optiga_oid;
+        p_params->offset = 0;
+        //for Metadata
+        p_params->data_or_metadata = 1;
+        p_params->buffer = buffer;
+        p_params->size = length;
+        p_params->write_type = 1;
+        p_params->written_size = 0;
+        OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+        OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+
+        return_value = optiga_cmd_set_data_object(me->my_cmd, p_params->write_type,
+                                                  (optiga_set_data_object_params_t *)p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+    optiga_util_reset_protection_level(me);
+
+    return (return_value);
+}
+
+_STATIC_H optiga_lib_status_t optiga_util_protected_update(optiga_util_t * me,
+                                                           uint8_t manifest_version,
+                                                           const uint8_t * p_buffer,
+                                                           uint16_t buffer_length,
+                                                           optiga_set_obj_protected_tag_t set_obj_tag)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    optiga_set_object_protected_params_t * p_params;
+
+    do
+    {
+        if (OPTIGA_LIB_INSTANCE_BUSY == me->instance_state)
+        {
+            return_value = OPTIGA_UTIL_ERROR_INSTANCE_IN_USE;
+            break;
+        }
+
+        me->instance_state = OPTIGA_LIB_INSTANCE_BUSY;
+        p_params = (optiga_set_object_protected_params_t *)&(me->params.optiga_set_object_protected_params);
+
+        if(OPTIGA_SET_PROTECTED_UPDATE_START == set_obj_tag)
+        {
+            pal_os_memset(&me->params,0x00,sizeof(optiga_util_params_t));
+            p_params->manifest_version = manifest_version;
+            OPTIGA_PROTECTION_ENABLE(me->my_cmd, me);
+            OPTIGA_PROTECTION_SET_VERSION(me->my_cmd, me);
+        }
+
+        p_params->p_protected_update_buffer = p_buffer;
+        p_params->p_protected_update_buffer_length = buffer_length;
+        p_params->set_obj_protected_tag = set_obj_tag;
+
+        return_value = optiga_cmd_set_object_protected(me->my_cmd, p_params->manifest_version,p_params);
+        if (OPTIGA_LIB_SUCCESS != return_value)
+        {
+            me->instance_state = OPTIGA_LIB_INSTANCE_FREE;
+        }
+    } while (FALSE);
+
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_protected_update_start(optiga_util_t * me,
+                                                       uint8_t manifest_version,
+                                                       const uint8_t * manifest,
+                                                       uint16_t manifest_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == manifest))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        return_value = optiga_util_protected_update(me,
+                                                    manifest_version,
+                                                    manifest,
+                                                    manifest_length,
+                                                    OPTIGA_SET_PROTECTED_UPDATE_START);
+    } while (FALSE);
+    optiga_util_reset_protection_level(me);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_protected_update_continue(optiga_util_t * me,
+                                                          const uint8_t * fragment,
+                                                          uint16_t fragment_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd) || (NULL == fragment))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        return_value = optiga_util_protected_update(me,
+                                                    0x00,
+                                                    fragment,
+                                                    fragment_length,
+                                                    OPTIGA_SET_PROTECTED_UPDATE_CONTINUE);
+    } while (FALSE);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_protected_update_final(optiga_util_t * me,
+                                                       const uint8_t * fragment,
+                                                       uint16_t fragment_length)
+{
+    optiga_lib_status_t return_value = OPTIGA_UTIL_ERROR;
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == me) || (NULL == me->my_cmd))
+        {
+            return_value = OPTIGA_UTIL_ERROR_INVALID_INPUT;
+            break;
+        }
+#endif
+
+        return_value = optiga_util_protected_update(me,
+                                                    0x00,
+                                                    fragment,
+                                                    fragment_length,
+                                                    OPTIGA_SET_PROTECTED_UPDATE_FINAL);
+    } while (FALSE);
+    return (return_value);
+}
+
+optiga_lib_status_t optiga_util_update_count(optiga_util_t * me,
+                                             uint16_t optiga_counter_oid,
+                                             uint8_t count)
+{
+    const uint8_t count_value[] = {count};
+    OPTIGA_UTIL_LOG_MESSAGE(__FUNCTION__);
+    return (optiga_util_write_data_wrapper(me,
+                                           optiga_counter_oid,
+                                           OPTIGA_UTIL_COUNT_DATA_OBJECT,
+                                           0x0000,
+                                           count_value,
+                                           sizeof(count_value)));
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal.c b/3rdparty/experimental/optiga/pal/esp32/pal.c
new file mode 100644
index 000000000..b37ffa6f1
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal.c
@@ -0,0 +1,57 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal.c
+*
+* \brief    This file implements the platform abstraction layer APIs.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+
+#include "optiga/pal/pal.h"
+#include "optiga/pal/pal_gpio.h"
+
+pal_status_t pal_init(void)
+{
+    
+    return pal_gpio_init(NULL);
+    //return PAL_STATUS_SUCCESS;
+}
+
+
+pal_status_t pal_deinit(void)
+{
+    return PAL_STATUS_SUCCESS;
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_gpio.c b/3rdparty/experimental/optiga/pal/esp32/pal_gpio.c
new file mode 100644
index 000000000..0fa9ddcc6
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_gpio.c
@@ -0,0 +1,81 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_gpio.c
+*
+* \brief   This file implements the platform abstraction layer APIs for GPIO.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_gpio.h"
+#include <aos/hal/gpio.h>
+//#include "driver/gpio.h"
+#define RESET_PIN   25
+#define VDD_PIN     26
+
+
+gpio_dev_t gpio_reset;
+gpio_dev_t gpio_vdd;
+//lint --e{714,715} suppress "This is implemented for overall completion of API"
+pal_status_t pal_gpio_init(const pal_gpio_t * p_gpio_context)
+{
+
+    gpio_reset.port  = RESET_PIN;
+    gpio_reset.config = OUTPUT_PUSH_PULL;
+    hal_gpio_init(&gpio_reset);
+    gpio_vdd.port  = VDD_PIN;
+    gpio_vdd.config = OUTPUT_PUSH_PULL;
+    hal_gpio_init(&gpio_vdd);
+
+    return PAL_STATUS_SUCCESS;
+}
+
+//lint --e{714,715} suppress "This is implemented for overall completion of API"
+pal_status_t pal_gpio_deinit(const pal_gpio_t * p_gpio_context)
+{
+    return PAL_STATUS_SUCCESS;
+}
+
+void pal_gpio_set_high(const pal_gpio_t * p_gpio_context)
+{
+    gpio_dev_t *gpio_context = (gpio_dev_t*) p_gpio_context->p_gpio_hw; 
+    hal_gpio_output_high(gpio_context);
+}
+
+void pal_gpio_set_low(const pal_gpio_t * p_gpio_context)
+{
+    gpio_dev_t *gpio_context = (gpio_dev_t*) p_gpio_context->p_gpio_hw;
+    hal_gpio_output_high(gpio_context);
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_i2c.c b/3rdparty/experimental/optiga/pal/esp32/pal_i2c.c
new file mode 100644
index 000000000..a9075fbee
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_i2c.c
@@ -0,0 +1,260 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_i2c.c
+*
+* \brief   This file implements the platform abstraction layer(pal) APIs for I2C.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+
+#include "optiga/pal/pal_i2c.h"
+#include "aos/hal/i2c.h"
+#include "aos/kernel.h"
+
+#define PAL_I2C_MASTER_MAX_BITRATE  (400U)
+/// @cond hidden
+_STATIC_H volatile uint32_t g_entry_count = 0;
+_STATIC_H const pal_i2c_t * gp_pal_i2c_current_ctx;
+
+//lint --e{715} suppress "This is implemented for overall completion of API"
+_STATIC_H pal_status_t pal_i2c_acquire(const void * p_i2c_context)
+{
+    if (0 == g_entry_count)
+    {
+        g_entry_count++;
+        if (1 == g_entry_count)
+        {
+            return PAL_STATUS_SUCCESS;
+        }
+    }
+    return PAL_STATUS_FAILURE;
+}
+
+//lint --e{715} suppress "The unused p_i2c_context variable is kept for future enhancements"
+_STATIC_H void pal_i2c_release(const void * p_i2c_context)
+{
+    g_entry_count = 0;
+}
+/// @endcond
+
+void invoke_upper_layer_callback (const pal_i2c_t * p_pal_i2c_ctx, optiga_lib_status_t event)
+{
+    upper_layer_callback_t upper_layer_handler;
+    //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+    upper_layer_handler = (upper_layer_callback_t)p_pal_i2c_ctx->upper_layer_event_handler;
+
+    upper_layer_handler(p_pal_i2c_ctx->p_upper_layer_ctx, event);
+
+    //Release I2C Bus
+    pal_i2c_release(p_pal_i2c_ctx->p_upper_layer_ctx);
+}
+
+/// @cond hidden
+void i2c_master_end_of_transmit_callback(void)
+{
+    invoke_upper_layer_callback(gp_pal_i2c_current_ctx, PAL_I2C_EVENT_SUCCESS);
+}
+
+void i2c_master_end_of_receive_callback(void)
+{
+    invoke_upper_layer_callback(gp_pal_i2c_current_ctx, PAL_I2C_EVENT_SUCCESS);
+}
+
+void i2c_master_error_detected_callback(void)
+{
+    invoke_upper_layer_callback(gp_pal_i2c_current_ctx, PAL_I2C_EVENT_ERROR);
+}
+
+void i2c_master_nack_received_callback(void)
+{
+    i2c_master_error_detected_callback();
+}
+
+void i2c_master_arbitration_lost_callback(void)
+{
+    i2c_master_error_detected_callback();
+}
+/// @endcond
+
+pal_status_t pal_i2c_init(const pal_i2c_t * p_i2c_context)
+{
+    pal_status_t status = PAL_STATUS_SUCCESS;
+    if (hal_i2c_init(p_i2c_context->p_i2c_hw_config)) {
+        status = PAL_STATUS_FAILURE;
+    }
+    return status;
+}
+
+pal_status_t pal_i2c_deinit(const pal_i2c_t * p_i2c_context)
+{    
+    return PAL_STATUS_SUCCESS;
+}
+
+pal_status_t pal_i2c_write(const pal_i2c_t * p_i2c_context, uint8_t * p_data, uint16_t length)
+{
+    pal_status_t status = PAL_STATUS_FAILURE;
+    //Acquire the I2C bus before read/write
+    if (PAL_STATUS_SUCCESS == pal_i2c_acquire(p_i2c_context))
+    {
+        gp_pal_i2c_current_ctx = p_i2c_context;
+
+        //Invoke the low level i2c master driver API to write to the bus
+        if (0 != hal_i2c_master_send(p_i2c_context->p_i2c_hw_config, 
+                                    (p_i2c_context->slave_address << 1), 
+                                    p_data, 
+                                    length, 
+                                    HAL_WAIT_FOREVER))
+        {
+            //If I2C Master fails to invoke the write operation, invoke upper layer event handler with error.
+
+            //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+            ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                       (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_ERROR);
+            //Release I2C Bus
+            pal_i2c_release((void * )p_i2c_context);
+        }
+        else
+        {
+            //Check status flags
+            if (0 != hal_i2c_get_status(p_i2c_context->p_i2c_hw_config))
+            {
+                ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                        (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_ERROR);
+                //Release I2C Bus
+                pal_i2c_release((void * )p_i2c_context);
+            }
+            else
+            {
+                i2c_master_end_of_transmit_callback();
+                status = PAL_STATUS_SUCCESS;
+            }
+		}
+    }
+    else
+    {
+        status = PAL_STATUS_I2C_BUSY;
+        //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+        ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                        (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_BUSY);
+    }
+    return status;
+}
+
+pal_status_t pal_i2c_read(const pal_i2c_t * p_i2c_context, uint8_t * p_data, uint16_t length)
+{
+    pal_status_t status = PAL_STATUS_FAILURE;
+    //Acquire the I2C bus before read/write
+    if (PAL_STATUS_SUCCESS == pal_i2c_acquire(p_i2c_context))
+    {
+        gp_pal_i2c_current_ctx = p_i2c_context;
+
+        //Invoke the low level i2c master driver API to read from the bus
+        if (0 != hal_i2c_master_recv(p_i2c_context->p_i2c_hw_config, 
+                                    (p_i2c_context->slave_address << 1), 
+                                     p_data, 
+                                     length, 
+                                     AOS_WAIT_FOREVER))
+        {
+            //If I2C Master fails to invoke the read operation, invoke upper layer event handler with error.
+
+            //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+            ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                       (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_ERROR);
+            //Release I2C Bus
+            pal_i2c_release((void * )p_i2c_context);
+        }
+		else
+        {
+            //Check status flags
+            if (0 != hal_i2c_get_status(p_i2c_context->p_i2c_hw_config))
+            {
+                ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                        (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_ERROR);
+                //Release I2C Bus
+                pal_i2c_release((void * )p_i2c_context);
+            }
+            else
+            {
+                i2c_master_end_of_receive_callback();
+                status = PAL_STATUS_SUCCESS;
+            }
+        }
+    }
+    else
+    {
+        status = PAL_STATUS_I2C_BUSY;
+        //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+        ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                        (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_BUSY);
+    }
+    return status;
+}
+
+pal_status_t pal_i2c_set_bitrate(const pal_i2c_t * p_i2c_context, uint16_t bitrate)
+{
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+    optiga_lib_status_t event = PAL_I2C_EVENT_ERROR;
+
+    //This function is stubed to return success 
+    //Acquire the I2C bus before setting the bitrate
+    if (PAL_STATUS_SUCCESS == pal_i2c_acquire(p_i2c_context))
+    {    
+        // If the user provided bitrate is greater than the I2C master hardware maximum supported value,
+        // set the I2C master to its maximum supported value.
+        if (bitrate > PAL_I2C_MASTER_MAX_BITRATE)         
+        {
+            bitrate = PAL_I2C_MASTER_MAX_BITRATE;
+        }
+        return_status = PAL_STATUS_SUCCESS;
+        event = PAL_I2C_EVENT_SUCCESS;
+    }
+    else
+    {
+        return_status = PAL_STATUS_I2C_BUSY;
+        event = PAL_I2C_EVENT_BUSY;
+    }
+    if (0 != p_i2c_context->upper_layer_event_handler)
+    {
+        //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+        ((callback_handler_t)(p_i2c_context->upper_layer_event_handler))(p_i2c_context->p_upper_layer_ctx , event);
+    }
+    //Release I2C Bus if its acquired 
+    if (PAL_STATUS_I2C_BUSY != return_status)
+    {
+        pal_i2c_release((void * )p_i2c_context);
+    }
+    return return_status;
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_ifx_i2c_config.c b/3rdparty/experimental/optiga/pal/esp32/pal_ifx_i2c_config.c
new file mode 100644
index 000000000..553099fef
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_ifx_i2c_config.c
@@ -0,0 +1,91 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_ifx_i2c_config.c
+*
+* \brief   This file implements platform abstraction layer configurations for ifx i2c protocol.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_gpio.h"
+#include "optiga/pal/pal_i2c.h"
+#include "optiga/ifx_i2c/ifx_i2c_config.h"
+#include <aos/hal/gpio.h>
+#include "aos/hal/i2c.h"
+#include "aos/kernel.h"
+
+extern gpio_dev_t gpio_reset;
+extern gpio_dev_t gpio_vdd;
+
+i2c_dev_t i2c_0 = {
+    .port                 = 0,
+    .config.address_width = I2C_HAL_ADDRESS_WIDTH_7BIT,
+    .config.freq          = I2C_BUS_BIT_RATES_400K,
+    .config.mode          = I2C_MODE_MASTER,
+    .config.dev_addr      = 0x30 << 1
+};
+
+/**
+ * \brief PAL I2C configuration for OPTIGA. 
+ */
+pal_i2c_t optiga_pal_i2c_context_0 =
+{
+    /// Pointer to I2C master platform specific context
+    &i2c_0,
+    /// Slave address
+    0x30,
+    /// Upper layer context
+    NULL,
+    /// Callback event handler
+    NULL
+};
+
+/**
+* \brief PAL vdd pin configuration for OPTIGA. 
+ */
+pal_gpio_t optiga_vdd_0 =
+{
+    // Platform specific GPIO context for the pin used to toggle Vdd.
+	(void*)&gpio_vdd
+};
+
+/**
+ * \brief PAL reset pin configuration for OPTIGA.
+ */
+pal_gpio_t optiga_reset_0 =
+{
+    // Platform specific GPIO context for the pin used to toggle Reset.
+    (void*)&gpio_reset
+};
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_logger.c b/3rdparty/experimental/optiga/pal/esp32/pal_logger.c
new file mode 100644
index 000000000..3f63d62fa
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_logger.c
@@ -0,0 +1,109 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+ *
+ * \file    pal_logger.c
+ *
+ * \brief   This file provides the prototypes declarations for pal logger.
+ *
+ * \ingroup grPAL
+ *
+ * @{
+ */
+
+#include "optiga/pal/pal_logger.h"
+#include "ulog/ulog.h"
+#include "aos/kernel.h"
+#include "ulog_api.h"
+#include "aos/hal/uart.h"
+/// @cond hidden
+#define HAL_WAIT_FOREVER 0xFFFFFFFFU
+uart_dev_t uart_logger= {
+    .port = 0,
+    .priv = NULL,
+};
+//lint --e{552,714} suppress "Accessed by user of this structure" 
+pal_logger_t logger_console =
+{
+        .logger_config_ptr = NULL,
+        .logger_rx_flag = 1,
+        .logger_tx_flag = 1
+};
+//lint --e{552} suppress "Accessed by user of this structure"
+pal_logger_t cunit_console =
+{
+        .logger_config_ptr = NULL,
+        .logger_rx_flag = 1,
+        .logger_tx_flag = 1
+};
+
+void cunit_console_uart_end_of_transmit_callback(void)
+{
+    cunit_console.logger_tx_flag = 0;
+}
+
+void cunit_console_uart_end_of_receive_callback(void)
+{
+    cunit_console.logger_rx_flag = 0;
+}
+
+/// @endcond
+
+
+pal_status_t pal_logger_init(void * p_logger_context)
+{
+    return PAL_STATUS_SUCCESS;
+}
+
+
+pal_status_t pal_logger_deinit(void * p_logger_context)
+{
+    return PAL_STATUS_SUCCESS;
+}
+
+
+pal_status_t pal_logger_write(void * p_logger_context, const uint8_t * p_log_data, uint32_t log_data_length)
+{
+    int32_t return_status = PAL_STATUS_FAILURE;
+
+    return_status = hal_uart_send(&uart_logger, p_log_data, log_data_length, HAL_WAIT_FOREVER);
+
+    return ((pal_status_t)return_status);
+}
+
+pal_status_t pal_logger_read(void * p_logger_context, uint8_t * p_log_data, uint32_t log_data_length)
+{
+    int32_t return_status = PAL_STATUS_FAILURE;
+    uint32_t log_rcv_data_length = 0;
+    memset(p_log_data, 0x00, log_data_length);
+    return_status = hal_uart_recv_II(&uart_logger, p_log_data, log_data_length, &log_rcv_data_length, HAL_WAIT_FOREVER);
+
+    return ((pal_status_t)return_status);
+}
+/**
+ * @}
+ */
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_os_datastore.c b/3rdparty/experimental/optiga/pal/esp32/pal_os_datastore.c
new file mode 100644
index 000000000..72c9875c9
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_os_datastore.c
@@ -0,0 +1,192 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_datastore.c
+*
+* \brief   This file implements the platform abstraction layer APIs for data store.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_os_datastore.h"
+/// @cond hidden
+
+/// Size of length field 
+#define LENGTH_SIZE                (0x02)
+/// Size of data store buffer to hold the shielded connection manage context information (2 bytes length field + 64(0x40) bytes context)
+#define MANAGE_CONTEXT_BUFFER_SIZE      (0x42)
+
+//Internal buffer to store the shielded connection manage context information (length field + Data)
+uint8_t data_store_manage_context_buffer [LENGTH_SIZE + MANAGE_CONTEXT_BUFFER_SIZE];
+
+//Internal buffer to store the optiga application context data during hibernate(length field + Data)
+uint8_t data_store_app_context_buffer [LENGTH_SIZE + APP_CONTEXT_SIZE];
+
+//Internal buffer to store the generated platform binding shared secret on Host (length field + shared secret)
+uint8_t optiga_platform_binding_shared_secret [LENGTH_SIZE + OPTIGA_SHARED_SECRET_MAX_LENGTH] = 
+{
+    // Length of the shared secret, followed after the length information
+    0x00 ,0x40, 
+    // Shared secret. Buffer is defined to the maximum supported length [64 bytes]. 
+    // But the actual size used is to be specified in the length field.
+    0x01 ,0x02 ,0x03 ,0x04 ,0x05 ,0x06 ,0x07 ,0x08 ,0x09 ,0x0A ,0x0B ,0x0C ,0x0D ,0x0E ,0x0F ,0x10,
+    0x11 ,0x12 ,0x13 ,0x14 ,0x15 ,0x16 ,0x17 ,0x18 ,0x19 ,0x1A ,0x1B ,0x1C ,0x1D ,0x1E ,0x1F ,0x20,
+    0x21 ,0x22 ,0x23 ,0x24 ,0x25 ,0x26 ,0x27 ,0x28 ,0x29 ,0x2A ,0x2B ,0x2C ,0x2D ,0x2E ,0x2F ,0x30,
+    0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 ,0x38 ,0x39 ,0x3A ,0x3B ,0x3C ,0x3D ,0x3E ,0x3F ,0x40
+};
+
+
+pal_status_t pal_os_datastore_write(uint16_t datastore_id,
+                                    const uint8_t * p_buffer,
+                                    uint16_t length)
+{
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+    uint8_t offset = 0;
+
+    switch(datastore_id)
+    {
+        case OPTIGA_PLATFORM_BINDING_SHARED_SECRET_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only, in case of updating
+            // the platform binding shared secret during the runtime into NVM.
+            // In current implementation, platform binding shared secret is 
+            // stored in RAM.
+            if (length <= OPTIGA_SHARED_SECRET_MAX_LENGTH)
+            {
+                optiga_platform_binding_shared_secret[offset++] = (uint8_t)(length>>8);
+                optiga_platform_binding_shared_secret[offset++] = (uint8_t)(length);
+                memcpy(&optiga_platform_binding_shared_secret[offset], p_buffer, length);
+                return_status = PAL_STATUS_SUCCESS;
+            }
+            break;
+        }
+        case OPTIGA_COMMS_MANAGE_CONTEXT_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only, in case of storing 
+            // the manage context information in non-volatile memory 
+            // to reuse for later during hard reset scenarios where the 
+            // RAM gets flushed out.
+            data_store_manage_context_buffer[offset++] = (uint8_t)(length>>8);
+            data_store_manage_context_buffer[offset++] = (uint8_t)(length);
+            memcpy(&data_store_manage_context_buffer[offset],p_buffer,length);
+            return_status = PAL_STATUS_SUCCESS;
+            break;
+        }
+        case OPTIGA_HIBERNATE_CONTEXT_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only, in case of storing 
+            // the application context information in non-volatile memory 
+            // to reuse for later during hard reset scenarios where the 
+            // RAM gets flushed out.
+            data_store_app_context_buffer[offset++] = (uint8_t)(length>>8);
+            data_store_app_context_buffer[offset++] = (uint8_t)(length);
+            memcpy(&data_store_app_context_buffer[offset],p_buffer,length);
+            return_status = PAL_STATUS_SUCCESS;
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+    return return_status;
+}
+
+
+pal_status_t pal_os_datastore_read(uint16_t datastore_id, 
+                                   uint8_t * p_buffer, 
+                                   uint16_t * p_buffer_length)
+{
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+    uint16_t data_length;
+    uint8_t offset = 0;
+
+    switch(datastore_id)
+    {
+        case OPTIGA_PLATFORM_BINDING_SHARED_SECRET_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only,
+            // if the platform binding shared secret is stored in non-volatile 
+            // memory with a specific location and not as a context segment 
+            // else updating the share secret content is good enough.
+
+            data_length = (uint16_t) (optiga_platform_binding_shared_secret[offset++] << 8);
+            data_length |= (uint16_t)(optiga_platform_binding_shared_secret[offset++]);
+            if (data_length <= OPTIGA_SHARED_SECRET_MAX_LENGTH)
+            {
+                memcpy(p_buffer,&optiga_platform_binding_shared_secret[offset], data_length);
+                *p_buffer_length = data_length;
+                return_status = PAL_STATUS_SUCCESS;
+            }
+            break;
+        }
+        case OPTIGA_COMMS_MANAGE_CONTEXT_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only,
+            // if manage context information is stored in NVM during the hibernate, 
+            // else this is not required to be enhanced.
+            data_length = (uint16_t) (data_store_manage_context_buffer[offset++] << 8);
+            data_length |= (uint16_t)(data_store_manage_context_buffer[offset++]);
+            memcpy(p_buffer, &data_store_manage_context_buffer[offset], data_length);
+            *p_buffer_length = data_length;
+            return_status = PAL_STATUS_SUCCESS;
+            break;
+        }
+        case OPTIGA_HIBERNATE_CONTEXT_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only,
+            // if application context information is stored in NVM during the hibernate, 
+            // else this is not required to be enhanced.
+            data_length = (uint16_t) (data_store_app_context_buffer[offset++] << 8);
+            data_length |= (uint16_t)(data_store_app_context_buffer[offset++]);
+            memcpy(p_buffer, &data_store_app_context_buffer[offset], data_length);
+            *p_buffer_length = data_length;
+            return_status = PAL_STATUS_SUCCESS;
+            break;
+        }
+        default:
+        {
+            *p_buffer_length = 0;
+            break;
+        }
+    }
+
+    return return_status;
+}
+/// @endcond
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_os_event.c b/3rdparty/experimental/optiga/pal/esp32/pal_os_event.c
new file mode 100644
index 000000000..6fddee0f8
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_os_event.c
@@ -0,0 +1,138 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_event.c
+*
+* \brief   This file implements the platform abstraction layer APIs for os event/scheduler.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_os_event.h"
+#include "espos_timer.h"
+
+static const char *TIMER_NAME = "scheduler_timer";
+
+static espos_timer_t scheduler_timer;
+static uint8_t create_state = 1;
+/// @cond hidden
+
+static pal_os_event_t pal_os_event_0 = {0};
+
+
+static void timer_handler(espos_timer_t timer, void *arg)
+{
+    pal_os_event_trigger_registered_callback();
+}
+
+void pal_os_event_start(pal_os_event_t * p_pal_os_event, register_callback callback, void * callback_args)
+{
+    if (FALSE == p_pal_os_event->is_event_triggered)
+    {
+        pal_os_event_register_callback_oneshot(p_pal_os_event,callback,callback_args,1000);
+        p_pal_os_event->is_event_triggered = TRUE;
+    }
+}
+
+void pal_os_event_stop(pal_os_event_t * p_pal_os_event)
+{
+    //lint --e{714} suppress "The API pal_os_event_stop is not exposed in header file but used as extern in 
+    //optiga_cmd.c"
+    p_pal_os_event->is_event_triggered = FALSE;
+    espos_timer_stop(scheduler_timer);
+}
+
+pal_os_event_t * pal_os_event_create(register_callback callback, void * callback_args)
+{
+    if (( NULL != callback )&&( NULL != callback_args ))
+    {
+        pal_os_event_start(&pal_os_event_0,callback,callback_args);
+    }
+    return (&pal_os_event_0);
+}
+
+void pal_os_event_trigger_registered_callback(void)
+{
+    register_callback callback;
+
+    // !!!OPTIGA_LIB_PORTING_REQUIRED
+    // The following steps related to TIMER must be taken care while porting to different platform
+    //lint --e{534} suppress "Error handling is not required so return value is not checked"
+    espos_timer_stop(scheduler_timer);
+
+    if (pal_os_event_0.callback_registered)
+    {
+        callback = pal_os_event_0.callback_registered;
+        pal_os_event_0.callback_registered = NULL;
+        callback((void * )pal_os_event_0.callback_ctx);
+    }
+}
+/// @endcond
+
+void pal_os_event_register_callback_oneshot(pal_os_event_t * p_pal_os_event,
+                                             register_callback callback,
+                                             void * callback_args,
+                                             uint32_t time_us)
+{
+    p_pal_os_event->callback_registered = callback;
+    p_pal_os_event->callback_ctx = callback_args;
+    uint32_t time_ms;
+
+    if(create_state)
+    {
+        // !!!OPTIGA_LIB_PORTING_REQUIRED
+        // The following steps related to TIMER must be taken care while porting to different platform
+        espos_timer_create(&scheduler_timer, 
+                            TIMER_NAME, 
+                            timer_handler, 
+                            NULL,
+                            2,
+                            ESPOS_TIMER_NO_AUTO_RUN);
+        create_state = 0;
+        
+    }
+    else
+    {
+        //espos_timer_set_period(scheduler_timer, espos_ms_to_ticks(5));
+        espos_timer_set_period(scheduler_timer, 2);
+    }
+    
+    espos_timer_start(scheduler_timer);
+}
+
+//lint --e{818,715} suppress "As there is no implementation, pal_os_event is not used"
+void pal_os_event_destroy(pal_os_event_t * pal_os_event)
+{
+    espos_timer_del(scheduler_timer);
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_os_lock.c b/3rdparty/experimental/optiga/pal/esp32/pal_os_lock.c
new file mode 100644
index 000000000..3421d9808
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_os_lock.c
@@ -0,0 +1,87 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_lock.c
+*
+* \brief   This file implements the platform abstraction layer APIs for os locks (e.g. semaphore).
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_os_lock.h"
+
+void pal_os_lock_create(pal_os_lock_t * p_lock, uint8_t lock_type)
+{
+    p_lock->type = lock_type;
+    p_lock->lock = 0;
+}
+
+//lint --e{715} suppress "p_lock is not used here as it is placeholder for future." 
+//lint --e{818} suppress "Not declared as pointer as nothing needs to be updated in the pointer."
+void pal_os_lock_destroy(pal_os_lock_t * p_lock)
+{
+    
+}
+
+pal_status_t pal_os_lock_acquire(pal_os_lock_t * p_lock)
+{
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+
+    if (!(p_lock->lock))
+    {
+        p_lock->lock++;
+        if (1 != p_lock->lock)
+        {
+            p_lock->lock--;
+        }
+        return_status = PAL_STATUS_SUCCESS;
+    }
+    return return_status;
+}
+
+void pal_os_lock_release(pal_os_lock_t * p_lock)
+{
+    if (0 != p_lock->lock)
+    {
+        p_lock->lock--;
+    }
+}
+
+void pal_os_lock_enter_critical_section()
+{
+}
+
+void pal_os_lock_exit_critical_section()
+{
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_os_memory.c b/3rdparty/experimental/optiga/pal/esp32/pal_os_memory.c
new file mode 100644
index 000000000..5f5149d68
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_os_memory.c
@@ -0,0 +1,67 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_gpio.c
+*
+* \brief   This file implements the platform abstraction layer APIs for GPIO.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_os_memory.h"
+
+void * pal_os_malloc(uint32_t block_size)
+{
+    return (malloc(block_size));
+}
+
+void * pal_os_calloc(uint32_t number_of_blocks , uint32_t block_size)
+{
+    return (calloc(number_of_blocks, block_size));
+}
+
+void pal_os_free(void * p_block)
+{
+    free(p_block);
+}
+
+void pal_os_memcpy(void * p_destination, const void * p_source, uint32_t size)
+{
+    memcpy(p_destination, p_source, size);
+}
+
+void pal_os_memset(void * p_buffer, uint32_t value, uint32_t size)
+{
+    memset(p_buffer, value, size);
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_os_random.c b/3rdparty/experimental/optiga/pal/esp32/pal_os_random.c
new file mode 100644
index 000000000..7fcc012bd
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_os_random.c
@@ -0,0 +1,73 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_random.c
+*
+* \brief   This file implements the platform abstraction layer APIs for random seed generation.
+*
+* \ingroup  grPAL
+* @{
+*/
+
+#include "optiga/pal/pal_os_timer.h"
+
+/// @cond hidden
+static uint32_t g_random_count;
+
+void random_tick_timer_isr(void)
+{
+    //14 bit counter
+    g_random_count = ((g_random_count + 1) % (0x4000));        
+}
+
+uint32_t pal_os_random_get_counter(void)
+{
+    uint32_t millisec_start_count;
+    uint32_t millisec_current_count;
+
+    millisec_start_count = pal_os_timer_get_time_in_milliseconds();
+    do
+    {
+        millisec_current_count = pal_os_timer_get_time_in_milliseconds();
+        if (millisec_current_count > millisec_start_count)
+        {
+            break;
+        }
+    } while (1);
+
+    //stop timer 
+    //(void)TIMER_Stop(&random_timer);
+    
+    //Return the current random timer value
+    return g_random_count;
+}
+
+/**
+* @}
+*/
+
diff --git a/3rdparty/experimental/optiga/pal/esp32/pal_os_timer.c b/3rdparty/experimental/optiga/pal/esp32/pal_os_timer.c
new file mode 100644
index 000000000..c06a118a3
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/esp32/pal_os_timer.c
@@ -0,0 +1,100 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_timer.c
+*
+* \brief   This file implements the platform abstraction layer APIs for timer.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_os_timer.h"
+
+/// @cond hidden
+static volatile uint32_t g_tick_count = 0;
+
+void delay_timer_isr(void)
+{
+    //TIMER_ClearEvent(&tick_timer);
+    //(void)TIMER_Clear(&tick_timer);
+    g_tick_count += 1U;
+}
+
+/// @endcond
+
+
+uint32_t pal_os_timer_get_time_in_microseconds(void)
+{
+    // !!!OPTIGA_LIB_PORTING_REQUIRED
+    // This API is needed to support optiga cmd scheduler. 
+    static uint32_t count = 0;
+    // The implementation must ensure that every invocation of this API returns a unique value.
+    return (count++);
+}
+
+uint32_t pal_os_timer_get_time_in_milliseconds(void)
+{
+    return  krhino_sys_time_get();
+}
+
+void pal_os_timer_delay_in_milliseconds(uint16_t milliseconds)
+{
+    uint32_t start_time;
+    uint32_t current_time;
+    uint32_t time_stamp_diff;
+
+    start_time = pal_os_timer_get_time_in_milliseconds();
+    current_time = start_time;
+    time_stamp_diff = current_time - start_time;
+    while (time_stamp_diff <= (uint32_t)milliseconds)
+    {
+        current_time = pal_os_timer_get_time_in_milliseconds();
+        time_stamp_diff = current_time - start_time;
+        if (start_time > current_time)
+        {
+            time_stamp_diff = (0xFFFFFFFF + (current_time - start_time)) + 0x01;
+        }        
+    }
+}
+
+//lint --e{714} suppress "This is implemented for overall completion of API"
+pal_status_t pal_timer_init(void)
+{
+    return PAL_STATUS_SUCCESS;
+}
+
+//lint --e{714} suppress "This is implemented for overall completion of API"
+pal_status_t pal_timer_deinit(void)
+{
+    return PAL_STATUS_SUCCESS;
+}
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/pal_crypt_mbedtls.c b/3rdparty/experimental/optiga/pal/pal_crypt_mbedtls.c
new file mode 100644
index 000000000..087362f7e
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/pal_crypt_mbedtls.c
@@ -0,0 +1,304 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_crypt_mbedtls.c
+*
+* \brief   This file implements the platform abstraction layer APIs for cryptographic functions using mbedTLS SW Crypto.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/common/optiga_lib_common.h"
+#include "optiga/pal/pal_crypt.h"
+#include "optiga/pal/pal_os_memory.h"
+#include "mbedtls/ccm.h"
+#include "mbedtls/md.h"
+#include "mbedtls/ssl.h"
+#include "mbedtls/version.h"
+
+#define PAL_CRYPT_MAX_LABEL_SEED_LENGTH     (96U)
+//lint --e{818, 715, 830} suppress "argument "p_pal_crypt" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_tls_prf_sha256(pal_crypt_t* p_pal_crypt,
+                                      const uint8_t * p_secret,
+                                      uint16_t secret_length,
+                                      const uint8_t * p_label,
+                                      uint16_t label_length,
+                                      const uint8_t * p_seed,
+                                      uint16_t seed_length,
+                                      uint8_t * p_derived_key,
+                                      uint16_t derived_key_length)
+{
+    #define PAL_CRYPT_DIGEST_MAX_SIZE    (32U)
+
+    pal_status_t return_value = PAL_STATUS_FAILURE;
+    uint8_t message_digest_length = PAL_CRYPT_DIGEST_MAX_SIZE;
+    uint16_t derive_key_len_index, hmac_checksum_result_index;
+    uint16_t hmac_result_length;
+    uint8_t md_hmac_temp_array[PAL_CRYPT_MAX_LABEL_SEED_LENGTH + PAL_CRYPT_DIGEST_MAX_SIZE];
+    uint8_t hmac_checksum_result[PAL_CRYPT_DIGEST_MAX_SIZE];
+    const mbedtls_md_info_t *message_digest_info;
+    mbedtls_md_context_t message_digest_context;
+    uint16_t final_seed_length = 0;
+       
+    mbedtls_md_init(&message_digest_context);
+    
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == p_secret) || (NULL == p_label) || (NULL == p_seed) || (NULL == p_derived_key))
+        {
+            break;
+        }
+#endif  //OPTIGA_LIB_DEBUG_NULL_CHECK
+
+        if (sizeof(md_hmac_temp_array ) < (uint32_t)(message_digest_length + label_length + seed_length))
+        {
+            return_value = PAL_STATUS_INVALID_INPUT;
+            break;
+        }
+
+        message_digest_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
+
+        memcpy(md_hmac_temp_array + message_digest_length, p_label, label_length);
+        memcpy(md_hmac_temp_array + message_digest_length + label_length, p_seed, seed_length);
+        final_seed_length = label_length + seed_length;
+
+        if (0 != (mbedtls_md_setup(&message_digest_context,message_digest_info,1)))
+        {
+            return_value = PAL_STATUS_INVALID_INPUT;
+            break;
+        }
+
+        if (0 != mbedtls_md_hmac_starts(&message_digest_context, p_secret, secret_length))
+        {
+            break;
+        }
+       
+        if (0 != mbedtls_md_hmac_update(&message_digest_context, md_hmac_temp_array + message_digest_length, final_seed_length))
+        {
+            break;
+        }
+        
+        if (0 != mbedtls_md_hmac_finish(&message_digest_context, md_hmac_temp_array))
+        {
+            break;
+        }
+
+        for (derive_key_len_index = 0; derive_key_len_index < derived_key_length; 
+             derive_key_len_index += message_digest_length)
+        {
+            if (0 != mbedtls_md_hmac_reset(&message_digest_context))
+            {
+                break;
+            }
+            if (0 != mbedtls_md_hmac_update(&message_digest_context, md_hmac_temp_array, 
+                            message_digest_length + final_seed_length))
+            {
+                break;                
+            }
+            if (0 != mbedtls_md_hmac_finish(&message_digest_context, hmac_checksum_result))
+            {
+                break;                                
+            }
+
+            if (0 != mbedtls_md_hmac_reset(&message_digest_context))
+            {
+                break;                
+            }
+            if (0 != mbedtls_md_hmac_update(&message_digest_context, md_hmac_temp_array, message_digest_length))
+            {
+                break;                                
+            }
+            if (0 != mbedtls_md_hmac_finish(&message_digest_context, md_hmac_temp_array))
+            {
+                break;                                
+            }
+
+            hmac_result_length = ((derive_key_len_index + message_digest_length) > derived_key_length) ? 
+                                  (derived_key_length % message_digest_length) : (message_digest_length);
+
+            for (hmac_checksum_result_index = 0; hmac_checksum_result_index < hmac_result_length; 
+                 hmac_checksum_result_index++)
+            {
+                p_derived_key[derive_key_len_index + hmac_checksum_result_index] = 
+                                                                    hmac_checksum_result[hmac_checksum_result_index];
+            }
+        }
+        if (derive_key_len_index >= derived_key_length)
+        {
+            return_value = PAL_STATUS_SUCCESS;
+        }
+    } while (FALSE);
+    
+    mbedtls_md_free(&message_digest_context);
+
+    memset(md_hmac_temp_array, 0x00, sizeof(md_hmac_temp_array));
+    memset(hmac_checksum_result, 0x00, sizeof(hmac_checksum_result));    
+    #undef PAL_CRYPT_DIGEST_MAX_SIZE
+    return return_value;
+}
+
+//lint --e{818, 715, 830} suppress "argument "p_pal_crypt" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_encrypt_aes128_ccm(pal_crypt_t* p_pal_crypt,
+                                          const uint8_t * p_plain_text,
+                                          uint16_t plain_text_length,
+                                          const uint8_t * p_encrypt_key,
+                                          const uint8_t * p_nonce,
+                                          uint16_t nonce_length,
+                                          const uint8_t * p_associated_data,
+                                          uint16_t associated_data_length,
+                                          uint8_t mac_size,
+                                          uint8_t * p_cipher_text)
+{
+    #define AES128_KEY_BITS_SIZE    (16U)
+    #define MAC_TAG_BUFFER_SIZE     (16U)
+    
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+    uint8_t mac_output[MAC_TAG_BUFFER_SIZE];
+    mbedtls_ccm_context sEncrypt;
+
+    mbedtls_ccm_init(&sEncrypt);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == p_cipher_text) || (NULL == p_plain_text) ||
+            (NULL == p_nonce) || (NULL == p_associated_data) || (NULL == p_encrypt_key))
+        {
+            break;
+        }
+#endif
+
+        if (0 != mbedtls_ccm_setkey(&sEncrypt, MBEDTLS_CIPHER_ID_AES, p_encrypt_key, 8 * AES128_KEY_BITS_SIZE))
+        {
+            break;
+        }
+        
+        if (0 != mbedtls_ccm_encrypt_and_tag(&sEncrypt,
+                                              plain_text_length,
+                                              p_nonce,
+                                              nonce_length,
+                                              p_associated_data,
+                                              associated_data_length,
+                                              p_plain_text,
+                                              p_cipher_text,
+                                              mac_output,
+                                              mac_size))
+        
+        {
+            break;
+        }
+
+        memcpy((p_cipher_text + plain_text_length), mac_output, mac_size);
+        return_status = PAL_STATUS_SUCCESS;
+    } while (FALSE);
+    mbedtls_ccm_free(&sEncrypt);
+    #undef AES128_KEY_BITS_SIZE
+    #undef MAC_TAG_BUFFER_SIZE    
+    return return_status;
+}
+
+//lint --e{818, 715, 830} suppress "argument "p_pal_crypt" is not used in the implementation but kept for future use"
+pal_status_t pal_crypt_decrypt_aes128_ccm(pal_crypt_t* p_pal_crypt,
+                                          const uint8_t * p_cipher_text,
+                                          uint16_t cipher_text_length,
+                                          const uint8_t * p_decrypt_key,
+                                          const uint8_t * p_nonce,
+                                          uint16_t nonce_length,
+                                          const uint8_t * p_associated_data,
+                                          uint16_t associated_data_length,
+                                          uint8_t mac_size,
+                                          uint8_t * p_plain_text)
+{
+    #define AES128_KEY_BITS_SIZE    (16U)
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+    mbedtls_ccm_context sDecrypt;
+
+    mbedtls_ccm_init(&sDecrypt);
+
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == p_plain_text) || (NULL == p_cipher_text) ||
+            (NULL == p_nonce) || (NULL == p_associated_data) || (NULL == p_decrypt_key))
+        {
+            break;
+        }
+#endif
+
+        if (0 != mbedtls_ccm_setkey(&sDecrypt, MBEDTLS_CIPHER_ID_AES, p_decrypt_key, 8 * AES128_KEY_BITS_SIZE))
+        {
+            break;
+        }
+
+        if (0 != mbedtls_ccm_auth_decrypt(&sDecrypt,
+                                          (cipher_text_length - mac_size),
+                                          p_nonce,
+                                          nonce_length,
+                                          p_associated_data,
+                                          associated_data_length,
+                                          p_cipher_text,
+                                          p_plain_text, 
+                                          &p_cipher_text[cipher_text_length - mac_size],
+                                          mac_size))
+        {
+            break;
+        }
+        return_status = PAL_STATUS_SUCCESS;
+    } while (FALSE);
+    mbedtls_ccm_free(&sDecrypt);
+    #undef AES128_KEY_BITS_SIZE
+    return return_status;
+}
+
+pal_status_t pal_crypt_version(uint8_t * p_crypt_lib_version_info, uint16_t * length)
+{
+    pal_status_t return_value  = PAL_STATUS_FAILURE;    
+    uint8_t sizeof_version_number  = (uint8_t)strlen(MBEDTLS_VERSION_STRING);
+
+    do
+    {
+        if (sizeof_version_number > *length)
+        {
+            break;
+        }
+
+        pal_os_memcpy(p_crypt_lib_version_info, MBEDTLS_VERSION_STRING, sizeof_version_number);
+        *length = sizeof_version_number;
+
+        return_value = PAL_STATUS_SUCCESS;
+
+    } while (0);
+    return return_value;
+}
+
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/pal/pal_crypt_wolfssl.c b/3rdparty/experimental/optiga/pal/pal_crypt_wolfssl.c
new file mode 100644
index 000000000..4a2d7ae4e
--- /dev/null
+++ b/3rdparty/experimental/optiga/pal/pal_crypt_wolfssl.c
@@ -0,0 +1,230 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2020 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_crypt_wolfssl.c
+*
+* \brief   This file implements the platform abstraction layer(pal) APIs for cryptographic functions.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_crypt.h"
+#include "optiga/pal/pal_os_memory.h"
+
+/// @cond hidden
+//lint --e{123,617,537} suppress "Suppress ctype.h in Keil + Warning mpi_class.h is both a module and an include file + Repeated include"
+#include <wolfssl/wolfcrypt/aes.h>
+#include <wolfssl/optiga_wolfssl_tls.h>
+/// @endcond
+
+pal_status_t pal_crypt_tls_prf_sha256(pal_crypt_t* p_pal_crypt,
+                                      const uint8_t * p_secret,
+                                      uint16_t secret_length,
+                                      const uint8_t * p_label,
+                                      uint16_t label_length,
+                                      const uint8_t * p_seed,
+                                      uint16_t seed_length,
+                                      uint8_t * p_derived_key,
+                                      uint16_t derived_key_length)
+{
+    pal_status_t return_value = PAL_STATUS_FAILURE;
+    
+    (void )p_pal_crypt;
+    
+    #define SHA256_ALGORITHM            (4U)
+    do
+    {
+    #ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == p_secret) || (NULL == p_label) || (NULL == p_seed) || (NULL == p_derived_key))
+        {
+            break;
+        }
+    #endif
+        //Calling PRF function
+        if (0 != (int32_t)PRF(p_derived_key,
+                              derived_key_length,
+                              p_secret,
+                              secret_length,
+                              p_label,
+                              label_length,
+                              p_seed,
+                              seed_length,
+                              TRUE,
+                              SHA256_ALGORITHM))
+
+        {
+            break;
+        }
+
+        return_value = PAL_STATUS_SUCCESS;
+    } while (0);
+    #undef SHA256_ALGORITHM
+    return return_value;
+}
+
+pal_status_t pal_crypt_encrypt_aes128_ccm(pal_crypt_t* p_pal_crypt,
+                                          const uint8_t * p_plain_text,
+                                          uint16_t plain_text_length,
+                                          const uint8_t * p_encrypt_key,
+                                          const uint8_t * p_nonce,
+                                          uint16_t nonce_length,
+                                          const uint8_t * p_associated_data,
+                                          uint16_t associated_data_length,
+                                          uint8_t mac_size,
+                                          uint8_t * p_cipher_text)
+{
+    pal_status_t return_value = PAL_STATUS_FAILURE;
+    Aes encrypt;
+    uint8_t mac_output[16];
+        
+    (void )p_pal_crypt;
+    
+    #define AES128_KEY_SIZE         (16U)
+        
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == p_cipher_text) || (NULL == p_plain_text) ||
+            (NULL == p_nonce) || (NULL == p_associated_data) || (NULL == p_encrypt_key))
+        {
+            break;
+        }
+#endif
+
+        if (0 != wc_AesCcmSetKey(&encrypt, p_encrypt_key, AES128_KEY_SIZE))
+        {
+            break;
+        }
+        if (0 != wc_AesCcmEncrypt(&encrypt,
+                                  p_cipher_text,
+                                  p_plain_text,
+                                  plain_text_length,
+                                  p_nonce,
+                                  nonce_length,
+                                  mac_output,
+                                  mac_size,
+                                  p_associated_data,
+                                  associated_data_length))
+
+        {
+          break;
+        }
+
+        pal_os_memcpy((p_cipher_text + plain_text_length), mac_output, mac_size);
+        return_value = PAL_STATUS_SUCCESS;
+    } while (FALSE);
+    #undef AES128_KEY_SIZE
+    return return_value;
+}
+
+pal_status_t pal_crypt_decrypt_aes128_ccm(pal_crypt_t* p_pal_crypt,
+                                          const uint8_t * p_cipher_text,
+                                          uint16_t cipher_text_length,
+                                          const uint8_t * p_decrypt_key,
+                                          const uint8_t * p_nonce,
+                                          uint16_t nonce_length,
+                                          const uint8_t * p_associated_data,
+                                          uint16_t associated_data_length,
+                                          uint8_t mac_size,
+                                          uint8_t * p_plain_text)
+{
+    pal_status_t return_value = PAL_STATUS_FAILURE;
+    Aes decrypt;
+
+    (void )p_pal_crypt;
+    
+    #define AES128_KEY_SIZE     (16U)
+    do
+    {
+#ifdef OPTIGA_LIB_DEBUG_NULL_CHECK
+        if ((NULL == p_plain_text) || (NULL == p_cipher_text) ||
+            (NULL == p_nonce) || (NULL == p_associated_data) || (NULL == p_decrypt_key))
+        {
+            break;
+        }
+#endif
+        if (0 != wc_AesCcmSetKey(&decrypt, p_decrypt_key, AES128_KEY_SIZE))
+        {
+            break;
+        }
+
+
+        if (0 != wc_AesCcmDecrypt(&decrypt,
+                                  p_plain_text,
+                                  p_cipher_text,
+                                  (cipher_text_length - mac_size),
+                                  p_nonce,
+                                  nonce_length,
+                                  &p_cipher_text[cipher_text_length - mac_size],
+                                  mac_size,
+                                  p_associated_data,
+                                  associated_data_length))
+        {
+            break;
+        }
+
+        return_value = PAL_STATUS_SUCCESS;
+    } while (FALSE);
+    #undef AES128_KEY_SIZE
+    return return_value;
+}
+
+pal_status_t pal_crypt_version(uint8_t * p_crypt_lib_version_info, uint16_t * length)
+{
+    pal_status_t return_value  = PAL_STATUS_FAILURE;    
+    uint8_t sizeof_version_number  = (uint8_t)strlen(LIBWOLFSSL_VERSION_STRING);
+    do
+    {        
+        if (sizeof_version_number > *length)
+        {
+            break;
+        }
+
+        pal_os_memcpy(p_crypt_lib_version_info, LIBWOLFSSL_VERSION_STRING, sizeof_version_number);
+        *length = sizeof_version_number;
+
+        return_value = PAL_STATUS_SUCCESS;
+
+    }while (0);
+    return return_value;
+}
+
+/// @cond hidden
+//lint --e{715,830,818} suppress "As this is reference api to be implemented by the user to generate random number from wolfssl"
+int32_t CryptoLib_GenerateSeed(uint8_t * PpbSeed, uint32_t PdwSeedLength)
+{
+    int32_t i4Status  = 0;
+    //"User need to write an Platform specific wc_GenerateSeed() here"
+    return i4Status;
+}
+/// @endcond 
+/**
+* @}
+*/
diff --git a/3rdparty/experimental/optiga/projects/esp32_alios/Config.in b/3rdparty/experimental/optiga/projects/esp32_alios/Config.in
new file mode 100644
index 000000000..ca3c7757e
--- /dev/null
+++ b/3rdparty/experimental/optiga/projects/esp32_alios/Config.in
@@ -0,0 +1,9 @@
+config AOS_COMP_OPTIGA
+    bool "Root of trust, OPTIGA"
+    default n
+    help
+    Select if optiga_se_adapter is enabled
+
+#if AOS_COMP_OPTIGA
+# Configurations for component optiga
+#endif
\ No newline at end of file
diff --git a/3rdparty/experimental/optiga/projects/esp32_alios/aos.mk b/3rdparty/experimental/optiga/projects/esp32_alios/aos.mk
new file mode 100644
index 000000000..3d6234b74
--- /dev/null
+++ b/3rdparty/experimental/optiga/projects/esp32_alios/aos.mk
@@ -0,0 +1,49 @@
+
+NAME := optiga
+
+$(NAME)_MBINS_TYPE := app
+$(NAME)_VERSION := 1.0.0
+$(NAME)_SUMMARY := infineon optiga host library implimentation
+#$(NAME)_COMPONENTS := imbedtls alicrypto
+
+LIBOPTIGA := ./../..
+
+$(NAME)_INCLUDES     += $(LIBOPTIGA)/optiga/include
+$(NAME)_INCLUDES     += ../../../utility/mbedtls/include
+$(NAME)_INCLUDES     += $(LIBOPTIGA)/externals/wolfssl
+$(NAME)_INCLUDES     += $(LIBOPTIGA)/externals/wolfssl/wolfcrypt
+GLOBAL_INCLUDES += $(ESP_INC_PATH)/driver/include
+#$(NAME)_INCLUDES     += $(LIBOPTIGA)/externals/mbedtls/include/ 
+
+ifeq ($(AOS_COMP_OPTIGA), y)
+$(NAME)_DEFINES     += WOLFSSL_ESP32_OPTIGA=1
+endif
+
+$(NAME)_SOURCES += \
+    $(LIBOPTIGA)/optiga/cmd/optiga_cmd.c \
+    $(LIBOPTIGA)/optiga/util/optiga_util.c \
+    $(LIBOPTIGA)/optiga/crypt/optiga_crypt.c \
+    $(LIBOPTIGA)/optiga/common/optiga_lib_common.c \
+    $(LIBOPTIGA)/optiga/common/optiga_lib_logger.c \
+    $(LIBOPTIGA)/optiga/comms/optiga_comms_ifx_i2c.c \
+    $(LIBOPTIGA)/optiga/comms/ifx_i2c/ifx_i2c.c \
+    $(LIBOPTIGA)/optiga/comms/ifx_i2c/ifx_i2c_config.c \
+    $(LIBOPTIGA)/optiga/comms/ifx_i2c/ifx_i2c_data_link_layer.c \
+    $(LIBOPTIGA)/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c \
+    $(LIBOPTIGA)/optiga/comms/ifx_i2c/ifx_i2c_presentation_layer.c \
+    $(LIBOPTIGA)/optiga/comms/ifx_i2c/ifx_i2c_transport_layer.c \
+    $(LIBOPTIGA)/examples/optiga/usecases/example_ali_id2_key_update.c \
+    $(LIBOPTIGA)/examples/optiga/usecases/example_ali_id2_rsa_key_update.c \
+    $(LIBOPTIGA)/pal/esp32/pal.c \
+    $(LIBOPTIGA)/pal/esp32/pal_gpio.c \
+    $(LIBOPTIGA)/pal/esp32/pal_i2c.c \
+    $(LIBOPTIGA)/pal/esp32/pal_ifx_i2c_config.c \
+    $(LIBOPTIGA)/pal/esp32/pal_logger.c \
+    $(LIBOPTIGA)/pal/esp32/pal_os_datastore.c \
+    $(LIBOPTIGA)/pal/esp32/pal_os_event.c \
+    $(LIBOPTIGA)/pal/esp32/pal_os_lock.c \
+    $(LIBOPTIGA)/pal/esp32/pal_os_memory.c \
+    $(LIBOPTIGA)/pal/esp32/pal_os_random.c \
+    $(LIBOPTIGA)/pal/esp32/pal_os_timer.c \
+
+
diff --git a/app/example/mqttapp/app_entry.c b/app/example/mqttapp/app_entry.c
index a0d20f675..f72df08dd 100644
--- a/app/example/mqttapp/app_entry.c
+++ b/app/example/mqttapp/app_entry.c
@@ -57,7 +57,7 @@ int application_start(int argc, char **argv)
 #ifdef CSP_LINUXHOST
     signal(SIGPIPE, SIG_IGN);
 #endif
-
+//example_optiga_util_ali_id2_aes_key_update();
 #ifdef TEST_LOOP
     argc = 2;
     argv = (char **)input_data;
diff --git a/app/example/mqttapp/mqtt_example.c b/app/example/mqttapp/mqtt_example.c
index 16aab793a..af7c6a6c2 100644
--- a/app/example/mqttapp/mqtt_example.c
+++ b/app/example/mqttapp/mqtt_example.c
@@ -11,10 +11,10 @@
 #include "iot_export.h"
 #include "app_entry.h"
 
-#define PRODUCT_KEY             "a1MZxOdcBnO"
-#define PRODUCT_SECRET          "h4I4dneEFp7EImTv"
-#define DEVICE_NAME             "test_01"
-#define DEVICE_SECRET           "t9GmMf2jb3LgWfXBaZD2r3aJrfVWBv56"
+#define PRODUCT_KEY      "a1FCMDh4ypx"
+#define PRODUCT_SECRET   "i11LJA9Bk0OCedcXtG0B5EBE8F137FFE"
+#define DEVICE_NAME      "IFXDeviceMqttTest"
+#define DEVICE_SECRET    "4SOUvFBwztKwrWSrq5qPGHKDZ35z2CE1"
 
 /* These are pre-defined topics */
 #define TOPIC_UPDATE            "/"PRODUCT_KEY"/"DEVICE_NAME"/update"
@@ -130,10 +130,11 @@ static void _demo_message_arrive(void *pcontext, void *pclient, iotx_mqtt_event_
             break;
     }
 }
-
+int cnt = 0;
 int mqtt_client(void)
 {
-    int rc, msg_len, cnt = 0;
+    uint16_t status;
+    int rc, msg_len;
     void *pclient;
     iotx_conn_info_pt pconn_info;
     iotx_mqtt_param_t mqtt_params;
@@ -230,7 +231,7 @@ int mqtt_client(void)
 
         topic_msg.payload = (void *)msg_pub;
         topic_msg.payload_len = msg_len;
-
+        EXAMPLE_TRACE("-----cnt = %d ------", cnt);
         rc = IOT_MQTT_Publish(pclient, TOPIC_DATA, &topic_msg);
         if (rc < 0) {
             EXAMPLE_TRACE("error occur when publish");
@@ -243,11 +244,10 @@ int mqtt_client(void)
         /* infinite loop if running with 'loop' argument */
         if (user_argc >= 2 && !strcmp("loop", user_argv[1])) {
             HAL_SleepMs(2000);
-            cnt = 0;
         }
-
-    } while (cnt < 1);
-
+        EXAMPLE_TRACE("-----cnt 1 = %d ------", cnt);
+    } while (1);
+    EXAMPLE_TRACE("-----cnt 2 = %d ------", cnt);
     IOT_MQTT_Yield(pclient, 200);
 
     IOT_MQTT_Unsubscribe(pclient, TOPIC_DATA);
diff --git a/board/esp32devkitc/Config.in b/board/esp32devkitc/Config.in
index bee088a5f..a5f5529c8 100644
--- a/board/esp32devkitc/Config.in
+++ b/board/esp32devkitc/Config.in
@@ -59,4 +59,12 @@ config BSP_SUPPORT_WDG
     bool
     default y
 
+# link security config
+config CONFIG_LS_DEBUG
+    bool
+    default n
+config CONFIG_LS_KM_SE
+    bool
+    default y
+
 endif
diff --git a/board/esp32devkitc/k_config.h b/board/esp32devkitc/k_config.h
index 7b4731c28..fcfff5446 100644
--- a/board/esp32devkitc/k_config.h
+++ b/board/esp32devkitc/k_config.h
@@ -71,7 +71,7 @@
 
 /* kernel timer&tick conf */
 #ifndef RHINO_CONFIG_TICKS_PER_SECOND
-#define RHINO_CONFIG_TICKS_PER_SECOND        100
+#define RHINO_CONFIG_TICKS_PER_SECOND        1000
 #endif
 #ifndef RHINO_CONFIG_TIMER_TASK_STACK_SIZE
 #define RHINO_CONFIG_TIMER_TASK_STACK_SIZE   768
diff --git a/build/build_rules/aos_target_config.mk b/build/build_rules/aos_target_config.mk
index 665f10d4f..94d8dbaed 100644
--- a/build/build_rules/aos_target_config.mk
+++ b/build/build_rules/aos_target_config.mk
@@ -18,6 +18,7 @@ CONFIG_FILE := $(CONFIG_FILE_DIR)/config.mk
 DEPENDENCY_DICT :=
 
 COMPONENT_DIRECTORIES := . \
+						 3rdparty/experimental/optiga/projects/esp32_alios	\
                          app/example   \
                          app/profile   \
                          board     \
diff --git a/build/build_rules/toolchain/aos_toolchain_xtensa.mk b/build/build_rules/toolchain/aos_toolchain_xtensa.mk
index 70225f9a9..3ece35b8f 100644
--- a/build/build_rules/toolchain/aos_toolchain_xtensa.mk
+++ b/build/build_rules/toolchain/aos_toolchain_xtensa.mk
@@ -51,7 +51,7 @@ OPTIONS_IN_FILE_OPTION    := @
 ADD_COMPILER_SPECIFIC_STANDARD_CFLAGS   = $(1) $(if $(filter yes,$(MXCHIP_INTERNAL) $(TESTER)),-Werror)
 ADD_COMPILER_SPECIFIC_STANDARD_CXXFLAGS = $(1) $(if $(filter yes,$(MXCHIP_INTERNAL) $(TESTER)),-Werror)
 ADD_COMPILER_SPECIFIC_STANDARD_ADMFLAGS = $(1)
-COMPILER_SPECIFIC_OPTIMIZED_CFLAGS    := -Os
+COMPILER_SPECIFIC_OPTIMIZED_CFLAGS    := -O0
 COMPILER_SPECIFIC_UNOPTIMIZED_CFLAGS  := -O0
 COMPILER_SPECIFIC_PEDANTIC_CFLAGS  := $(COMPILER_SPECIFIC_STANDARD_CFLAGS)
 COMPILER_SPECIFIC_ARFLAGS_CREATE   := -rcs
diff --git a/include/aos/hal/i2c.h b/include/aos/hal/i2c.h
index fe425ec0c..b68ea6629 100644
--- a/include/aos/hal/i2c.h
+++ b/include/aos/hal/i2c.h
@@ -52,6 +52,8 @@ typedef struct {
  */
 int32_t hal_i2c_init(i2c_dev_t *i2c);
 
+int32_t hal_i2c_get_status(i2c_dev_t * i2c);
+
 /**
  * I2c master send
  *
diff --git a/platform/mcu/esp32/aos.mk b/platform/mcu/esp32/aos.mk
index ce2cc1866..782c808a5 100644
--- a/platform/mcu/esp32/aos.mk
+++ b/platform/mcu/esp32/aos.mk
@@ -6,7 +6,7 @@ $(NAME)_MBINS_TYPE := kernel
 $(NAME)_VERSION    := 1.0.0
 $(NAME)_SUMMARY    := driver & sdk for platform/mcu esp32
 
-$(NAME)_COMPONENTS += lwip alicrypto imbedtls netmgr
+$(NAME)_COMPONENTS += lwip alicrypto netmgr
 
 ESP_INC_PATH    := bsp/include
 GLOBAL_INCLUDES += $(ESP_INC_PATH)
diff --git a/platform/mcu/esp32/hal/i2c.c b/platform/mcu/esp32/hal/i2c.c
index d59604fb6..9ff9d9e7d 100644
--- a/platform/mcu/esp32/hal/i2c.c
+++ b/platform/mcu/esp32/hal/i2c.c
@@ -17,6 +17,8 @@
 #include "soc/i2c_struct.h"
 #include "soc/dport_reg.h"
 #include "driver/gpio.h"
+#include "ulog/ulog.h"
+#include "ulog_api.h"
 
 #define	 I2C_CMD_MAX		(16u)
 
@@ -43,7 +45,7 @@ typedef struct i2c_resource {
 
 
 static i2c_resource_t g_dev[I2C_NUM_MAX] = {
-    {(volatile i2c_dev_t *)0x60013000,23,22},
+    {(volatile i2c_dev_t *)0x60013000,22,21},
     {(volatile i2c_dev_t *)0x60027000,19,18}
 };
 
@@ -201,15 +203,24 @@ static int32_t i2c_write_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width
     uint16_t send_counts = 0;
     uint16_t packet_size = 0;
     uint16_t send_len = 0;
+    uint8_t index = 0;
+    uint8_t count = 0;
+    unsigned long long start;
+
+    i2c_start_prepare(handle);
+    index += 1;
+    i2c_config_cmd(handle,0,I2C_CMD_RSTART,0,false,false,false);
+    i2c_send_addr(handle,1,dev_addr,add_width);
+    while(handle->status_reg.tx_fifo_cnt < index);
+
     while(total_size) {
-        packet_size = (total_size > 32) ? 32 : total_size;
+        packet_size = (total_size > 28) ? 28 : total_size;
+
+
         send_len = packet_size;
-        i2c_start_prepare(handle);
-        i2c_config_cmd(handle,0,I2C_CMD_RSTART,0,false,false,false);
         uint8_t index = 0;
         while(send_len) {
             if(0 == send_counts) {
-                i2c_send_addr(handle,1,dev_addr,add_width);
                 send_len -= (add_width)?(2):(1);
             }
             index += 1;
@@ -218,16 +229,31 @@ static int32_t i2c_write_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width
             send_counts += 1;
             send_len -= 1;
         }
-        i2c_config_cmd(handle,1,I2C_CMD_WRITE,packet_size,true,false,false);
+        //send_len -= 1;
+        if(count == 0) {
+            i2c_config_cmd(handle,1,I2C_CMD_WRITE,packet_size,true,false,false);
+        } else {
+            i2c_config_cmd(handle,0,I2C_CMD_WRITE,packet_size,true,false,false);
+        }
+
         total_size -= packet_size;
 
-        if(total_size || !need_stop) {
-            i2c_config_cmd(handle,2,I2C_CMD_END,0,false,false,false);
-        } else if(need_stop) {
+        if(total_size) {
+            if (count == 0)
+            {
+                i2c_config_cmd(handle,2,I2C_CMD_END,0,false,false,false);
+            }
+            else
+            {
+                i2c_config_cmd(handle,1,I2C_CMD_END,0,false,false,false);
+            }
+              
+            count++;
+        } else if(len <= 28 ) {
             i2c_config_cmd(handle,2,I2C_CMD_STOP,0,false,false,false);
         }
         handle->ctr.trans_start = 1;
-        unsigned long long start = krhino_sys_time_get();
+        start = krhino_sys_time_get();
         do {
             if(0 != i2c_check_status(handle)) {
                 break;
@@ -236,13 +262,28 @@ static int32_t i2c_write_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width
                 break;
             }
         } while(krhino_sys_time_get()-start < 20);
+
+        if(count > 1 && total_size == 0)
+        {
+            i2c_config_cmd(handle,0,I2C_CMD_STOP,0,false,false,false);
+            handle->ctr.trans_start = 1;
+            start = krhino_sys_time_get();
+            do {
+                if(0 != i2c_check_status(handle)) {
+                    break;
+                }
+                if((need_stop && handle->command[2].done) || !handle->status_reg.bus_busy) {
+                    break;
+                }
+            } while(krhino_sys_time_get()-start < 20);
+        }
     }
 
     return 0;
 
 }
 
-
+static uint8_t temp_count = 0;
 static int32_t i2c_read_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width,uint8_t * buff,uint32_t len,int8_t need_stop)
 {
     if(NULL == handle || NULL == buff || len == 0) {
@@ -256,7 +297,13 @@ static int32_t i2c_read_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width,
     uint8_t nextCmdCount = 0;
     uint8_t currentCmdIdx = 0;
     uint8_t cmd_index = 0;
+    uint32_t fifo_cnt = 0, requested_len = 0, received_len = 0;
+    uint32_t i;
     uint16_t dev_addr = (addr << 1) | 1;
+    volatile uint8_t temp_len;
+    uint8_t count = 0;
+
+    memset (buff, 0, len);
     i2c_start_prepare(handle);
     i2c_config_cmd(handle,cmd_index,I2C_CMD_RSTART,0,false,false,false);
     cmd_index = (cmd_index+1)%I2C_CMD_MAX;
@@ -265,6 +312,7 @@ static int32_t i2c_read_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width,
     cmd_index = (cmd_index+1)%I2C_CMD_MAX;
     nextCmdCount = cmd_index;
     handle->ctr.trans_start = 1;
+
     while(is_run) {
         uint32_t startAt = krhino_sys_time_get();
         do {
@@ -276,9 +324,17 @@ static int32_t i2c_read_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width,
             if(handle->command[currentCmdIdx].done) {
                 nextCmdCount--;
                 if (handle->command[currentCmdIdx].op_code == I2C_CMD_READ) {
-                    if(currentCmdIdx >= 2) {
+                    while(fifo_cnt != requested_len)
+                    {
+                        for (i = 0; i < 400; i++);
+                        fifo_cnt = handle->status_reg.rx_fifo_cnt;
+                    }
+                    while(count < fifo_cnt)
+                    {
                         buff[index++] = handle->fifo_data.val & 0xFF;
+                        count++;
                     }
+                    //requested_len -= fifo_cnt;
                     handle->fifo_conf.tx_fifo_rst = 1;
                     handle->fifo_conf.tx_fifo_rst = 0;
                     handle->fifo_conf.rx_fifo_rst = 1;
@@ -289,15 +345,25 @@ static int32_t i2c_read_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width,
                 }
                 currentCmdIdx = (currentCmdIdx+1)%I2C_CMD_MAX;
                 if(nextCmdCount < 2) {
-                    if(len > 0) {
+                    if(len > 1) {
+                        temp_len = (len > 19)? 19:(len-1);
+                        i2c_config_cmd(handle, cmd_index, I2C_CMD_READ, temp_len, false, false, false);
+                        cmd_index = (cmd_index+1)%I2C_CMD_MAX;
+                        nextCmdCount++;
+                        len -= temp_len;
+                        requested_len += temp_len;
+                    } else if(len == 1) {
                         i2c_config_cmd(handle, cmd_index, I2C_CMD_READ, 1, false, false, (len==1));
                         cmd_index = (cmd_index+1)%I2C_CMD_MAX;
                         nextCmdCount++;
                         len -= 1;
+                        temp_len = 1;
+                        requested_len += temp_len;
                     } else {
                         i2c_config_cmd(handle, cmd_index, I2C_CMD_STOP, 0, false, false, false);
                         cmd_index = (cmd_index+1)%I2C_CMD_MAX;
                         nextCmdCount++;
+                        temp_len = 0;
                     }
                 }
                 break;
@@ -308,7 +374,6 @@ static int32_t i2c_read_bytes(i2c_dev_t * handle,uint16_t addr,int8_t add_width,
     return (0);
 }
 
-
 int32_t hal_i2c_init(aos_i2c_dev_t *i2c)
 {
     int32_t ret = 0;
@@ -322,6 +387,22 @@ int32_t hal_i2c_init(aos_i2c_dev_t *i2c)
     return ret;
 }
 
+int32_t hal_i2c_get_status(aos_i2c_dev_t * i2c)
+{
+    int32_t ret = 0;
+
+    if(NULL == i2c || (I2C_NUM_0 != i2c->port)&&(I2C_NUM_1 != i2c->port)) {
+        return (-1);
+    }
+    
+    i2c_dev_t * handle =  g_dev[i2c->port].dev;
+
+    if(0 != i2c_check_status(handle)) {
+        ret = -1;
+    }
+    return ret;
+}
+
 int32_t hal_i2c_master_send(aos_i2c_dev_t *i2c, uint16_t dev_addr, const uint8_t *data,uint16_t size, uint32_t timeout)
 {
     int32_t ret = 0;
@@ -330,7 +411,7 @@ int32_t hal_i2c_master_send(aos_i2c_dev_t *i2c, uint16_t dev_addr, const uint8_t
     }
     i2c_resource_t * resource = &g_dev[i2c->port];
     uint16_t addr = dev_addr >> 1;
-    i2c_write_bytes(resource->dev,addr,i2c->config.address_width == I2C_MEM_ADDR_SIZE_16BIT,(uint8_t *)data,size,0);
+    ret = i2c_write_bytes(resource->dev,addr,i2c->config.address_width == I2C_MEM_ADDR_SIZE_16BIT,(uint8_t *)data,size,0);
 
     return ret;
 }
@@ -343,7 +424,7 @@ int32_t hal_i2c_master_recv(aos_i2c_dev_t *i2c, uint16_t dev_addr, uint8_t *data
     }
     i2c_resource_t * resource = &g_dev[i2c->port];
     uint16_t addr = dev_addr >> 1;
-    i2c_read_bytes(resource->dev,addr,i2c->config.address_width == I2C_MEM_ADDR_SIZE_16BIT,(uint8_t *)data,size,0);
+    ret = i2c_read_bytes(resource->dev,addr,i2c->config.address_width == I2C_MEM_ADDR_SIZE_16BIT,(uint8_t *)data,size,0);
 
     return ret;
 }
diff --git a/security/Config.in b/security/Config.in
index fdaa3e649..5206a3e6b 100644
--- a/security/Config.in
+++ b/security/Config.in
@@ -6,13 +6,14 @@ source "security/ls_hal/Config.in"
 source "security/alicrypto/Config.in"
 source "security/dpm/Config.in"
 source "security/id2/Config.in"
+source "3rdparty/experimental/optiga/projects/esp32_alios/Config.in"
 source "security/irot/Config.in"
 source "security/irot/km/Config.in"
 source "security/irot/se/Config.in"
 source "security/irot/tee/Config.in"
 source "security/isst/Config.in"
 source "security/itls/Config.in"
-source "security/mbedtls/Config.in"
+## source "security/mbedtls/Config.in"
 source "security/prov/Config.in"
 ## --- End ---
 
diff --git a/security/id2/aos.mk b/security/id2/aos.mk
index eee0d8d27..c88359686 100644
--- a/security/id2/aos.mk
+++ b/security/id2/aos.mk
@@ -10,7 +10,7 @@ RPM_INCLUDE_DIR := ../include/id2
 #id2 config
 
 ifeq ($(CONFIG_LS_KM_SE), y)
-$(NAME)_DEFINES     += ID2_CRYPTO_TYPE_CONFIG=ID2_CRYPTO_TYPE_3DES
+$(NAME)_DEFINES     += ID2_CRYPTO_TYPE_CONFIG=ID2_CRYPTO_TYPE_AES
 else ifeq ($(CONFIG_LS_KM_TEE), y)
 $(NAME)_DEFINES     += ID2_CRYPTO_TYPE_CONFIG=ID2_CRYPTO_TYPE_AES
 else
diff --git a/security/irot/Config.in b/security/irot/Config.in
index 006fb2ccf..b6bfbf528 100644
--- a/security/irot/Config.in
+++ b/security/irot/Config.in
@@ -1,9 +1,9 @@
 config AOS_COMP_IROT
     bool "Root of Trust - MCU, SE and TEE"
     default n
-    select AOS_COMP_LIBKM_SE if CONFIG_LS_KM_SE
-    select AOS_COMP_LIBKM_TEE if !CONFIG_LS_KM_SE && CONFIG_LS_KM_TEE
-    select AOS_COMP_LIBKM if !CONFIG_LS_KM_SE && !CONFIG_LS_KM_TEE
+    #select AOS_COMP_LIBKM_SE if CONFIG_LS_KM_SE
+    #select AOS_COMP_LIBKM_TEE if !CONFIG_LS_KM_SE && CONFIG_LS_KM_TEE
+    #select AOS_COMP_LIBKM if !CONFIG_LS_KM_SE && !CONFIG_LS_KM_TEE
     help
 
 if AOS_COMP_IROT
diff --git a/security/irot/se/aos.mk b/security/irot/se/aos.mk
index afbdfae3e..009b3a90a 100644
--- a/security/irot/se/aos.mk
+++ b/security/irot/se/aos.mk
@@ -3,6 +3,7 @@ CHIPNAME = chip_template
 $(NAME)_MBINS_TYPE := kernel
 $(NAME)_VERSION := 1.0.0
 $(NAME)_SUMMARY := key management for se
+$(NAME)_COMPONENTS := alicrypto
 
 NAME := libkm_se
 
@@ -12,11 +13,13 @@ $(NAME)_INCLUDES     += $(LIBSE)/../../include/irot
 $(NAME)_INCLUDES     += $(LIBSE)/src
 $(NAME)_INCLUDES     += $(LIBSE)/chipset/$(CHIPNAME)/include
 $(NAME)_INCLUDES     += $(LIBSE)/chipset/$(CHIPNAME)
+$(NAME)_INCLUDES     += $(LIBSE)/../../../3rdparty/experimental/optiga/optiga/include 
 
 $(NAME)_SOURCES     += 			\
     $(LIBSE)/src/core/km_to_irot.c \
     $(LIBSE)/src/core/std_se_adapter.c \
     $(LIBSE)/src/core/mtk_se_adapter.c \
+    $(LIBSE)/src/core/optiga_se_adapter.c \
     $(LIBSE)/src/log/chiplog.c \
     $(LIBSE)/chipset/$(CHIPNAME)/irot_impl/irot_hal.c \
     $(LIBSE)/chipset/$(CHIPNAME)/se_driver_impl/se_driver.c \
diff --git a/security/irot/se/chipset/chip_template/chip_config.h b/security/irot/se/chipset/chip_template/chip_config.h
index b7b900ef3..989b10c43 100644
--- a/security/irot/se/chipset/chip_template/chip_config.h
+++ b/security/irot/se/chipset/chip_template/chip_config.h
@@ -19,6 +19,7 @@
 #define CHIP_TYPE_SECURE_MCU                1
 #define CHIP_TYPE_SE_STD_CMD                2
 #define CHIP_TYPE_SE_MTK_CMD                3
+#define CHIP_TYPE_SE_OPTIGA_CMD             4
 
 #define CHIP_CRYPTO_TYPE_3DES               1
 #define CHIP_CRYPTO_TYPE_AES                2
@@ -32,12 +33,12 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 
-#define CHIP_TYPE_CONFIG                    CHIP_TYPE_SE_STD_CMD
-#define CHIP_CRYPTO_TYPE_CONFIG             CHIP_CRYPTO_TYPE_3DES
+#define CHIP_TYPE_CONFIG                    CHIP_TYPE_SE_OPTIGA_CMD
+#define CHIP_CRYPTO_TYPE_CONFIG             CHIP_CRYPTO_TYPE_AES
 
 ////////////////////////////////////////////////////////////////////////////////
 
-#if ((CHIP_TYPE_CONFIG != CHIP_TYPE_SECURE_MCU) && (CHIP_TYPE_CONFIG != CHIP_TYPE_SE_STD_CMD) && (CHIP_TYPE_CONFIG != CHIP_TYPE_SE_MTK_CMD))
+#if ((CHIP_TYPE_CONFIG != CHIP_TYPE_SECURE_MCU) && (CHIP_TYPE_CONFIG != CHIP_TYPE_SE_STD_CMD) && (CHIP_TYPE_CONFIG != CHIP_TYPE_SE_MTK_CMD) && (CHIP_TYPE_CONFIG != CHIP_TYPE_SE_OPTIGA_CMD))
 #error("CHIP_TYPE_CONFIG error.");
 #endif
 
diff --git a/security/irot/se/src/core/km_to_irot.c b/security/irot/se/src/core/km_to_irot.c
index b8290c508..c58b3fae7 100644
--- a/security/irot/se/src/core/km_to_irot.c
+++ b/security/irot/se/src/core/km_to_irot.c
@@ -26,6 +26,9 @@ static void dump_chip_conf_info()
         case CHIP_TYPE_SE_MTK_CMD: {
             chip_log_debug("CHIP_TYPE_CONFIG           : %s\n", "CHIP_TYPE_SE_MTK_CMD");
         }
+        case CHIP_TYPE_SE_OPTIGA_CMD: {
+            chip_log_debug("CHIP_TYPE_CONFIG           : %s\n", "CHIP_TYPE_SE_OPTIGA_CMD");
+        }
         break;
         default: {
         } break;
diff --git a/security/irot/se/src/core/optiga_se_adapter.c b/security/irot/se/src/core/optiga_se_adapter.c
new file mode 100644
index 000000000..802bea84f
--- /dev/null
+++ b/security/irot/se/src/core/optiga_se_adapter.c
@@ -0,0 +1,702 @@
+/*
+ * Copyright (C) 2015-2018 Alibaba Group Holding Limited
+ */
+
+#include <stdio.h>
+//lint --e{766} suppress "string.h inclusion as its part of template"
+#include <string.h>
+#include "chip_config.h"
+#include "irot_hal.h"
+
+#if (CHIP_APDU_CMD_ADAPTER && (CHIP_TYPE_CONFIG == CHIP_TYPE_SE_OPTIGA_CMD))
+#include "optiga/optiga_util.h"
+#include "optiga/optiga_crypt.h"
+#include "optiga/pal/pal_os_timer.h"
+
+/* Macro to enable the OPTIGA chip to power off when irot_cleanup is invoked. By default, this MACRO is disabled.
+ * If the macro is enabled, the HOST waits until the security event counter on OPTIGA reaches 0 and then 
+ * closes the application on OPTIGA.
+ */
+//#define OPTIGA_SE_ENABLE_POWER_DOWN
+// Device id to store ID of the Ali ID2 device
+#define OPTIGA_SE_DEVICE_ID_OID         (0xF1D0)
+
+// Length of the Ali ID2 device id      
+#define OPTIGA_SE_DEVICE_ID_LEN         (12U)
+
+#if (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES)
+// Symmetric key object OID
+#define IROT_HAL_OPTIGA_KEY_OID         ((optiga_key_id_t)0xE200)
+#elif (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_RSA)
+// Asymmetric RSA key object OID
+#define IROT_HAL_OPTIGA_KEY_OID         ((optiga_key_id_t)0xE0FC)
+#else                                   
+#define IROT_HAL_OPTIGA_KEY_OID         ((optiga_key_id_t)0x0000)
+#endif
+
+// Mask for comms error
+#define OPTIGA_SE_LIB_ERROR_LAYER_MASK  (0xFF00)
+// Comms layer error code
+#define OPTIGA_SE_COMMS_LAYER_ERROR     (0x0100)
+// Maximum size of uint16_t
+#define OPTIGA_SE_MAX_OUTPUT_LENGTH     (0x0000FFFF)
+
+// static variable to store util instance
+_STATIC_H optiga_util_t * p_irot_hal_util_instance = NULL;
+// static variable to store crypt instance
+_STATIC_H optiga_crypt_t * p_irot_hal_crypt_instance = NULL;
+
+_STATIC_H volatile optiga_lib_status_t irot_hal_util_status;
+_STATIC_H volatile optiga_lib_status_t irot_hal_crypt_status;
+
+// IROT HAL initialization status
+_STATIC_H bool_t irot_hal_init_status = FALSE;
+
+//lint --e{818} suppress "argument "context" is not used in this usecase"
+_STATIC_H void irot_hal_util_callback(void * context, optiga_lib_status_t return_status)
+{
+    irot_hal_util_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+//lint --e{818} suppress "argument "context" is not used in this usecase"
+_STATIC_H void irot_hal_crypt_callback(void * context, optiga_lib_status_t return_status)
+{
+    irot_hal_crypt_status = return_status;
+    if (NULL != context)
+    {
+        // callback to upper layer here
+    }
+}
+
+irot_result_t irot_hal_init(void)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+
+    do
+    {
+        // If instances are already created, return success
+        if((NULL != p_irot_hal_util_instance) && (NULL != p_irot_hal_crypt_instance))
+        {
+            return_status = IROT_SUCCESS;
+            irot_hal_init_status = TRUE;
+            break;
+        }
+
+        // Create util instance
+        p_irot_hal_util_instance = optiga_util_create(0, irot_hal_util_callback, NULL);
+        if (NULL == p_irot_hal_util_instance)
+        {
+            break;
+        }
+
+        // Create crypt instance
+        p_irot_hal_crypt_instance = optiga_crypt_create(0, irot_hal_crypt_callback, NULL);
+        if (NULL == p_irot_hal_crypt_instance)
+        {
+            break;
+        }
+
+        // Power On OPTIGA and send Open Application command
+        irot_hal_util_status = OPTIGA_LIB_BUSY;
+
+        if (OPTIGA_LIB_SUCCESS != optiga_util_open_application(p_irot_hal_util_instance, 0))
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == irot_hal_util_status)
+        {
+            //Wait until the optiga_util_open_application is completed
+        }
+        //optiga util open application failed
+        if (OPTIGA_LIB_SUCCESS != irot_hal_util_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_util_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            break;
+        }
+        return_status = IROT_SUCCESS;
+        irot_hal_init_status = TRUE;
+    } while (FALSE);
+
+    if ((IROT_SUCCESS != return_status) && (NULL != p_irot_hal_crypt_instance))
+    {
+        (void)optiga_crypt_destroy(p_irot_hal_crypt_instance);
+        p_irot_hal_crypt_instance = NULL;
+    }
+
+    if ((IROT_SUCCESS != return_status) && (NULL != p_irot_hal_util_instance))
+    {
+        (void)optiga_util_destroy(p_irot_hal_util_instance);
+        p_irot_hal_util_instance = NULL;
+    }
+    return (return_status);
+}
+
+irot_result_t irot_hal_cleanup(void)
+{
+    irot_result_t return_status;
+    
+#ifdef OPTIGA_SE_ENABLE_POWER_DOWN
+    uint16_t bytes_to_read = 1;
+    uint8_t security_event_counter = 0;
+
+    do
+    {
+        // If instances are already destroyed, return success
+        if(FALSE == irot_hal_init_status)
+        {
+            return_status = IROT_SUCCESS;
+            break;
+        }
+        /**
+        * Before performing power down, SEC value should be 0
+        */
+        do
+        {
+            irot_hal_util_status = OPTIGA_LIB_BUSY;
+            return_status = IROT_ERROR_GENERIC;
+            if (OPTIGA_LIB_SUCCESS != optiga_util_read_data(p_irot_hal_util_instance,
+                                                    0xE0C5,
+                                                    0x0000,
+                                                    &security_event_counter,
+                                                    &bytes_to_read))
+            {
+                break;
+            }
+
+            while (OPTIGA_LIB_BUSY == irot_hal_util_status)
+            {
+                //Wait until the optiga_util_read_data operation is completed
+            }
+            //Reading the data object failed.
+            if (OPTIGA_LIB_SUCCESS != irot_hal_util_status)
+            {
+                break;
+            }
+
+            // Provide delay of 500ms in case SEC value is not equal to 0
+            if (0 != security_event_counter)
+            {
+                pal_os_timer_delay_in_milliseconds(500);
+            }
+        } while (0 != security_event_counter);
+
+        // Send Close Application command and Power Off OPTIGA
+        irot_hal_util_status = OPTIGA_LIB_BUSY;
+        return_status = IROT_ERROR_GENERIC;
+        if (OPTIGA_LIB_SUCCESS != optiga_util_close_application(p_irot_hal_util_instance, 0))
+        {
+            break;
+        }
+
+        while (irot_hal_util_status == OPTIGA_LIB_BUSY)
+        {
+        //Wait until the optiga_util_close_application is completed
+        }
+
+        //optiga util close application failed
+        if (OPTIGA_LIB_SUCCESS != irot_hal_util_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_util_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+
+    if ((NULL != p_irot_hal_crypt_instance) && OPTIGA_LIB_SUCCESS != optiga_crypt_destroy(p_irot_hal_crypt_instance))
+    {
+        if (IROT_SUCCESS == return_status)
+        {
+            return_status = IROT_ERROR_GENERIC;
+        }
+    }
+    p_irot_hal_crypt_instance = NULL;
+
+    if ((NULL != p_irot_hal_util_instance) && OPTIGA_LIB_SUCCESS != optiga_util_destroy(p_irot_hal_util_instance))
+    {
+        if (IROT_SUCCESS == return_status)
+        {
+            return_status = IROT_ERROR_GENERIC;
+        }
+    }
+    p_irot_hal_util_instance = NULL;
+#else
+    return_status = IROT_SUCCESS;
+#endif
+    irot_hal_init_status = FALSE;
+    return (return_status);
+}
+
+irot_result_t irot_hal_get_id2(uint8_t * id2, uint32_t * len)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+    
+    do
+    {
+        if (FALSE == irot_hal_init_status)
+        {
+            break;
+        }
+
+        // Check if the 'len' value passed is lesser than the minimum value Device ID length
+        if (OPTIGA_SE_DEVICE_ID_LEN > *len)
+        {
+            return_status = IROT_ERROR_SHORT_BUFFER;
+            break;
+        }
+        
+        // Check if the 'len' value passed is greater than the max length accepted by optiga_util_read_data
+        if (OPTIGA_SE_MAX_OUTPUT_LENGTH < *len)
+        {
+            *len = OPTIGA_SE_MAX_OUTPUT_LENGTH;
+        }
+        
+        irot_hal_util_status = OPTIGA_LIB_BUSY;
+        // Read device ID from the OID configured in OPTIGA_SE_DEVICE_ID_OID
+        if (OPTIGA_LIB_SUCCESS != optiga_util_read_data(p_irot_hal_util_instance,
+                                                        OPTIGA_SE_DEVICE_ID_OID,
+                                                        0x0000,
+                                                        id2,
+                                                        ((uint16_t * )(void * )len)))
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == irot_hal_util_status)
+        {
+            //Wait until the optiga_util_read_data operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_util_status)
+        {
+            do
+            {
+                if (OPTIGA_DEVICE_ERROR == (irot_hal_util_status & OPTIGA_DEVICE_ERROR))
+                {
+                    //Reading the device ID failed.
+                    return_status = IROT_ERROR_ITEM_NOT_FOUND;
+                    break;
+                }
+
+                if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_util_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+                {
+                    //Error from OPTIGA Comms.
+                    return_status = IROT_ERROR_COMMUNICATION;
+                    break;
+                }
+            } while (FALSE);
+            break;
+        }
+        // Check if the device ID received matches the expected length
+        if (OPTIGA_SE_DEVICE_ID_LEN != *len)
+        {
+            return_status = IROT_ERROR_ITEM_NOT_FOUND;
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+
+    if (IROT_SUCCESS != return_status)
+    {
+        *len = 0;
+    }
+
+    return (return_status);
+}
+
+#if ((CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES) || (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_3DES))
+//lint --e{715} suppress "argument "key_id", "iv" and "iv_len" is not used"
+irot_result_t irot_hal_sym_crypto(key_object * key_obj,
+                                  uint8_t key_id,
+                                  const uint8_t * iv,
+                                  uint32_t iv_len,
+                                  const uint8_t * in,
+                                  uint32_t in_len,
+                                  uint8_t * out,
+                                  uint32_t * out_len,
+                                  sym_crypto_param_t * crypto_param)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+  
+    do
+    {
+        // Check for crypt instance NULL 
+        if (FALSE == irot_hal_init_status)
+        {
+            break;
+        }
+
+        // Check for key object NULL
+        if (NULL != key_obj)
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+            break;
+        }
+        
+        // Check the mode for encrypt or decrypt
+        if ((MODE_DECRYPT != crypto_param->mode) && (MODE_ENCRYPT != crypto_param->mode))
+        {
+            return_status = IROT_ERROR_BAD_PARAMETERS;
+            break;
+        }
+        
+        // Check the mode of operation as ECB and no padding
+        if ((BLOCK_MODE_ECB != crypto_param->block_mode) || (SYM_PADDING_NOPADDING != crypto_param->padding_type))
+        {
+            return_status = IROT_ERROR_NOT_IMPLEMENTED;
+            break;
+        }
+                                                        
+        // Check for out buffer length
+        if (*out_len < in_len)
+        {
+            return_status = IROT_ERROR_SHORT_BUFFER;
+            break;
+        }
+        
+        /*
+          Check if request is for decryption or encryption
+        */
+        irot_hal_crypt_status = OPTIGA_LIB_BUSY;
+        if (MODE_DECRYPT == crypto_param->mode)
+        {
+            // Decrypt input data based on symmetric key stored in IROT_HAL_OPTIGA_SYMMETRIC_KEY_OID
+            if (OPTIGA_LIB_SUCCESS != optiga_crypt_symmetric_decrypt_ecb(p_irot_hal_crypt_instance,
+                                                                         IROT_HAL_OPTIGA_KEY_OID,
+                                                                         in,
+                                                                         in_len,
+                                                                         out,
+                                                                         out_len))
+            {
+                break;
+            }
+        }
+        else 
+        {
+            // Encrypt input data based on symmetric key stored in IROT_HAL_OPTIGA_SYMMETRIC_KEY_OID
+            if (OPTIGA_LIB_SUCCESS != optiga_crypt_symmetric_encrypt_ecb(p_irot_hal_crypt_instance,
+                                                                         IROT_HAL_OPTIGA_KEY_OID,
+                                                                         in,
+                                                                         in_len,
+                                                                         out,
+                                                                         out_len))
+            {
+                break;
+            }
+        }
+
+
+
+        while (OPTIGA_LIB_BUSY == irot_hal_crypt_status)
+        {
+            //Wait until the encrypt/decrypt operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_crypt_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_crypt_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+    
+    if (IROT_SUCCESS != return_status)
+    {
+        *out_len = 0;
+    }
+    return (return_status);
+}
+#endif // ((CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_AES) || (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_3DES))
+
+irot_result_t irot_hal_get_random(uint8_t *buf, uint32_t len)
+{
+    // chip_log function is not implemented
+    
+    // API returns IROT_ERROR_NOT_IMPLEMENTED as it's not implemented
+    return IROT_ERROR_NOT_IMPLEMENTED;
+
+}
+
+irot_result_t irot_hal_hash_sum(const uint8_t *in, uint32_t in_len, uint8_t *out, uint32_t *out_len, hash_t type)
+{
+    // chip_log function is not implemented
+    
+    // API returns IROT_ERROR_NOT_IMPLEMENTED as it's not implemented
+    return IROT_ERROR_NOT_IMPLEMENTED;
+
+}
+
+#if (CHIP_CRYPTO_TYPE_CONFIG == CHIP_CRYPTO_TYPE_RSA)
+static irot_result_t irot_hal_generate_hash(const uint8_t *in_data, 
+                                            uint32_t *in_data_len, 
+                                            uint8_t *out_data, 
+                                            uint16_t *out_data_len, 
+                                            optiga_rsa_signature_scheme_t type)
+{
+
+#define OPTIGA_SE_SHA_256_HASH_OUT_LENGTH  (0x20)  
+#define OPTIGA_SE_SHA_384_HASH_OUT_LENGTH  (0x30)  
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+    hash_data_from_host_t hash_data_host;
+    optiga_hash_type_t hash_type;
+
+    do
+    {
+        if (OPTIGA_RSASSA_PKCS1_V15_SHA256 == type)
+        {
+            *out_data_len = OPTIGA_SE_SHA_256_HASH_OUT_LENGTH;
+            hash_type = OPTIGA_HASH_TYPE_SHA_256;
+        }  
+        else if (OPTIGA_RSASSA_PKCS1_V15_SHA384 == type)
+        {
+            return_status = IROT_ERROR_NOT_IMPLEMENTED;
+            break;
+        }
+        hash_data_host.buffer = in_data;
+        hash_data_host.length = *in_data_len;
+        irot_hal_crypt_status = OPTIGA_LIB_BUSY;  
+        if (OPTIGA_LIB_SUCCESS != optiga_crypt_hash(p_irot_hal_crypt_instance, 
+                                                    hash_type, 
+                                                    OPTIGA_CRYPT_HOST_DATA, 
+                                                    &hash_data_host, 
+                                                    out_data))
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == irot_hal_crypt_status)
+        {
+            //Wait until the optiga_crypt_hash operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_crypt_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_crypt_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            break;
+        }
+
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+#undef OPTIGA_SE_SHA_256_HASH_OUT_LENGTH 
+#undef OPTIGA_SE_SHA_384_HASH_OUT_LENGTH
+    return (return_status);
+}
+static irot_result_t irot_hal_get_signature_scheme(asym_sign_verify_t type, 
+                                                   optiga_rsa_signature_scheme_t *signature_scheme)
+{
+    irot_result_t return_status = IROT_SUCCESS;
+    switch(type)
+    {
+        case ASYM_TYPE_RSA_SHA256_PKCS1: 
+        {
+            *signature_scheme = OPTIGA_RSASSA_PKCS1_V15_SHA256;
+        }
+        break;
+        case ASYM_TYPE_RSA_SHA384_PKCS1: 
+        {
+            *signature_scheme = OPTIGA_RSASSA_PKCS1_V15_SHA384;
+        }
+        break;
+        default :
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+        }
+        break;
+    }
+    return (return_status);
+}
+
+irot_result_t irot_hal_asym_priv_sign(key_object *key_obj, 
+                                      uint8_t key_id, 
+                                      const uint8_t *in, 
+                                      uint32_t in_len,
+                                      uint8_t *out, 
+                                      uint32_t *out_len, 
+                                      asym_sign_verify_t type)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+    optiga_rsa_signature_scheme_t signature_scheme;
+    uint16_t digest_len;
+#define OPTIGA_SE_DIGEST_LENGTH (0x30)
+
+    uint8_t digest[OPTIGA_SE_DIGEST_LENGTH];
+    do
+    {   
+        // Check for crypt instance NULL 
+        if (FALSE == irot_hal_init_status)
+        {
+            break;
+        }
+
+        // Check for key object NULL
+        if (NULL != key_obj)
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+            break;
+        }
+
+        // Check supported scheme
+        if (IROT_SUCCESS != irot_hal_get_signature_scheme(type,
+                                                          &signature_scheme))
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+            break;
+        }
+        
+        //Generate hash of input data
+        return_status = irot_hal_generate_hash(in, 
+                                               &in_len, 
+                                               digest, 
+                                               &digest_len,
+                                               signature_scheme);
+        if (IROT_SUCCESS != return_status)
+        {
+            break;
+        }
+        return_status = IROT_ERROR_GENERIC;
+        
+        // Out put boundary check
+        *out_len = (*out_len > OPTIGA_SE_MAX_OUTPUT_LENGTH) ? (OPTIGA_SE_MAX_OUTPUT_LENGTH) : (*out_len);
+        
+        irot_hal_crypt_status = OPTIGA_LIB_BUSY;        
+        // Generate signature of input data based on asymmetric RSA key stored in IROT_HAL_OPTIGA_KEY_OID
+        if (OPTIGA_LIB_SUCCESS != optiga_crypt_rsa_sign(p_irot_hal_crypt_instance,
+                                                        signature_scheme,
+                                                        digest,
+                                                        (uint8_t)digest_len,
+                                                        IROT_HAL_OPTIGA_KEY_OID,
+                                                        out,
+                                                        (uint16_t *)out_len,
+                                                        0x0000))
+        {
+            break;
+        }
+        while (OPTIGA_LIB_BUSY == irot_hal_crypt_status)
+        {
+            //Wait until the rsa sign operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_crypt_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_crypt_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            else if (OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT & irot_hal_crypt_status)
+            {
+                return_status = IROT_ERROR_SHORT_BUFFER;
+            }
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+    
+    if (IROT_SUCCESS != return_status)
+    {
+        *out_len = 0;
+    }    
+#undef OPTIGA_SE_DIGEST_LENGTH
+    return (return_status);
+}
+
+irot_result_t irot_hal_asym_priv_decrypt(key_object *key_obj,
+                                         uint8_t key_id, 
+                                         const uint8_t *in,
+                                         uint32_t in_len,
+                                         uint8_t *out, 
+                                         uint32_t *out_len, 
+                                         irot_asym_padding_t padding)
+{
+    irot_result_t return_status = IROT_ERROR_GENERIC;
+  
+    do
+    {
+        // Check for crypt instance NULL 
+        if (FALSE == irot_hal_init_status)
+        {
+            break;
+        }
+
+        // Check for key object NULL, padding and in_len size
+        if ((NULL != key_obj) || (ASYM_PADDING_PKCS1 != padding) || (in_len != LENGTH_RSA_1024))
+        {
+            return_status = IROT_ERROR_NOT_SUPPORTED;
+            break;
+        }
+
+        *out_len = (*out_len > OPTIGA_SE_MAX_OUTPUT_LENGTH) ? (OPTIGA_SE_MAX_OUTPUT_LENGTH) : (*out_len);
+        
+        /*
+        * Decrypt input data based on asymmetric key stored in IROT_HAL_OPTIGA_KEY_OID
+        */
+        irot_hal_crypt_status = OPTIGA_LIB_BUSY;
+        // RSA decryption
+        if (OPTIGA_LIB_SUCCESS != optiga_crypt_rsa_decrypt_and_export(p_irot_hal_crypt_instance,
+                                                                      OPTIGA_RSAES_PKCS1_V15,
+                                                                      in,
+                                                                      in_len,
+                                                                      NULL,
+                                                                      0,
+                                                                      IROT_HAL_OPTIGA_KEY_OID,
+                                                                      out,
+                                                                      (uint16_t *)out_len))
+        {
+            break;
+        }
+
+        while (OPTIGA_LIB_BUSY == irot_hal_crypt_status)
+        {
+            //Wait until the decrypt operation is completed
+        }
+
+        if (OPTIGA_LIB_SUCCESS != irot_hal_crypt_status)
+        {
+            if (OPTIGA_SE_COMMS_LAYER_ERROR == (irot_hal_crypt_status & OPTIGA_SE_LIB_ERROR_LAYER_MASK))
+            {
+                //Error from OPTIGA Comms.
+                return_status = IROT_ERROR_COMMUNICATION;
+            }
+            else if (OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT == (OPTIGA_CMD_ERROR_MEMORY_INSUFFICIENT & irot_hal_crypt_status))
+            {
+                return_status = IROT_ERROR_SHORT_BUFFER;
+            }
+                
+            break;
+        }
+        return_status = IROT_SUCCESS;
+    } while (FALSE);
+    
+    if (IROT_SUCCESS != return_status)
+    {
+        *out_len = 0;
+    }
+    
+    return (return_status);
+}
+#endif
+
+#endif
+/**
+* @}
+*/
diff --git a/security/itls/lib/xtensa/libitls.a b/security/itls/lib/xtensa/libitls.a
new file mode 100644
index 0000000000000000000000000000000000000000..f909b6a00e38c0e5813c4037df9e7832039b2398
GIT binary patch
literal 111336
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
ZPC3RQ&t;9p#NpHH@!ck0gU`(L{xAAQI*tGU

literal 0
HcmV?d00001

diff --git a/security/itls/src/mbedtls_alt.c b/security/itls/src/mbedtls_alt.c
index d12d518e6..000fbf4fc 100644
--- a/security/itls/src/mbedtls_alt.c
+++ b/security/itls/src/mbedtls_alt.c
@@ -12,7 +12,20 @@
 #include "itls/aes.h"
 #include "itls/sha1.h"
 #include "itls/sha256.h"
-#include "itls/platform.h"
+//#include "itls/platform.h"
+
+extern void free(void *ptr);
+extern void *calloc(size_t nmemb, size_t size);
+
+void *mbedtls_calloc(size_t n, size_t s)
+{
+    return calloc(n, s);
+} 
+
+void mbedtls_free(void *ptr)
+{
+    free(ptr);
+}
 
 #if defined(MBEDTLS_AES_ALT)
 #include "ali_crypto.h"
@@ -294,7 +307,10 @@ void mbedtls_sha256_init_alt(mbedtls_sha256_context *ctx)
 {
     memset(ctx, 0, sizeof(mbedtls_sha256_context));
 }
-
+void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
+{
+    mbedtls_sha256_init_alt(ctx);
+}
 void mbedtls_sha256_free_alt(mbedtls_sha256_context *ctx)
 {
     if (ctx == NULL) {
@@ -308,6 +324,10 @@ void mbedtls_sha256_free_alt(mbedtls_sha256_context *ctx)
     mbedtls_zeroize(ctx, sizeof(mbedtls_sha256_context));
 }
 
+void mbedtls_sha256_free(mbedtls_sha256_context *ctx)
+{
+    mbedtls_sha256_free_alt(ctx);
+}
 void mbedtls_sha256_clone_alt(mbedtls_sha256_context *dst,
                               const mbedtls_sha256_context *src)
 {
@@ -359,6 +379,10 @@ void mbedtls_sha256_starts_alt(mbedtls_sha256_context *ctx, int is224)
     return;
 }
 
+void mbedtls_sha256_starts(mbedtls_sha256_context *ctx, int is224)
+{
+    return mbedtls_sha256_starts_alt(ctx, is224);
+}
 void mbedtls_sha256_update_alt(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
 {
     ali_crypto_result result;
@@ -371,7 +395,10 @@ void mbedtls_sha256_update_alt(mbedtls_sha256_context *ctx, const unsigned char
 
     return;
 }
-
+void mbedtls_sha256_update(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
+{
+    return mbedtls_sha256_update_alt(ctx, input, ilen);
+}
 void mbedtls_sha256_finish_alt(mbedtls_sha256_context *ctx, unsigned char output[32])
 {
     ali_crypto_result result;
@@ -384,7 +411,10 @@ void mbedtls_sha256_finish_alt(mbedtls_sha256_context *ctx, unsigned char output
 
     return;
 }
-
+void mbedtls_sha256_finish(mbedtls_sha256_context *ctx, unsigned char output[32])
+{
+    return mbedtls_sha256_finish_alt(ctx, output);
+}
 void mbedtls_sha256_alt(const unsigned char *input, size_t ilen, unsigned char output[32], int is224)
 {
     mbedtls_sha256_context ctx;
-- 
2.21.0.windows.1

